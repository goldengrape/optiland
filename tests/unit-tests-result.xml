<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="391" skipped="4" tests="3235" time="421.024" timestamp="2025-10-13T17:14:03.700048-07:00" hostname="glaptop-16"><testcase classname="tests.environment.test_air_index" name="test_dispatch_to_correct_model[backend=numpy-ciddor-ciddor_refractive_index]" time="0.003" /><testcase classname="tests.environment.test_air_index" name="test_dispatch_to_correct_model[backend=numpy-edlen-edlen_refractive_index]" time="0.002" /><testcase classname="tests.environment.test_air_index" name="test_dispatch_to_correct_model[backend=numpy-birch_downs-birch_downs_refractive_index]" time="0.002" /><testcase classname="tests.environment.test_air_index" name="test_dispatch_to_correct_model[backend=numpy-kohlrausch-kohlrausch_refractive_index]" time="0.003" /><testcase classname="tests.environment.test_air_index" name="test_dispatch_to_correct_model[backend=torch-ciddor-ciddor_refractive_index]" time="0.075" /><testcase classname="tests.environment.test_air_index" name="test_dispatch_to_correct_model[backend=torch-edlen-edlen_refractive_index]" time="0.006" /><testcase classname="tests.environment.test_air_index" name="test_dispatch_to_correct_model[backend=torch-birch_downs-birch_downs_refractive_index]" time="0.004" /><testcase classname="tests.environment.test_air_index" name="test_dispatch_to_correct_model[backend=torch-kohlrausch-kohlrausch_refractive_index]" time="0.002" /><testcase classname="tests.environment.test_air_index" name="test_unsupported_model_name[backend=numpy]" time="0.002" /><testcase classname="tests.environment.test_air_index" name="test_unsupported_model_name[backend=torch]" time="0.003" /><testcase classname="tests.environment.test_air_index" name="test_invalid_conditions_type[backend=numpy]" time="0.003" /><testcase classname="tests.environment.test_air_index" name="test_invalid_conditions_type[backend=torch]" time="0.002" /><testcase classname="tests.environment.test_air_index" name="test_wavelength_validation_passed_to_models[backend=numpy]" time="0.003" /><testcase classname="tests.environment.test_air_index" name="test_wavelength_validation_passed_to_models[backend=torch]" time="0.001" /><testcase classname="tests.environment.test_air_index" name="test_temperature_validation_passed_to_models[backend=numpy]" time="0.002" /><testcase classname="tests.environment.test_air_index" name="test_temperature_validation_passed_to_models[backend=torch]" time="0.001" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_calculate_saturation_vapor_pressure_standard" time="0.003" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_calculate_water_vapor_partial_pressure_dry_air" time="0.002" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_calculate_water_vapor_partial_pressure_moist_air" time="0.002" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_birch_downs_refractive_index_nist_reference" time="0.003" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_birch_downs_refractive_index_dry_air_different_co2" time="0.002" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_birch_downs_refractive_index_moist_air" time="0.002" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_birch_downs_refractive_index_temperature_effect" time="0.003" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_birch_downs_refractive_index_pressure_effect" time="0.003" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_birch_downs_refractive_index_wavelength_effect" time="0.002" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_birch_downs_refractive_index_edge_wavelengths" time="0.002" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_birch_downs_refractive_index_zero_pressure" time="0.002" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_birch_downs_refractive_index_invalid_wavelength" time="0.002" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_birch_downs_refractive_index_invalid_conditions_type" time="0.001" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_birch_downs_refractive_index_high_humidity_extreme_temp" time="0.002" /><testcase classname="tests.environment.test_birch_downs.TestBirchDownsRefractiveIndex" name="test_birch_downs_refractive_index_low_temp_high_pressure" time="0.002" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_molar_mass_air_standard[backend=numpy]" time="0.002" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_molar_mass_air_standard[backend=torch]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_molar_mass_air_different_co2[backend=numpy]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_molar_mass_air_different_co2[backend=torch]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_saturation_vapor_pressure_standard[backend=numpy]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_saturation_vapor_pressure_standard[backend=torch]" time="0.006" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_saturation_vapor_pressure_edge_cases[backend=numpy]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_saturation_vapor_pressure_edge_cases[backend=torch]" time="0.004" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_saturation_vapor_pressure_no_where_backend" time="0.005" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_enhancement_factor_standard[backend=numpy]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_enhancement_factor_standard[backend=torch]" time="0.005" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_enhancement_factor_edge_cases[backend=numpy]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_enhancement_factor_edge_cases[backend=torch]" time="0.004" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_compressibility_standard[backend=numpy]" time="0.002" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_compressibility_standard[backend=torch]" time="0.002" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_compressibility_moist_air[backend=numpy]" time="0.002" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_calculate_compressibility_moist_air[backend=torch]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_standard_conditions[backend=numpy]" time="0.002" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_standard_conditions[backend=torch]" time="0.008" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_dry_air_different_co2[backend=numpy]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_dry_air_different_co2[backend=torch]" time="0.017" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_moist_air[backend=numpy]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_moist_air[backend=torch]" time="0.008" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_temperature_effect[backend=numpy]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_temperature_effect[backend=torch]" time="0.006" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_pressure_effect[backend=numpy]" time="0.004" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_pressure_effect[backend=torch]" time="0.006" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_wavelength_effect[backend=numpy]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_wavelength_effect[backend=torch]" time="0.005" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_edge_wavelengths[backend=numpy]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_edge_wavelengths[backend=torch]" time="0.008" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_zero_pressure[backend=numpy]" time="0.004" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_zero_pressure[backend=torch]" time="0.006" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_invalid_wavelength[backend=numpy]" time="0.004" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_invalid_wavelength[backend=torch]" time="0.004" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_invalid_conditions_type[backend=numpy]" time="0.002" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_invalid_conditions_type[backend=torch]" time="0.005" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_high_humidity_extreme_temp[backend=numpy]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_high_humidity_extreme_temp[backend=torch]" time="0.007" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_low_temp_high_pressure[backend=numpy]" time="0.003" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_low_temp_high_pressure[backend=torch]" time="0.005" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_consistency_with_example[backend=numpy]" time="0.002" /><testcase classname="tests.environment.test_ciddor.TestCiddorRefractiveIndex" name="test_ciddor_refractive_index_consistency_with_example[backend=torch]" time="0.003" /><testcase classname="tests.environment.test_conditions" name="test_environmental_conditions_defaults" time="0.001" /><testcase classname="tests.environment.test_conditions" name="test_environmental_conditions_custom_values" time="0.001" /><testcase classname="tests.environment.test_conditions" name="test_environmental_conditions_partial_custom_values" time="0.001" /><testcase classname="tests.environment.test_conditions" name="test_environmental_conditions_parametrization[101325-15-0.0-400-None]" time="0.003" /><testcase classname="tests.environment.test_conditions" name="test_environmental_conditions_parametrization[90000-0-0.25-300-0.633]" time="0.003" /><testcase classname="tests.environment.test_conditions" name="test_environmental_conditions_parametrization[110000-30-1.0-800-1.55]" time="0.001" /><testcase classname="tests.environment.test_conditions" name="test_environmental_conditions_types" time="0.002" /><testcase classname="tests.environment.test_conditions" name="test_environmental_conditions_mutability" time="0.002" /><testcase classname="tests.environment.test_edlen.TestEdlenRefractiveIndex" name="test_calculate_saturation_vapor_pressure_standard" time="0.002" /><testcase classname="tests.environment.test_edlen.TestEdlenRefractiveIndex" name="test_calculate_saturation_vapor_pressure_edge_cases" time="0.002" /><testcase classname="tests.environment.test_edlen.TestEdlenRefractiveIndex" name="test_edlen_refractive_index_nist_reference" time="0.002" /><testcase classname="tests.environment.test_edlen.TestEdlenRefractiveIndex" name="test_edlen_refractive_index_dry_air_different_co2" time="0.002" /><testcase classname="tests.environment.test_edlen.TestEdlenRefractiveIndex" name="test_edlen_refractive_index_moist_air" time="0.002" /><testcase classname="tests.environment.test_edlen.TestEdlenRefractiveIndex" name="test_edlen_refractive_index_temperature_effect" time="0.001" /><testcase classname="tests.environment.test_edlen.TestEdlenRefractiveIndex" name="test_edlen_refractive_index_pressure_effect" time="0.002" /><testcase classname="tests.environment.test_edlen.TestEdlenRefractiveIndex" name="test_edlen_refractive_index_wavelength_effect" time="0.001" /><testcase classname="tests.environment.test_edlen.TestEdlenRefractiveIndex" name="test_edlen_refractive_index_edge_wavelengths" time="0.002" /><testcase classname="tests.environment.test_edlen.TestEdlenRefractiveIndex" name="test_edlen_refractive_index_zero_pressure" time="0.002" /><testcase classname="tests.environment.test_edlen.TestEdlenRefractiveIndex" name="test_edlen_refractive_index_invalid_wavelength" time="0.002" /><testcase classname="tests.environment.test_edlen.TestEdlenRefractiveIndex" name="test_edlen_refractive_index_invalid_conditions_type" time="0.002" /><testcase classname="tests.environment.test_edlen.TestEdlenRefractiveIndex" name="test_edlen_refractive_index_high_humidity_extreme_temp" time="0.002" /><testcase classname="tests.environment.test_edlen.TestEdlenRefractiveIndex" name="test_edlen_refractive_index_low_temp_high_pressure" time="0.002" /><testcase classname="tests.environment.test_kohlrausch.TestKohlrauschRefractiveIndex" name="test_kohlrausch_refractive_index_standard_conditions" time="0.002" /><testcase classname="tests.environment.test_kohlrausch.TestKohlrauschRefractiveIndex" name="test_kohlrausch_refractive_index_temperature_effect" time="0.002" /><testcase classname="tests.environment.test_kohlrausch.TestKohlrauschRefractiveIndex" name="test_kohlrausch_refractive_index_pressure_effect" time="0.002" /><testcase classname="tests.environment.test_kohlrausch.TestKohlrauschRefractiveIndex" name="test_kohlrausch_refractive_index_wavelength_effect" time="0.002" /><testcase classname="tests.environment.test_kohlrausch.TestKohlrauschRefractiveIndex" name="test_kohlrausch_refractive_index_edge_wavelengths" time="0.002" /><testcase classname="tests.environment.test_kohlrausch.TestKohlrauschRefractiveIndex" name="test_kohlrausch_refractive_index_zero_pressure" time="0.001" /><testcase classname="tests.environment.test_kohlrausch.TestKohlrauschRefractiveIndex" name="test_kohlrausch_refractive_index_invalid_wavelength_zero" time="0.002" /><testcase classname="tests.environment.test_kohlrausch.TestKohlrauschRefractiveIndex" name="test_kohlrausch_refractive_index_invalid_wavelength_negative" time="0.002" /><testcase classname="tests.environment.test_kohlrausch.TestKohlrauschRefractiveIndex" name="test_kohlrausch_refractive_index_invalid_conditions_type" time="0.002" /><testcase classname="tests.environment.test_kohlrausch.TestKohlrauschRefractiveIndex" name="test_kohlrausch_refractive_index_extreme_low_temperature" time="0.002" /><testcase classname="tests.environment.test_kohlrausch.TestKohlrauschRefractiveIndex" name="test_kohlrausch_refractive_index_high_temp_low_pressure" time="0.002" /><testcase classname="tests.test_aberrations.TestDoubleGaussAberrations" name="test_init[backend=numpy]" time="0.223" /><testcase classname="tests.test_aberrations.TestDoubleGaussAberrations" name="test_init[backend=torch]" time="0.165" /><testcase classname="tests.test_aberrations.TestDoubleGaussAberrations" name="test_seidels[backend=numpy]" time="0.122" /><testcase classname="tests.test_aberrations.TestDoubleGaussAberrations" name="test_seidels[backend=torch]" time="0.328" /><testcase classname="tests.test_aberrations.TestDoubleGaussAberrations" name="test_third_order[backend=numpy]" time="0.139" /><testcase classname="tests.test_aberrations.TestDoubleGaussAberrations" name="test_third_order[backend=torch]" time="0.254" /><testcase classname="tests.test_aberrations.TestDoubleGaussAberrations" name="test_third_order_all_functions[backend=numpy]" time="0.387" /><testcase classname="tests.test_aberrations.TestDoubleGaussAberrations" name="test_third_order_all_functions[backend=torch]" time="1.600" /><testcase classname="tests.test_aberrations.TestEdmundSinglet" name="test_init[backend=numpy]" time="0.025" /><testcase classname="tests.test_aberrations.TestEdmundSinglet" name="test_init[backend=torch]" time="0.026" /><testcase classname="tests.test_aberrations.TestEdmundSinglet" name="test_seidels[backend=numpy]" time="0.036" /><testcase classname="tests.test_aberrations.TestEdmundSinglet" name="test_seidels[backend=torch]" time="0.070" /><testcase classname="tests.test_aberrations.TestEdmundSinglet" name="test_third_order[backend=numpy]" time="0.033" /><testcase classname="tests.test_aberrations.TestEdmundSinglet" name="test_third_order[backend=torch]" time="0.073" /><testcase classname="tests.test_aberrations.TestEdmundSinglet" name="test_third_order_all_functions[backend=numpy]" time="0.097" /><testcase classname="tests.test_aberrations.TestEdmundSinglet" name="test_third_order_all_functions[backend=torch]" time="0.275" /><testcase classname="tests.test_aberrations.TestSingletStopTwo" name="test_init[backend=numpy]" time="0.017" /><testcase classname="tests.test_aberrations.TestSingletStopTwo" name="test_init[backend=torch]" time="0.015" /><testcase classname="tests.test_aberrations.TestSingletStopTwo" name="test_seidels[backend=numpy]" time="0.034" /><testcase classname="tests.test_aberrations.TestSingletStopTwo" name="test_seidels[backend=torch]" time="0.087" /><testcase classname="tests.test_aberrations.TestSingletStopTwo" name="test_third_order[backend=numpy]" time="0.039" /><testcase classname="tests.test_aberrations.TestSingletStopTwo" name="test_third_order[backend=torch]" time="0.084" /><testcase classname="tests.test_aberrations.TestSingletStopTwo" name="test_third_order_all_functions[backend=numpy]" time="0.138" /><testcase classname="tests.test_aberrations.TestSingletStopTwo" name="test_third_order_all_functions[backend=torch]" time="0.584" /><testcase classname="tests.test_aberrations.TestSimpleSinglet" name="test_on_axis_seidels_are_not_zero[backend=numpy]" time="0.063" /><testcase classname="tests.test_aberrations.TestSimpleSinglet" name="test_on_axis_seidels_are_not_zero[backend=torch]" time="0.118" /><testcase classname="tests.test_analysis.TestCookeTripetSpotDiagram" name="test_spot_geometric_radius[backend=numpy]" time="0.258" /><testcase classname="tests.test_analysis.TestCookeTripetSpotDiagram" name="test_spot_geometric_radius[backend=torch]" time="0.677" /><testcase classname="tests.test_analysis.TestCookeTripetSpotDiagram" name="test_spot_rms_radius[backend=numpy]" time="0.246" /><testcase classname="tests.test_analysis.TestCookeTripetSpotDiagram" name="test_spot_rms_radius[backend=torch]" time="0.495" /><testcase classname="tests.test_analysis.TestCookeTripetSpotDiagram" name="test_airy_disc[backend=numpy]" time="0.212" /><testcase classname="tests.test_analysis.TestCookeTripetSpotDiagram" name="test_airy_disc[backend=torch]" time="1.084" /><testcase classname="tests.test_analysis.TestCookeTripetSpotDiagram" name="test_airy_disc_in_view_spot_diagram[backend=numpy]" time="0.666" /><testcase classname="tests.test_analysis.TestCookeTripetSpotDiagram" name="test_airy_disc_in_view_spot_diagram[backend=torch]" time="1.928" /><testcase classname="tests.test_analysis.TestCookeTripetSpotDiagram" name="test_view_spot_diagram[backend=numpy]" time="0.522" /><testcase classname="tests.test_analysis.TestCookeTripetSpotDiagram" name="test_view_spot_diagram[backend=torch]" time="0.815" /><testcase classname="tests.test_analysis.TestCookeTripetSpotDiagram" name="test_view_spot_diagram_larger_fig[backend=numpy]" time="0.464" /><testcase classname="tests.test_analysis.TestCookeTripetSpotDiagram" name="test_view_spot_diagram_larger_fig[backend=torch]" time="0.981" /><testcase classname="tests.test_analysis.TestTripletSpotDiagram" name="test_view_spot_diagram[backend=numpy]" time="0.543" /><testcase classname="tests.test_analysis.TestTripletSpotDiagram" name="test_view_spot_diagram[backend=torch]" time="1.021" /><testcase classname="tests.test_analysis.TestTripletSpotDiagram" name="test_view_spot_diagram_larger_fig[backend=numpy]" time="0.746" /><testcase classname="tests.test_analysis.TestTripletSpotDiagram" name="test_view_spot_diagram_larger_fig[backend=torch]" time="1.109" /><testcase classname="tests.test_analysis.TestCookeTripletEncircledEnergy" name="test_encircled_energy_centroid[backend=numpy]" time="2.521" /><testcase classname="tests.test_analysis.TestCookeTripletEncircledEnergy" name="test_encircled_energy_centroid[backend=torch]" time="3.965" /><testcase classname="tests.test_analysis.TestCookeTripletEncircledEnergy" name="test_view_encircled_energy[backend=numpy]" time="3.486" /><testcase classname="tests.test_analysis.TestCookeTripletEncircledEnergy" name="test_view_encircled_energy[backend=torch]" time="4.027" /><testcase classname="tests.test_analysis.TestCookeTripletEncircledEnergy" name="test_view_encircled_energy_larger_fig[backend=numpy]" time="3.667" /><testcase classname="tests.test_analysis.TestCookeTripletEncircledEnergy" name="test_view_encircled_energy_larger_fig[backend=torch]" time="4.712" /><testcase classname="tests.test_analysis.TestCookeTripletRayFan" name="test_ray_fan[backend=numpy]" time="0.380" /><testcase classname="tests.test_analysis.TestCookeTripletRayFan" name="test_ray_fan[backend=torch]" time="1.179" /><testcase classname="tests.test_analysis.TestCookeTripletRayFan" name="test_view_ray_fan[backend=numpy]" time="0.820" /><testcase classname="tests.test_analysis.TestCookeTripletRayFan" name="test_view_ray_fan[backend=torch]" time="1.469" /><testcase classname="tests.test_analysis.TestCookeTripletRayFan" name="test_view_ray_fan_larger_fig[backend=numpy]" time="0.679" /><testcase classname="tests.test_analysis.TestCookeTripletRayFan" name="test_view_ray_fan_larger_fig[backend=torch]" time="1.324" /><testcase classname="tests.test_analysis.TestTelescopeTripletYYbar" name="test_view_yybar[backend=numpy]" time="0.192" /><testcase classname="tests.test_analysis.TestTelescopeTripletYYbar" name="test_view_yybar[backend=torch]" time="0.251" /><testcase classname="tests.test_analysis.TestTelescopeTripletYYbar" name="test_view_yybar_larger_fig[backend=numpy]" time="0.188" /><testcase classname="tests.test_analysis.TestTelescopeTripletYYbar" name="test_view_yybar_larger_fig[backend=torch]" time="0.207" /><testcase classname="tests.test_analysis.TestTelescopeTripletDistortion" name="test_distortion_values[backend=numpy]" time="0.138" /><testcase classname="tests.test_analysis.TestTelescopeTripletDistortion" name="test_distortion_values[backend=torch]" time="0.227" /><testcase classname="tests.test_analysis.TestTelescopeTripletDistortion" name="test_f_theta_distortion[backend=numpy]" time="0.100" /><testcase classname="tests.test_analysis.TestTelescopeTripletDistortion" name="test_f_theta_distortion[backend=torch]" time="0.259" /><testcase classname="tests.test_analysis.TestTelescopeTripletDistortion" name="test_invalid_distortion_type[backend=numpy]" time="0.091" /><testcase classname="tests.test_analysis.TestTelescopeTripletDistortion" name="test_invalid_distortion_type[backend=torch]" time="0.128" /><testcase classname="tests.test_analysis.TestTelescopeTripletDistortion" name="test_view_distortion[backend=numpy]" time="0.242" /><testcase classname="tests.test_analysis.TestTelescopeTripletDistortion" name="test_view_distortion[backend=torch]" time="0.439" /><testcase classname="tests.test_analysis.TestTelescopeTripletDistortion" name="test_view_distortion_larger_fig[backend=numpy]" time="0.161" /><testcase classname="tests.test_analysis.TestTelescopeTripletDistortion" name="test_view_distortion_larger_fig[backend=torch]" time="0.339" /><testcase classname="tests.test_analysis.TestTelescopeTripletGridDistortion" name="test_grid_distortion_values[backend=numpy]" time="0.135" /><testcase classname="tests.test_analysis.TestTelescopeTripletGridDistortion" name="test_grid_distortion_values[backend=torch]" time="0.291" /><testcase classname="tests.test_analysis.TestTelescopeTripletGridDistortion" name="test_f_theta_distortion[backend=numpy]" time="0.082" /><testcase classname="tests.test_analysis.TestTelescopeTripletGridDistortion" name="test_f_theta_distortion[backend=torch]" time="0.248" /><testcase classname="tests.test_analysis.TestTelescopeTripletGridDistortion" name="test_invalid_distortion_type[backend=numpy]" time="0.102" /><testcase classname="tests.test_analysis.TestTelescopeTripletGridDistortion" name="test_invalid_distortion_type[backend=torch]" time="0.203" /><testcase classname="tests.test_analysis.TestTelescopeTripletGridDistortion" name="test_view_grid_distortion[backend=numpy]" time="0.225" /><testcase classname="tests.test_analysis.TestTelescopeTripletGridDistortion" name="test_view_grid_distortion[backend=torch]" time="0.377" /><testcase classname="tests.test_analysis.TestTelescopeTripletGridDistortion" name="test_view_grid_distortion_larger_fig[backend=numpy]" time="0.265" /><testcase classname="tests.test_analysis.TestTelescopeTripletGridDistortion" name="test_view_grid_distortion_larger_fig[backend=torch]" time="0.836" /><testcase classname="tests.test_analysis.TestTelescopeTripletFieldCurvature" name="test_field_curvature_init[backend=numpy]" time="0.164" /><testcase classname="tests.test_analysis.TestTelescopeTripletFieldCurvature" name="test_field_curvature_init[backend=torch]" time="0.432" /><testcase classname="tests.test_analysis.TestTelescopeTripletFieldCurvature" name="test_field_curvature_init_with_wavelength[backend=numpy]" time="0.137" /><testcase classname="tests.test_analysis.TestTelescopeTripletFieldCurvature" name="test_field_curvature_init_with_wavelength[backend=torch]" time="0.322" /><testcase classname="tests.test_analysis.TestTelescopeTripletFieldCurvature" name="test_field_curvature_init_with_num_points[backend=numpy]" time="0.128" /><testcase classname="tests.test_analysis.TestTelescopeTripletFieldCurvature" name="test_field_curvature_init_with_num_points[backend=torch]" time="0.384" /><testcase classname="tests.test_analysis.TestTelescopeTripletFieldCurvature" name="test_field_curvature_init_with_all_parameters[backend=numpy]" time="0.117" /><testcase classname="tests.test_analysis.TestTelescopeTripletFieldCurvature" name="test_field_curvature_init_with_all_parameters[backend=torch]" time="0.187" /><testcase classname="tests.test_analysis.TestTelescopeTripletFieldCurvature" name="test_field_curvature_view[backend=numpy]" time="0.257" /><testcase classname="tests.test_analysis.TestTelescopeTripletFieldCurvature" name="test_field_curvature_view[backend=torch]" time="0.546" /><testcase classname="tests.test_analysis.TestTelescopeTripletFieldCurvature" name="test_field_curvature_generate_data[backend=numpy]" time="0.157" /><testcase classname="tests.test_analysis.TestTelescopeTripletFieldCurvature" name="test_field_curvature_generate_data[backend=torch]" time="0.399" /><testcase classname="tests.test_analysis.TestSpotVsField" name="test_rms_spot_size_vs_field_initialization[backend=numpy]" time="2.356" /><testcase classname="tests.test_analysis.TestSpotVsField" name="test_rms_spot_size_vs_field_initialization[backend=torch]" time="11.376" /><testcase classname="tests.test_analysis.TestSpotVsField" name="test_rms_spot_radius[backend=numpy]" time="2.651" /><testcase classname="tests.test_analysis.TestSpotVsField" name="test_rms_spot_radius[backend=torch]" time="11.141" /><testcase classname="tests.test_analysis.TestSpotVsField" name="test_view_spot_vs_field[backend=numpy]" time="2.378" /><testcase classname="tests.test_analysis.TestSpotVsField" name="test_view_spot_vs_field[backend=torch]" time="11.164" /><testcase classname="tests.test_analysis.TestSpotVsField" name="test_view_spot_vs_field_larger_fig[backend=numpy]" time="2.462" /><testcase classname="tests.test_analysis.TestSpotVsField" name="test_view_spot_vs_field_larger_fig[backend=torch]" time="11.735" /><testcase classname="tests.test_analysis.TestWavefrontErrorVsField" name="test_rms_wave_init[backend=numpy]" time="0.080"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_analysis.TestWavefrontErrorVsField object at 0x000001478D2CE5D0&gt;
set_test_backend = None
telescope_objective = &lt;optiland.samples.objectives.TripletTelescopeObjective object at 0x00000147B0533E90&gt;

    def test_rms_wave_init(self, set_test_backend, telescope_objective):
&gt;       wavefront_error_vs_field = analysis.RmsWavefrontErrorVsField(
            telescope_objective,
        )

tests\test_analysis.py:717: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\rms_vs_field.py:137: in __init__
    super().__init__(optic, fields, wavelengths, num_rays, distribution)
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001478FD06350&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_analysis.TestWavefrontErrorVsField" name="test_rms_wave_init[backend=torch]" time="0.162"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_analysis.TestWavefrontErrorVsField object at 0x000001478D2CE710&gt;
set_test_backend = None
telescope_objective = &lt;optiland.samples.objectives.TripletTelescopeObjective object at 0x000001479478EA50&gt;

    def test_rms_wave_init(self, set_test_backend, telescope_objective):
&gt;       wavefront_error_vs_field = analysis.RmsWavefrontErrorVsField(
            telescope_objective,
        )

tests\test_analysis.py:717: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\rms_vs_field.py:137: in __init__
    super().__init__(optic, fields, wavelengths, num_rays, distribution)
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014795456ED0&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_analysis.TestWavefrontErrorVsField" name="test_rms_wave[backend=numpy]" time="0.097"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_analysis.TestWavefrontErrorVsField object at 0x000001478D2CEE90&gt;
set_test_backend = None
telescope_objective = &lt;optiland.samples.objectives.TripletTelescopeObjective object at 0x000001479F1A4050&gt;

    def test_rms_wave(self, set_test_backend, telescope_objective):
&gt;       wavefront_error_vs_field = analysis.RmsWavefrontErrorVsField(
            telescope_objective,
        )

tests\test_analysis.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\rms_vs_field.py:137: in __init__
    super().__init__(optic, fields, wavelengths, num_rays, distribution)
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014794A72ED0&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_analysis.TestWavefrontErrorVsField" name="test_rms_wave[backend=torch]" time="0.200"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_analysis.TestWavefrontErrorVsField object at 0x000001478D2CEFD0&gt;
set_test_backend = None
telescope_objective = &lt;optiland.samples.objectives.TripletTelescopeObjective object at 0x000001478F8BEC50&gt;

    def test_rms_wave(self, set_test_backend, telescope_objective):
&gt;       wavefront_error_vs_field = analysis.RmsWavefrontErrorVsField(
            telescope_objective,
        )

tests\test_analysis.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\rms_vs_field.py:137: in __init__
    super().__init__(optic, fields, wavelengths, num_rays, distribution)
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x00000147949F5250&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_analysis.TestWavefrontErrorVsField" name="test_view_wave[backend=numpy]" time="0.152"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_analysis.TestWavefrontErrorVsField object at 0x000001478D2CF750&gt;
set_test_backend = None
telescope_objective = &lt;optiland.samples.objectives.TripletTelescopeObjective object at 0x00000147A0691B90&gt;

    def test_view_wave(self, set_test_backend, telescope_objective):
&gt;       wavefront_error_vs_field = analysis.RmsWavefrontErrorVsField(
            telescope_objective,
        )

tests\test_analysis.py:737: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\rms_vs_field.py:137: in __init__
    super().__init__(optic, fields, wavelengths, num_rays, distribution)
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x00000147B0512A90&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_analysis.TestWavefrontErrorVsField" name="test_view_wave[backend=torch]" time="0.148"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_analysis.TestWavefrontErrorVsField object at 0x000001478D2CF890&gt;
set_test_backend = None
telescope_objective = &lt;optiland.samples.objectives.TripletTelescopeObjective object at 0x000001479F157410&gt;

    def test_view_wave(self, set_test_backend, telescope_objective):
&gt;       wavefront_error_vs_field = analysis.RmsWavefrontErrorVsField(
            telescope_objective,
        )

tests\test_analysis.py:737: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\rms_vs_field.py:137: in __init__
    super().__init__(optic, fields, wavelengths, num_rays, distribution)
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014794B5C050&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_analysis.TestWavefrontErrorVsField" name="test_view_wave_larger_fig[backend=numpy]" time="0.069"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_analysis.TestWavefrontErrorVsField object at 0x000001478D2D0250&gt;
set_test_backend = None
telescope_objective = &lt;optiland.samples.objectives.TripletTelescopeObjective object at 0x00000147B0221A10&gt;

    def test_view_wave_larger_fig(self, set_test_backend, telescope_objective):
&gt;       wavefront_error_vs_field = analysis.RmsWavefrontErrorVsField(
            telescope_objective,
        )

tests\test_analysis.py:748: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\rms_vs_field.py:137: in __init__
    super().__init__(optic, fields, wavelengths, num_rays, distribution)
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479441A390&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_analysis.TestWavefrontErrorVsField" name="test_view_wave_larger_fig[backend=torch]" time="0.148"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_analysis.TestWavefrontErrorVsField object at 0x000001478D2D04D0&gt;
set_test_backend = None
telescope_objective = &lt;optiland.samples.objectives.TripletTelescopeObjective object at 0x000001479F37B6D0&gt;

    def test_view_wave_larger_fig(self, set_test_backend, telescope_objective):
&gt;       wavefront_error_vs_field = analysis.RmsWavefrontErrorVsField(
            telescope_objective,
        )

tests\test_analysis.py:748: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\rms_vs_field.py:137: in __init__
    super().__init__(optic, fields, wavelengths, num_rays, distribution)
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479548EE90&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_analysis.TestPupilAberration" name="test_initialization[backend=numpy]" time="0.317" /><testcase classname="tests.test_analysis.TestPupilAberration" name="test_initialization[backend=torch]" time="1.190" /><testcase classname="tests.test_analysis.TestPupilAberration" name="test_generate_data[backend=numpy]" time="0.567" /><testcase classname="tests.test_analysis.TestPupilAberration" name="test_generate_data[backend=torch]" time="2.451" /><testcase classname="tests.test_analysis.TestPupilAberration" name="test_view[backend=numpy]" time="0.709" /><testcase classname="tests.test_analysis.TestPupilAberration" name="test_view[backend=torch]" time="1.638" /><testcase classname="tests.test_analysis" name="test_spotdiagram_invalid_coordinates" time="0.065" /><testcase classname="tests.test_analysis" name="test_generate_field_data_local[backend=numpy]" time="0.209" /><testcase classname="tests.test_analysis" name="test_generate_field_data_local[backend=torch]" time="0.571" /><testcase classname="tests.test_analysis" name="test_generate_field_data_global[backend=numpy]" time="0.191" /><testcase classname="tests.test_analysis" name="test_generate_field_data_global[backend=torch]" time="0.556" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_v1_uniform_and_user_defined_rays[backend=numpy]" time="1.418" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_v1_uniform_and_user_defined_rays[backend=torch]" time="1.251" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_v1_one_ray_per_other_pixel[backend=numpy]" time="0.235" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_v1_one_ray_per_other_pixel[backend=torch]" time="0.257" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_gaussian_apodization[backend=numpy]" time="0.251" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_gaussian_apodization[backend=torch]" time="0.299" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_perfect_mirror_focus[backend=numpy]" time="0.229" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_perfect_mirror_focus[backend=torch]" time="0.283" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_plot_cross_section_gaussian[backend=numpy]" time="0.524" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_plot_cross_section_gaussian[backend=torch]" time="0.433" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_peak_irradiance[backend=numpy]" time="0.003" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_peak_irradiance[backend=torch]" time="0.015" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_detector_surface_no_aperture[backend=numpy]" time="0.001" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_detector_surface_no_aperture[backend=torch]" time="0.002" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_px_size_overrides_res_warning[backend=numpy]" time="0.211" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_px_size_overrides_res_warning[backend=torch]" time="0.704" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_view_options[backend=numpy]" time="0.407" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_view_options[backend=torch]" time="0.416" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_cross_section_invalid_slice[backend=numpy]" time="0.942" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_cross_section_invalid_slice[backend=torch]" time="0.703" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_view_no_data[backend=numpy]" time="0.009" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_view_no_data[backend=torch]" time="0.021" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_vmin_vmax_equal_case[backend=numpy]" time="0.687" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_vmin_vmax_equal_case[backend=torch]" time="0.741" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_peak_irradiance_empty_data[backend=numpy]" time="0.007" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_peak_irradiance_empty_data[backend=torch]" time="0.032" /><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_autodiff[backend=numpy]" time="0.002"><skipped type="pytest.skip" message="Autodiff test only runs for torch backend">C:\Users\golde\code\optiland\tests\test_analysis.py:1402: Autodiff test only runs for torch backend</skipped></testcase><testcase classname="tests.test_analysis.TestIncoherentIrradiance" name="test_irradiance_autodiff[backend=torch]" time="0.116" /><testcase classname="tests.test_analysis" name="test_incoherent_irradiance_initialization[backend=numpy]" time="0.008" /><testcase classname="tests.test_analysis" name="test_incoherent_irradiance_initialization[backend=torch]" time="0.031" /><testcase classname="tests.test_analysis" name="test_view_normalize_true_peak_zero[backend=numpy]" time="0.230" /><testcase classname="tests.test_analysis" name="test_view_normalize_true_peak_zero[backend=torch]" time="0.243" /><testcase classname="tests.test_analysis" name="test_cross_section_plot_helper_out_of_bounds[backend=numpy]" time="0.019" /><testcase classname="tests.test_analysis" name="test_cross_section_plot_helper_out_of_bounds[backend=torch]" time="0.048" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_init_valid[backend=numpy]" time="0.562" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_init_valid[backend=torch]" time="2.373" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_init_invalid_coordinates[backend=numpy]" time="0.070" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_init_invalid_coordinates[backend=torch]" time="0.071" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_perform_analysis_at_focus_returns_data[backend=numpy]" time="0.460" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_perform_analysis_at_focus_returns_data[backend=torch]" time="1.580" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_validate_view_prerequisites_failure_empty_results[backend=numpy]" time="0.317" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_validate_view_prerequisites_failure_empty_results[backend=torch]" time="1.672" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_validate_view_prerequisites_failure_empty_fields[backend=numpy]" time="0.320" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_validate_view_prerequisites_failure_empty_fields[backend=torch]" time="1.252" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_validate_view_prerequisites_success[backend=numpy]" time="0.313" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_validate_view_prerequisites_success[backend=torch]" time="1.221" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_get_plot_axis_labels_orientation_0[backend=numpy]" time="0.354" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_get_plot_axis_labels_orientation_0[backend=torch]" time="1.339" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_get_spot_centroid_and_axis_limit[backend=numpy]" time="0.317" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_get_spot_centroid_and_axis_limit[backend=torch]" time="1.326" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_view_full[backend=numpy]" time="1.194" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_view_full[backend=torch]" time="2.027" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_view_with_all_zero_intensities[backend=numpy]" time="1.061" /><testcase classname="tests.test_analysis.TestThroughFocusSpotDiagram" name="test_view_with_all_zero_intensities[backend=torch]" time="2.206" /><testcase classname="tests.test_analysis.TestRadiantIntensity" name="test_intensity_output_values[backend=numpy-1-tests/zemax_files/sph_lens_coll_intensity_free_prop.txt-12]" time="5.609" /><testcase classname="tests.test_analysis.TestRadiantIntensity" name="test_intensity_output_values[backend=torch-1-tests/zemax_files/sph_lens_coll_intensity_free_prop.txt-12]" time="5.721" /><testcase classname="tests.test_analysis.TestRadiantIntensity" name="test_view_intensity[backend=numpy]" time="1.630" /><testcase classname="tests.test_analysis.TestRadiantIntensity" name="test_view_intensity[backend=torch]" time="0.574" /><testcase classname="tests.test_analysis.TestRadiantIntensity" name="test_view_intensity_cross_section[backend=numpy]" time="0.157" /><testcase classname="tests.test_analysis.TestRadiantIntensity" name="test_view_intensity_cross_section[backend=torch]" time="0.234" /><testcase classname="tests.test_analysis.TestRadiantIntensity" name="test_view_intensity_normalize[backend=numpy]" time="0.735" /><testcase classname="tests.test_analysis.TestRadiantIntensity" name="test_view_intensity_normalize[backend=torch]" time="0.873" /><testcase classname="tests.test_analysis.TestRadiantIntensity" name="test_intensity_autodiff[backend=numpy]" time="0.001"><skipped type="pytest.skip" message="Autodiff test only runs for torch backend">C:\Users\golde\code\optiland\tests\test_analysis.py:2003: Autodiff test only runs for torch backend</skipped></testcase><testcase classname="tests.test_analysis.TestRadiantIntensity" name="test_intensity_autodiff[backend=torch]" time="0.090" /><testcase classname="tests.test_analysis.TestCookeTripletBestFitRayFan" name="test_initialization[backend=numpy]" time="0.075"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_analysis.TestCookeTripletBestFitRayFan object at 0x000001478D30D510&gt;
set_test_backend = None

    def test_initialization(self, set_test_backend):
        """
        Tests that the BestFitRayFan class initializes correctly,
        setting its own attributes and calling its parent's __init__.
        """
        cooke_triplet = CookeTriplet()
        # Test with default parameters
&gt;       fan = analysis.BestFitRayFan(cooke_triplet)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_analysis.py:2061: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\ray_fan.py:286: in __init__
    super().__init__(optic, fields, wavelengths, num_points)
optiland\analysis\ray_fan.py:56: in __init__
    super().__init__(optic, wavelengths)
optiland\analysis\base.py:35: in __init__
    self.data = self._generate_data()
                ^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\ray_fan.py:316: in _generate_data
    strategy.compute_wavefront_data(field, self.optic.primary_wavelength)
optiland\wavefront\strategy.py:286: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x00000147ADE20650&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_analysis.TestCookeTripletBestFitRayFan" name="test_initialization[backend=torch]" time="0.091"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_analysis.TestCookeTripletBestFitRayFan object at 0x000001478D30D650&gt;
set_test_backend = None

    def test_initialization(self, set_test_backend):
        """
        Tests that the BestFitRayFan class initializes correctly,
        setting its own attributes and calling its parent's __init__.
        """
        cooke_triplet = CookeTriplet()
        # Test with default parameters
&gt;       fan = analysis.BestFitRayFan(cooke_triplet)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_analysis.py:2061: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\ray_fan.py:286: in __init__
    super().__init__(optic, fields, wavelengths, num_points)
optiland\analysis\ray_fan.py:56: in __init__
    super().__init__(optic, wavelengths)
optiland\analysis\base.py:35: in __init__
    self.data = self._generate_data()
                ^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\ray_fan.py:316: in _generate_data
    strategy.compute_wavefront_data(field, self.optic.primary_wavelength)
optiland\wavefront\strategy.py:286: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001478FBA04D0&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_analysis.TestCookeTripletBestFitRayFan" name="test_best_fit_ray_fan_data[backend=numpy]" time="0.055"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_analysis.TestCookeTripletBestFitRayFan object at 0x000001478D30DD90&gt;
set_test_backend = None

    def test_best_fit_ray_fan_data(self, set_test_backend):
        """
        Tests the BestFitRayFan class with a real optical system to ensure
        it runs without errors and that results is similar to standard RayFan.
        """
        cooke_triplet = CookeTriplet()
        num_points = 33
    
        # Perform both standard and best-fit analyses for comparison
&gt;       fan_best_fit = analysis.BestFitRayFan(cooke_triplet, num_points=num_points, num_rays_for_fit=5)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_analysis.py:2082: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\ray_fan.py:286: in __init__
    super().__init__(optic, fields, wavelengths, num_points)
optiland\analysis\ray_fan.py:56: in __init__
    super().__init__(optic, wavelengths)
optiland\analysis\base.py:35: in __init__
    self.data = self._generate_data()
                ^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\ray_fan.py:316: in _generate_data
    strategy.compute_wavefront_data(field, self.optic.primary_wavelength)
optiland\wavefront\strategy.py:286: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001478FB77190&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_analysis.TestCookeTripletBestFitRayFan" name="test_best_fit_ray_fan_data[backend=torch]" time="0.070"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_analysis.TestCookeTripletBestFitRayFan object at 0x000001478D30DED0&gt;
set_test_backend = None

    def test_best_fit_ray_fan_data(self, set_test_backend):
        """
        Tests the BestFitRayFan class with a real optical system to ensure
        it runs without errors and that results is similar to standard RayFan.
        """
        cooke_triplet = CookeTriplet()
        num_points = 33
    
        # Perform both standard and best-fit analyses for comparison
&gt;       fan_best_fit = analysis.BestFitRayFan(cooke_triplet, num_points=num_points, num_rays_for_fit=5)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_analysis.py:2082: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\ray_fan.py:286: in __init__
    super().__init__(optic, fields, wavelengths, num_points)
optiland\analysis\ray_fan.py:56: in __init__
    super().__init__(optic, wavelengths)
optiland\analysis\base.py:35: in __init__
    self.data = self._generate_data()
                ^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\ray_fan.py:316: in _generate_data
    strategy.compute_wavefront_data(field, self.optic.primary_wavelength)
optiland\wavefront\strategy.py:286: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014795419710&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_analysis.TestCookeTripletBestFitRayFan" name="test_view_best_fit_ray_fan[backend=numpy]" time="0.066"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_analysis.TestCookeTripletBestFitRayFan object at 0x000001478D30E650&gt;
set_test_backend = None
cooke_triplet = &lt;optiland.samples.objectives.CookeTriplet object at 0x000001479547B450&gt;

    def test_view_best_fit_ray_fan(self, set_test_backend, cooke_triplet):
&gt;       ray_fan = analysis.BestFitRayFan(cooke_triplet)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_analysis.py:2114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\ray_fan.py:286: in __init__
    super().__init__(optic, fields, wavelengths, num_points)
optiland\analysis\ray_fan.py:56: in __init__
    super().__init__(optic, wavelengths)
optiland\analysis\base.py:35: in __init__
    self.data = self._generate_data()
                ^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\ray_fan.py:316: in _generate_data
    strategy.compute_wavefront_data(field, self.optic.primary_wavelength)
optiland\wavefront\strategy.py:286: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479547BCD0&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_analysis.TestCookeTripletBestFitRayFan" name="test_view_best_fit_ray_fan[backend=torch]" time="0.072"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_analysis.TestCookeTripletBestFitRayFan object at 0x000001478D30E790&gt;
set_test_backend = None
cooke_triplet = &lt;optiland.samples.objectives.CookeTriplet object at 0x0000014794B85690&gt;

    def test_view_best_fit_ray_fan(self, set_test_backend, cooke_triplet):
&gt;       ray_fan = analysis.BestFitRayFan(cooke_triplet)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_analysis.py:2114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\ray_fan.py:286: in __init__
    super().__init__(optic, fields, wavelengths, num_points)
optiland\analysis\ray_fan.py:56: in __init__
    super().__init__(optic, wavelengths)
optiland\analysis\base.py:35: in __init__
    self.data = self._generate_data()
                ^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\ray_fan.py:316: in _generate_data
    strategy.compute_wavefront_data(field, self.optic.primary_wavelength)
optiland\wavefront\strategy.py:286: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001478F896A10&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_analysis.TestCookeTripletBestFitRayFan" name="test_remove_distortion_with_invalid_central_ray[backend=numpy]" time="0.006" /><testcase classname="tests.test_analysis.TestCookeTripletBestFitRayFan" name="test_remove_distortion_with_invalid_central_ray[backend=torch]" time="0.018" /><testcase classname="tests.test_angle_vs_height.TestPupilIncidentAngleVsHeight" name="test_initialization[backend=numpy]" time="0.067" /><testcase classname="tests.test_angle_vs_height.TestPupilIncidentAngleVsHeight" name="test_initialization[backend=torch]" time="0.150" /><testcase classname="tests.test_angle_vs_height.TestPupilIncidentAngleVsHeight" name="test_get_trace_coordinates_axis_y[backend=numpy]" time="0.077" /><testcase classname="tests.test_angle_vs_height.TestPupilIncidentAngleVsHeight" name="test_get_trace_coordinates_axis_y[backend=torch]" time="0.104" /><testcase classname="tests.test_angle_vs_height.TestPupilIncidentAngleVsHeight" name="test_get_trace_coordinates_axis_x[backend=numpy]" time="0.086" /><testcase classname="tests.test_angle_vs_height.TestPupilIncidentAngleVsHeight" name="test_get_trace_coordinates_axis_x[backend=torch]" time="0.122" /><testcase classname="tests.test_angle_vs_height.TestPupilIncidentAngleVsHeight" name="test_generate_data[backend=numpy]" time="0.069" /><testcase classname="tests.test_angle_vs_height.TestPupilIncidentAngleVsHeight" name="test_generate_data[backend=torch]" time="0.121" /><testcase classname="tests.test_angle_vs_height.TestPupilIncidentAngleVsHeight" name="test_view[backend=numpy]" time="0.210" /><testcase classname="tests.test_angle_vs_height.TestPupilIncidentAngleVsHeight" name="test_view[backend=torch]" time="0.242" /><testcase classname="tests.test_angle_vs_height.TestFieldIncidentAngleVsHeight" name="test_initialization[backend=numpy]" time="0.076" /><testcase classname="tests.test_angle_vs_height.TestFieldIncidentAngleVsHeight" name="test_initialization[backend=torch]" time="0.106" /><testcase classname="tests.test_angle_vs_height.TestFieldIncidentAngleVsHeight" name="test_get_trace_coordinates_axis_y[backend=numpy]" time="0.089" /><testcase classname="tests.test_angle_vs_height.TestFieldIncidentAngleVsHeight" name="test_get_trace_coordinates_axis_y[backend=torch]" time="0.117" /><testcase classname="tests.test_angle_vs_height.TestFieldIncidentAngleVsHeight" name="test_get_trace_coordinates_axis_x[backend=numpy]" time="0.074" /><testcase classname="tests.test_angle_vs_height.TestFieldIncidentAngleVsHeight" name="test_get_trace_coordinates_axis_x[backend=torch]" time="0.109" /><testcase classname="tests.test_angle_vs_height.TestFieldIncidentAngleVsHeight" name="test_generate_data[backend=numpy]" time="0.069" /><testcase classname="tests.test_angle_vs_height.TestFieldIncidentAngleVsHeight" name="test_generate_data[backend=torch]" time="0.126" /><testcase classname="tests.test_angle_vs_height.TestFieldIncidentAngleVsHeight" name="test_view[backend=numpy]" time="0.195" /><testcase classname="tests.test_angle_vs_height.TestFieldIncidentAngleVsHeight" name="test_view[backend=torch]" time="0.249" /><testcase classname="tests.test_angle_vs_height.TestAngleVsHeightErrors" name="test_invalid_coord_label_raises_error[backend=numpy]" time="0.072" /><testcase classname="tests.test_angle_vs_height.TestAngleVsHeightErrors" name="test_invalid_coord_label_raises_error[backend=torch]" time="0.114" /><testcase classname="tests.test_angle_vs_height.TestAngleVsHeightErrors" name="test_view_with_different_color_labels[backend=numpy]" time="0.185" /><testcase classname="tests.test_angle_vs_height.TestAngleVsHeightErrors" name="test_view_with_different_color_labels[backend=torch]" time="0.251" /><testcase classname="tests.test_aperture" name="test_aperture_generate[backend=numpy-EPD-10]" time="0.001" /><testcase classname="tests.test_aperture" name="test_aperture_generate[backend=numpy-imageFNO-3.2]" time="0.001" /><testcase classname="tests.test_aperture" name="test_aperture_generate[backend=numpy-objectNA-0.265]" time="0.001" /><testcase classname="tests.test_aperture" name="test_aperture_generate[backend=numpy-float_by_stop_size-1.142857]" time="0.001" /><testcase classname="tests.test_aperture" name="test_aperture_generate[backend=torch-EPD-10]" time="0.001" /><testcase classname="tests.test_aperture" name="test_aperture_generate[backend=torch-imageFNO-3.2]" time="0.002" /><testcase classname="tests.test_aperture" name="test_aperture_generate[backend=torch-objectNA-0.265]" time="0.001" /><testcase classname="tests.test_aperture" name="test_aperture_generate[backend=torch-float_by_stop_size-1.142857]" time="0.002" /><testcase classname="tests.test_aperture" name="test_confirm_invalid_ap_type[backend=numpy]" time="0.001" /><testcase classname="tests.test_aperture" name="test_confirm_invalid_ap_type[backend=torch]" time="0.001" /><testcase classname="tests.test_aperture" name="test_obj_space_telecentric[backend=numpy]" time="0.002" /><testcase classname="tests.test_aperture" name="test_obj_space_telecentric[backend=torch]" time="0.002" /><testcase classname="tests.test_aperture" name="test_to_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_aperture" name="test_to_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_aperture" name="test_from_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_aperture" name="test_from_dict[backend=torch]" time="0.001" /><testcase classname="tests.test_aperture" name="test_invalid_from_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_aperture" name="test_invalid_from_dict[backend=torch]" time="0.001" /><testcase classname="tests.test_aperture" name="test_confirm_stop_size_floating_stop[backend=numpy]" time="0.023" /><testcase classname="tests.test_aperture" name="test_confirm_stop_size_floating_stop[backend=torch]" time="0.032" /><testcase classname="tests.test_apodization" name="test_uniform_apodization_get_intensity[backend=numpy]" time="0.001" /><testcase classname="tests.test_apodization" name="test_uniform_apodization_get_intensity[backend=torch]" time="0.002" /><testcase classname="tests.test_apodization" name="test_gaussian_apodization_get_intensity[backend=numpy]" time="0.002" /><testcase classname="tests.test_apodization" name="test_gaussian_apodization_get_intensity[backend=torch]" time="0.011" /><testcase classname="tests.test_apodization" name="test_apodization_to_dict_uniform[backend=numpy]" time="0.002" /><testcase classname="tests.test_apodization" name="test_apodization_to_dict_uniform[backend=torch]" time="0.002" /><testcase classname="tests.test_apodization" name="test_apodization_to_dict_gaussian[backend=numpy]" time="0.002" /><testcase classname="tests.test_apodization" name="test_apodization_to_dict_gaussian[backend=torch]" time="0.002" /><testcase classname="tests.test_apodization" name="test_apodization_from_dict_uniform[backend=numpy]" time="0.002" /><testcase classname="tests.test_apodization" name="test_apodization_from_dict_uniform[backend=torch]" time="0.002" /><testcase classname="tests.test_apodization" name="test_apodization_from_dict_gaussian[backend=numpy]" time="0.001" /><testcase classname="tests.test_apodization" name="test_apodization_from_dict_gaussian[backend=torch]" time="0.002" /><testcase classname="tests.test_apodization" name="test_apodization_from_dict_gaussian_default_sigma[backend=numpy]" time="0.006" /><testcase classname="tests.test_apodization" name="test_apodization_from_dict_gaussian_default_sigma[backend=torch]" time="0.012" /><testcase classname="tests.test_apodization" name="test_apodization_from_dict_unknown[backend=numpy]" time="0.005" /><testcase classname="tests.test_apodization" name="test_apodization_from_dict_unknown[backend=torch]" time="0.008" /><testcase classname="tests.test_apodization" name="test_set_apodization_uniform[backend=numpy]" time="0.139" /><testcase classname="tests.test_apodization" name="test_set_apodization_uniform[backend=torch]" time="0.062" /><testcase classname="tests.test_apodization" name="test_set_apodization_gaussian[backend=numpy]" time="0.079" /><testcase classname="tests.test_apodization" name="test_set_apodization_gaussian[backend=torch]" time="0.066" /><testcase classname="tests.test_apodization" name="test_set_apodization_invalid_type[backend=numpy]" time="0.064" /><testcase classname="tests.test_apodization" name="test_set_apodization_invalid_type[backend=torch]" time="0.071" /><testcase classname="tests.test_apodization" name="test_set_apodization_none[backend=numpy]" time="0.064" /><testcase classname="tests.test_apodization" name="test_set_apodization_none[backend=torch]" time="0.069" /><testcase classname="tests.test_apodization" name="test_trace_apodization[backend=numpy]" time="0.454" /><testcase classname="tests.test_apodization" name="test_trace_apodization[backend=torch]" time="0.723" /><testcase classname="tests.test_backend" name="test_default_backend" time="0.001" /><testcase classname="tests.test_backend" name="test_list_available_backends" time="0.001" /><testcase classname="tests.test_backend" name="test_invalid_backend" time="0.001" /><testcase classname="tests.test_backend" name="test_getattr_nonexistent_attribute" time="0.001" /><testcase classname="tests.test_backend" name="test_getattr_from_backend" time="0.001" /><testcase classname="tests.test_backend" name="test_getattr_from_backend_lib" time="0.001" /><testcase classname="tests.test_backend" name="test_getattr_fallback_priority" time="0.001" /><testcase classname="tests.test_backend" name="test_get_backend_after_set" time="0.001" /><testcase classname="tests.test_coatings.TestSimpleCoating" name="test_interact_reflect[backend=numpy]" time="0.005" /><testcase classname="tests.test_coatings.TestSimpleCoating" name="test_interact_reflect[backend=torch]" time="0.002" /><testcase classname="tests.test_coatings.TestSimpleCoating" name="test_interact_transmit[backend=numpy]" time="0.003" /><testcase classname="tests.test_coatings.TestSimpleCoating" name="test_interact_transmit[backend=torch]" time="0.003" /><testcase classname="tests.test_coatings.TestSimpleCoating" name="test_compute_aoi[backend=numpy]" time="0.002" /><testcase classname="tests.test_coatings.TestSimpleCoating" name="test_compute_aoi[backend=torch]" time="0.005" /><testcase classname="tests.test_coatings.TestSimpleCoating" name="test_to_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_coatings.TestSimpleCoating" name="test_to_dict[backend=torch]" time="0.001" /><testcase classname="tests.test_coatings.TestFresnelCoating" name="test_reflect[backend=numpy]" time="0.008" /><testcase classname="tests.test_coatings.TestFresnelCoating" name="test_reflect[backend=torch]" time="0.030" /><testcase classname="tests.test_coatings.TestFresnelCoating" name="test_transmit[backend=numpy]" time="0.004" /><testcase classname="tests.test_coatings.TestFresnelCoating" name="test_transmit[backend=torch]" time="0.012" /><testcase classname="tests.test_coatings.TestFresnelCoating" name="test_to_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_coatings.TestFresnelCoating" name="test_to_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_coatings.TestFresnelCoating" name="test_from_dict[backend=numpy]" time="0.003" /><testcase classname="tests.test_coatings.TestFresnelCoating" name="test_from_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_compensator" name="test_initialization_default" time="0.004" /><testcase classname="tests.test_compensator" name="test_initialization_custom" time="0.003" /><testcase classname="tests.test_compensator" name="test_has_variables" time="0.003" /><testcase classname="tests.test_compensator" name="test_run_optimizer_generic" time="0.128" /><testcase classname="tests.test_compensator" name="test_run_optimizer_least_squares" time="0.139" /><testcase classname="tests.test_compensator" name="test_invalid_method[backend=numpy]" time="0.002" /><testcase classname="tests.test_compensator" name="test_invalid_method[backend=torch]" time="0.001" /><testcase classname="tests.test_compensator" name="test_empty_variables_run" time="0.001" /><testcase classname="tests.test_compensator" name="test_tolerance_setting" time="0.001" /><testcase classname="tests.test_compensator" name="test_optimizer_map_content" time="0.001" /><testcase classname="tests.test_coordinate_system" name="test_coordinate_system_init[backend=numpy]" time="0.001" /><testcase classname="tests.test_coordinate_system" name="test_coordinate_system_init[backend=torch]" time="0.001" /><testcase classname="tests.test_coordinate_system" name="test_coordinate_system_localize[backend=numpy]" time="0.001" /><testcase classname="tests.test_coordinate_system" name="test_coordinate_system_localize[backend=torch]" time="0.003" /><testcase classname="tests.test_coordinate_system" name="test_coordinate_system_globalize[backend=numpy]" time="0.002" /><testcase classname="tests.test_coordinate_system" name="test_coordinate_system_globalize[backend=torch]" time="0.004" /><testcase classname="tests.test_coordinate_system" name="test_coordinate_system_transform[backend=numpy]" time="0.003" /><testcase classname="tests.test_coordinate_system" name="test_coordinate_system_transform[backend=torch]" time="0.011" /><testcase classname="tests.test_coordinate_system" name="test_coordinate_system_to_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_coordinate_system" name="test_coordinate_system_to_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_coordinate_system" name="test_coordinate_system_from_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_coordinate_system" name="test_coordinate_system_from_dict[backend=torch]" time="0.001" /><testcase classname="tests.test_distribution" name="test_line_x[backend=numpy-10]" time="0.003" /><testcase classname="tests.test_distribution" name="test_line_x[backend=numpy-25]" time="0.003" /><testcase classname="tests.test_distribution" name="test_line_x[backend=numpy-106]" time="0.002" /><testcase classname="tests.test_distribution" name="test_line_x[backend=numpy-512]" time="0.004" /><testcase classname="tests.test_distribution" name="test_line_x[backend=torch-10]" time="0.002" /><testcase classname="tests.test_distribution" name="test_line_x[backend=torch-25]" time="0.002" /><testcase classname="tests.test_distribution" name="test_line_x[backend=torch-106]" time="0.008" /><testcase classname="tests.test_distribution" name="test_line_x[backend=torch-512]" time="0.006" /><testcase classname="tests.test_distribution" name="test_line_y[backend=numpy-9]" time="0.004" /><testcase classname="tests.test_distribution" name="test_line_y[backend=numpy-60]" time="0.004" /><testcase classname="tests.test_distribution" name="test_line_y[backend=numpy-111]" time="0.003" /><testcase classname="tests.test_distribution" name="test_line_y[backend=numpy-509]" time="0.004" /><testcase classname="tests.test_distribution" name="test_line_y[backend=torch-9]" time="0.006" /><testcase classname="tests.test_distribution" name="test_line_y[backend=torch-60]" time="0.004" /><testcase classname="tests.test_distribution" name="test_line_y[backend=torch-111]" time="0.006" /><testcase classname="tests.test_distribution" name="test_line_y[backend=torch-509]" time="0.006" /><testcase classname="tests.test_distribution" name="test_random[backend=numpy-8]" time="0.006" /><testcase classname="tests.test_distribution" name="test_random[backend=numpy-26]" time="0.010" /><testcase classname="tests.test_distribution" name="test_random[backend=numpy-154]" time="0.003" /><testcase classname="tests.test_distribution" name="test_random[backend=numpy-689]" time="0.005" /><testcase classname="tests.test_distribution" name="test_random[backend=torch-8]" time="0.005" /><testcase classname="tests.test_distribution" name="test_random[backend=torch-26]" time="0.005" /><testcase classname="tests.test_distribution" name="test_random[backend=torch-154]" time="0.004" /><testcase classname="tests.test_distribution" name="test_random[backend=torch-689]" time="0.004" /><testcase classname="tests.test_distribution" name="test_hexapolar[backend=numpy-3]" time="0.005" /><testcase classname="tests.test_distribution" name="test_hexapolar[backend=numpy-7]" time="0.008" /><testcase classname="tests.test_distribution" name="test_hexapolar[backend=numpy-15]" time="0.012" /><testcase classname="tests.test_distribution" name="test_hexapolar[backend=numpy-220]" time="0.214" /><testcase classname="tests.test_distribution" name="test_hexapolar[backend=torch-3]" time="0.005" /><testcase classname="tests.test_distribution" name="test_hexapolar[backend=torch-7]" time="0.007" /><testcase classname="tests.test_distribution" name="test_hexapolar[backend=torch-15]" time="0.029" /><testcase classname="tests.test_distribution" name="test_hexapolar[backend=torch-220]" time="0.221" /><testcase classname="tests.test_distribution" name="test_cross[backend=numpy-15]" time="0.001" /><testcase classname="tests.test_distribution" name="test_cross[backend=numpy-56]" time="0.001" /><testcase classname="tests.test_distribution" name="test_cross[backend=numpy-161]" time="0.001" /><testcase classname="tests.test_distribution" name="test_cross[backend=numpy-621]" time="0.001" /><testcase classname="tests.test_distribution" name="test_cross[backend=torch-15]" time="0.001" /><testcase classname="tests.test_distribution" name="test_cross[backend=torch-56]" time="0.001" /><testcase classname="tests.test_distribution" name="test_cross[backend=torch-161]" time="0.001" /><testcase classname="tests.test_distribution" name="test_cross[backend=torch-621]" time="0.001" /><testcase classname="tests.test_distribution" name="test_view_distribution[backend=numpy]" time="0.009" /><testcase classname="tests.test_distribution" name="test_view_distribution[backend=torch]" time="0.013" /><testcase classname="tests.test_distribution" name="test_invalid_distribution_error[backend=numpy]" time="0.001" /><testcase classname="tests.test_distribution" name="test_invalid_distribution_error[backend=torch]" time="0.001" /><testcase classname="tests.test_distribution" name="test_uniform_distribution[backend=numpy-10]" time="0.003" /><testcase classname="tests.test_distribution" name="test_uniform_distribution[backend=numpy-25]" time="0.002" /><testcase classname="tests.test_distribution" name="test_uniform_distribution[backend=numpy-50]" time="0.004" /><testcase classname="tests.test_distribution" name="test_uniform_distribution[backend=numpy-100]" time="0.003" /><testcase classname="tests.test_distribution" name="test_uniform_distribution[backend=torch-10]" time="0.005" /><testcase classname="tests.test_distribution" name="test_uniform_distribution[backend=torch-25]" time="0.004" /><testcase classname="tests.test_distribution" name="test_uniform_distribution[backend=torch-50]" time="0.005" /><testcase classname="tests.test_distribution" name="test_uniform_distribution[backend=torch-100]" time="0.008" /><testcase classname="tests.test_distribution" name="test_gaussian_quad_distribution[backend=numpy]" time="0.009" /><testcase classname="tests.test_distribution" name="test_gaussian_quad_distribution[backend=torch]" time="0.024" /><testcase classname="tests.test_distribution" name="test_gaussian_quad_distribution_errors[backend=numpy]" time="0.003" /><testcase classname="tests.test_distribution" name="test_gaussian_quad_distribution_errors[backend=torch]" time="0.004" /><testcase classname="tests.test_distribution" name="test_gaussian_quad_weights[backend=numpy]" time="0.005" /><testcase classname="tests.test_distribution" name="test_gaussian_quad_weights[backend=torch]" time="0.013" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_cross_distribution_odd_points[numpy]" time="0.005" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_cross_distribution_odd_points[torch]" time="0.007" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_cross_distribution_even_points[numpy]" time="0.004" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_cross_distribution_even_points[torch]" time="0.005" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_hexagonal_distribution[0-numpy]" time="0.004" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_hexagonal_distribution[0-torch]" time="0.004" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_hexagonal_distribution[1-numpy]" time="0.005" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_hexagonal_distribution[1-torch]" time="0.005" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_hexagonal_distribution[2-numpy]" time="0.003" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_hexagonal_distribution[2-torch]" time="0.004" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_hexagonal_distribution[3-numpy]" time="0.003" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_hexagonal_distribution[3-torch]" time="0.005" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_random_distribution[numpy]" time="0.002" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_random_distribution[torch]" time="0.003" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_uniform_distribution[numpy]" time="0.002" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_uniform_distribution[torch]" time="0.004" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_ring_distribution[numpy]" time="0.002" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_ring_distribution[torch]" time="0.003" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_line_x_distribution[numpy]" time="0.003" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_line_x_distribution[torch]" time="0.001" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_line_y_distribution[numpy]" time="0.003" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_line_y_distribution[torch]" time="0.003" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_gaussian_quadrature_distribution[True-1-numpy]" time="0.003" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_gaussian_quadrature_distribution[True-1-torch]" time="0.004" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_gaussian_quadrature_distribution[True-3-numpy]" time="0.004" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_gaussian_quadrature_distribution[True-3-torch]" time="0.005" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_gaussian_quadrature_distribution[True-5-numpy]" time="0.003" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_gaussian_quadrature_distribution[True-5-torch]" time="0.007" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_gaussian_quadrature_distribution[False-1-numpy]" time="0.004" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_gaussian_quadrature_distribution[False-1-torch]" time="0.005" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_gaussian_quadrature_distribution[False-3-numpy]" time="0.004" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_gaussian_quadrature_distribution[False-3-torch]" time="0.004" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_gaussian_quadrature_distribution[False-5-numpy]" time="0.003" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_gaussian_quadrature_distribution[False-5-torch]" time="0.004" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_cross_distribution_zero_points[numpy]" time="0.003" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_cross_distribution_zero_points[torch]" time="0.002" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_hexagonal_distribution_negative_rings[numpy]" time="0.002" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_hexagonal_distribution_negative_rings[torch]" time="0.003" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_ring_distribution_zero_points[numpy]" time="0.004" /><testcase classname="tests.test_distribution_points.TestDistributionPoints" name="test_ring_distribution_zero_points[torch]" time="0.002" /><testcase classname="tests.test_fft_psf" name="test_initialization[backend=numpy]" time="0.133"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x0000014794AB2660&gt;

    def test_initialization(make_fftpsf):
&gt;       fftpsf = make_fftpsf(grid_size=1024)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_initialization[backend=torch]" time="0.136"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147AA8B0360&gt;

    def test_initialization(make_fftpsf):
&gt;       fftpsf = make_fftpsf(grid_size=1024)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_calculate_grid_size[32-32]" time="0.002" /><testcase classname="tests.test_fft_psf" name="test_calculate_grid_size[64-45]" time="0.001" /><testcase classname="tests.test_fft_psf" name="test_calculate_grid_size[128-64]" time="0.001" /><testcase classname="tests.test_fft_psf" name="test_calculate_grid_size[256-90]" time="0.003" /><testcase classname="tests.test_fft_psf" name="test_calculate_grid_size[512-128]" time="0.001" /><testcase classname="tests.test_fft_psf" name="test_calculate_grid_size[1024-181]" time="0.001" /><testcase classname="tests.test_fft_psf" name="test_calculate_grid_size[2048-256]" time="0.001" /><testcase classname="tests.test_fft_psf" name="test_calculate_grid_size[4096-362]" time="0.001" /><testcase classname="tests.test_fft_psf" name="test_calculate_grid_size[8192-512]" time="0.002" /><testcase classname="tests.test_fft_psf" name="test_num_rays_and_grid_size[backend=numpy-32-32]" time="0.106"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147AD9AD580&gt;
num_rays = 32, expected_pupil_sampling = 32

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(make_fftpsf, num_rays, expected_pupil_sampling):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_and_grid_size[backend=numpy-64-45]" time="0.056"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FB5ED40&gt;
num_rays = 64, expected_pupil_sampling = 45

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(make_fftpsf, num_rays, expected_pupil_sampling):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_and_grid_size[backend=numpy-128-64]" time="0.055"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FB8D3A0&gt;
num_rays = 128, expected_pupil_sampling = 64

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(make_fftpsf, num_rays, expected_pupil_sampling):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_and_grid_size[backend=numpy-256-90]" time="0.076"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FB5CCC0&gt;
num_rays = 256, expected_pupil_sampling = 90

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(make_fftpsf, num_rays, expected_pupil_sampling):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_and_grid_size[backend=numpy-1024-181]" time="0.088"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FB8E980&gt;
num_rays = 1024, expected_pupil_sampling = 181

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(make_fftpsf, num_rays, expected_pupil_sampling):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_and_grid_size[backend=torch-32-32]" time="0.139"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147B01EBA60&gt;
num_rays = 32, expected_pupil_sampling = 32

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(make_fftpsf, num_rays, expected_pupil_sampling):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_and_grid_size[backend=torch-64-45]" time="0.106"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147ABCAAB60&gt;
num_rays = 64, expected_pupil_sampling = 45

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(make_fftpsf, num_rays, expected_pupil_sampling):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_and_grid_size[backend=torch-128-64]" time="0.142"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147A62420C0&gt;
num_rays = 128, expected_pupil_sampling = 64

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(make_fftpsf, num_rays, expected_pupil_sampling):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_and_grid_size[backend=torch-256-90]" time="0.117"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147AD9AC040&gt;
num_rays = 256, expected_pupil_sampling = 90

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(make_fftpsf, num_rays, expected_pupil_sampling):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_and_grid_size[backend=torch-1024-181]" time="0.095"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FB5E480&gt;
num_rays = 1024, expected_pupil_sampling = 181

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(make_fftpsf, num_rays, expected_pupil_sampling):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=None)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_below_32[backend=numpy-32-None-expectation0]" time="0.059"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147B01E8540&gt;
num_rays = 32, grid_size = None
expectation = &lt;contextlib.nullcontext object at 0x000001478D44B690&gt;

    @pytest.mark.parametrize(
        "num_rays,grid_size,expectation",
        [
            (32, None, does_not_raise()),
            (64, None, does_not_raise()),
            (12, 16, does_not_raise()),
            (
                16,
                None,
                pytest.raises(
                    ValueError,
                    match="num_rays must be at least 32 if grid_size is not specified",
                ),
            ),
        ],
    )
    def test_num_rays_below_32(make_fftpsf, num_rays, grid_size, expectation):
        with expectation:
&gt;           make_fftpsf(num_rays=num_rays, grid_size=grid_size)

tests\test_fft_psf.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_below_32[backend=numpy-64-None-expectation1]" time="0.054"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FC00180&gt;
num_rays = 64, grid_size = None
expectation = &lt;contextlib.nullcontext object at 0x000001478D44B410&gt;

    @pytest.mark.parametrize(
        "num_rays,grid_size,expectation",
        [
            (32, None, does_not_raise()),
            (64, None, does_not_raise()),
            (12, 16, does_not_raise()),
            (
                16,
                None,
                pytest.raises(
                    ValueError,
                    match="num_rays must be at least 32 if grid_size is not specified",
                ),
            ),
        ],
    )
    def test_num_rays_below_32(make_fftpsf, num_rays, grid_size, expectation):
        with expectation:
&gt;           make_fftpsf(num_rays=num_rays, grid_size=grid_size)

tests\test_fft_psf.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_below_32[backend=numpy-12-16-expectation2]" time="0.062"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FB8F1A0&gt;
num_rays = 12, grid_size = 16
expectation = &lt;contextlib.nullcontext object at 0x000001478D44B450&gt;

    @pytest.mark.parametrize(
        "num_rays,grid_size,expectation",
        [
            (32, None, does_not_raise()),
            (64, None, does_not_raise()),
            (12, 16, does_not_raise()),
            (
                16,
                None,
                pytest.raises(
                    ValueError,
                    match="num_rays must be at least 32 if grid_size is not specified",
                ),
            ),
        ],
    )
    def test_num_rays_below_32(make_fftpsf, num_rays, grid_size, expectation):
        with expectation:
&gt;           make_fftpsf(num_rays=num_rays, grid_size=grid_size)

tests\test_fft_psf.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_below_32[backend=numpy-16-None-expectation3]" time="0.066" /><testcase classname="tests.test_fft_psf" name="test_num_rays_below_32[backend=torch-32-None-expectation0]" time="0.148"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147B04AD120&gt;
num_rays = 32, grid_size = None
expectation = &lt;contextlib.nullcontext object at 0x000001478D44B690&gt;

    @pytest.mark.parametrize(
        "num_rays,grid_size,expectation",
        [
            (32, None, does_not_raise()),
            (64, None, does_not_raise()),
            (12, 16, does_not_raise()),
            (
                16,
                None,
                pytest.raises(
                    ValueError,
                    match="num_rays must be at least 32 if grid_size is not specified",
                ),
            ),
        ],
    )
    def test_num_rays_below_32(make_fftpsf, num_rays, grid_size, expectation):
        with expectation:
&gt;           make_fftpsf(num_rays=num_rays, grid_size=grid_size)

tests\test_fft_psf.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_below_32[backend=torch-64-None-expectation1]" time="0.128"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147AD9AD4E0&gt;
num_rays = 64, grid_size = None
expectation = &lt;contextlib.nullcontext object at 0x000001478D44B410&gt;

    @pytest.mark.parametrize(
        "num_rays,grid_size,expectation",
        [
            (32, None, does_not_raise()),
            (64, None, does_not_raise()),
            (12, 16, does_not_raise()),
            (
                16,
                None,
                pytest.raises(
                    ValueError,
                    match="num_rays must be at least 32 if grid_size is not specified",
                ),
            ),
        ],
    )
    def test_num_rays_below_32(make_fftpsf, num_rays, grid_size, expectation):
        with expectation:
&gt;           make_fftpsf(num_rays=num_rays, grid_size=grid_size)

tests\test_fft_psf.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_below_32[backend=torch-12-16-expectation2]" time="0.079"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FB8C860&gt;
num_rays = 12, grid_size = 16
expectation = &lt;contextlib.nullcontext object at 0x000001478D44B450&gt;

    @pytest.mark.parametrize(
        "num_rays,grid_size,expectation",
        [
            (32, None, does_not_raise()),
            (64, None, does_not_raise()),
            (12, 16, does_not_raise()),
            (
                16,
                None,
                pytest.raises(
                    ValueError,
                    match="num_rays must be at least 32 if grid_size is not specified",
                ),
            ),
        ],
    )
    def test_num_rays_below_32(make_fftpsf, num_rays, grid_size, expectation):
        with expectation:
&gt;           make_fftpsf(num_rays=num_rays, grid_size=grid_size)

tests\test_fft_psf.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_num_rays_below_32[backend=torch-16-None-expectation3]" time="0.062" /><testcase classname="tests.test_fft_psf" name="test_grid_size[backend=numpy-64-128]" time="0.068"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FB5F880&gt;
num_rays = 64, grid_size = 128

    @pytest.mark.parametrize(
        "num_rays, grid_size",
        [
            (64, 128),
            (65, 256),
            (64, 257),
        ],
    )
    def test_grid_size(make_fftpsf, num_rays, grid_size):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=grid_size)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_grid_size[backend=numpy-65-256]" time="0.081"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x0000014794BC8E00&gt;
num_rays = 65, grid_size = 256

    @pytest.mark.parametrize(
        "num_rays, grid_size",
        [
            (64, 128),
            (65, 256),
            (64, 257),
        ],
    )
    def test_grid_size(make_fftpsf, num_rays, grid_size):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=grid_size)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_grid_size[backend=numpy-64-257]" time="0.079"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FB5C360&gt;
num_rays = 64, grid_size = 257

    @pytest.mark.parametrize(
        "num_rays, grid_size",
        [
            (64, 128),
            (65, 256),
            (64, 257),
        ],
    )
    def test_grid_size(make_fftpsf, num_rays, grid_size):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=grid_size)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_grid_size[backend=torch-64-128]" time="0.122"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x0000014794BCA980&gt;
num_rays = 64, grid_size = 128

    @pytest.mark.parametrize(
        "num_rays, grid_size",
        [
            (64, 128),
            (65, 256),
            (64, 257),
        ],
    )
    def test_grid_size(make_fftpsf, num_rays, grid_size):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=grid_size)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_grid_size[backend=torch-65-256]" time="0.105"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147B01E9580&gt;
num_rays = 65, grid_size = 256

    @pytest.mark.parametrize(
        "num_rays, grid_size",
        [
            (64, 128),
            (65, 256),
            (64, 257),
        ],
    )
    def test_grid_size(make_fftpsf, num_rays, grid_size):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=grid_size)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_grid_size[backend=torch-64-257]" time="0.106"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147AD9AF100&gt;
num_rays = 64, grid_size = 257

    @pytest.mark.parametrize(
        "num_rays, grid_size",
        [
            (64, 128),
            (65, 256),
            (64, 257),
        ],
    )
    def test_grid_size(make_fftpsf, num_rays, grid_size):
&gt;       fftpsf = make_fftpsf(num_rays=num_rays, grid_size=grid_size)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_invalid_grid_size[backend=numpy]" time="0.066" /><testcase classname="tests.test_fft_psf" name="test_invalid_grid_size[backend=torch]" time="0.070" /><testcase classname="tests.test_fft_psf" name="test_strehl_ratio[backend=numpy]" time="0.085"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147AD9AD9E0&gt;

    def test_strehl_ratio(make_fftpsf):
&gt;       fftpsf = make_fftpsf(grid_size=256)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_strehl_ratio[backend=torch]" time="0.129"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147ABCA9A80&gt;

    def test_strehl_ratio(make_fftpsf):
&gt;       fftpsf = make_fftpsf(grid_size=256)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view[backend=numpy-2d-False]" time="0.073"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">projection = '2d', log = False
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147AD9ACFE0&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_fftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view[backend=numpy-3d-False]" time="0.073"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">projection = '3d', log = False
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147B0543740&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_fftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view[backend=numpy-2d-True]" time="0.068"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">projection = '2d', log = True
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147AD9AE660&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_fftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view[backend=numpy-3d-True]" time="0.086"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">projection = '3d', log = True
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147B04993A0&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_fftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view[backend=torch-2d-False]" time="0.110"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">projection = '2d', log = False
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147B01E8A40&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_fftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view[backend=torch-3d-False]" time="0.136"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">projection = '3d', log = False
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FC33B00&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_fftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view[backend=torch-2d-True]" time="0.123"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">projection = '2d', log = True
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x0000014794BC8F40&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_fftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view[backend=torch-3d-True]" time="0.115"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">projection = '3d', log = True
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FB5F740&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_fftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_find_bounds[backend=numpy]" time="0.089"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FB8D9E0&gt;

    def test_find_bounds(make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_find_bounds[backend=torch]" time="0.099"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FC00540&gt;

    def test_find_bounds(make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view_invalid_projection[backend=numpy]" time="0.055"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147AA1CB420&gt;

    def test_view_invalid_projection(make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view_invalid_projection[backend=torch]" time="0.098"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147B0498400&gt;

    def test_view_invalid_projection(make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view_annotate_sampling[backend=numpy-2d]" time="0.068"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">mock_text = &lt;MagicMock name='text' id='1407145262480'&gt;, projection = '2d'
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001479F357880&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    @patch("matplotlib.figure.Figure.text")
    def test_view_annotate_sampling(mock_text, projection, make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view_annotate_sampling[backend=numpy-3d]" time="0.077"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">mock_text = &lt;MagicMock name='text' id='1407371666128'&gt;, projection = '3d'
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147940F71A0&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    @patch("matplotlib.figure.Figure.text")
    def test_view_annotate_sampling(mock_text, projection, make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view_annotate_sampling[backend=torch-2d]" time="0.124"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">mock_text = &lt;MagicMock name='text' id='1406948750864'&gt;, projection = '2d'
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FB5DE40&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    @patch("matplotlib.figure.Figure.text")
    def test_view_annotate_sampling(mock_text, projection, make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view_annotate_sampling[backend=torch-3d]" time="0.135"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">mock_text = &lt;MagicMock name='text' id='1406866167696'&gt;, projection = '3d'
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FB8DC60&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    @patch("matplotlib.figure.Figure.text")
    def test_view_annotate_sampling(mock_text, projection, make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view_oversampling[backend=numpy-2d]" time="0.074"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">projection = '2d'
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147B0498FE0&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    def test_view_oversampling(projection, make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view_oversampling[backend=numpy-3d]" time="0.068"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">projection = '3d'
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FC32C00&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    def test_view_oversampling(projection, make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view_oversampling[backend=torch-2d]" time="0.096"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">projection = '2d'
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147AA1C8FE0&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    def test_view_oversampling(projection, make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_view_oversampling[backend=torch-3d]" time="0.100"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">projection = '3d'
make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147B04B4E00&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    def test_view_oversampling(projection, make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_get_units_finite_obj[backend=numpy]" time="0.090"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x0000014795403240&gt;

    def test_get_units_finite_obj(make_fftpsf):
        def tweak(optic):
            optic.surface_group.surfaces[0].geometry.cs.z = -be.array(1e6)
    
&gt;       fftpsf = make_fftpsf(field=(0, 1), tweak_optic=tweak)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_get_units_finite_obj[backend=torch]" time="0.172"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147B05437E0&gt;

    def test_get_units_finite_obj(make_fftpsf):
        def tweak(optic):
            optic.surface_group.surfaces[0].geometry.cs.z = -be.array(1e6)
    
&gt;       fftpsf = make_fftpsf(field=(0, 1), tweak_optic=tweak)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_psf_log_tick_formatter[backend=numpy]" time="0.087"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147B04B62A0&gt;

    def test_psf_log_tick_formatter(make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_psf_log_tick_formatter[backend=torch]" time="0.109"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147943A4CC0&gt;

    def test_psf_log_tick_formatter(make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_invalid_working_FNO[backend=numpy]" time="0.108"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147AA1C8180&gt;

    def test_invalid_working_FNO(make_fftpsf):
        def tweak(optic):
            optic.surface_group.surfaces[0].geometry.cs.z = -be.array(1e100)
    
&gt;       fftpsf = make_fftpsf(field=(0, 1), tweak_optic=tweak)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_invalid_working_FNO[backend=torch]" time="0.124"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147B0194AE0&gt;

    def test_invalid_working_FNO(make_fftpsf):
        def tweak(optic):
            optic.surface_group.surfaces[0].geometry.cs.z = -be.array(1e100)
    
&gt;       fftpsf = make_fftpsf(field=(0, 1), tweak_optic=tweak)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_interpolate_zoom_factor_one[backend=numpy]" time="0.076"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x0000014795402660&gt;

    def test_interpolate_zoom_factor_one(make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_interpolate_zoom_factor_one[backend=torch]" time="0.100"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x000001478FB5EAC0&gt;

    def test_interpolate_zoom_factor_one(make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_large_threshold[backend=numpy]" time="0.064"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x00000147B01945E0&gt;

    def test_large_threshold(make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_fft_psf" name="test_large_threshold[backend=torch]" time="0.136"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_fftpsf = &lt;function make_fftpsf.&lt;locals&gt;._factory at 0x0000014795401440&gt;

    def test_large_threshold(make_fftpsf):
&gt;       fftpsf = make_fftpsf(field=(0, 1))
                 ^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_fft_psf.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_fft_psf.py:30: in _factory
    return FFTPSF(optic, field, wavelength, num_rays, grid_size)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_field_types" name="test_paraxial_image_height_infinite_object[backend=numpy]" time="0.024" /><testcase classname="tests.test_field_types" name="test_paraxial_image_height_infinite_object[backend=torch]" time="0.035" /><testcase classname="tests.test_field_types" name="test_paraxial_image_height_finite_object[backend=numpy]" time="0.020" /><testcase classname="tests.test_field_types" name="test_paraxial_image_height_finite_object[backend=torch]" time="0.024" /><testcase classname="tests.test_field_types" name="test_field_definition_to_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_field_types" name="test_field_definition_to_dict[backend=torch]" time="0.001" /><testcase classname="tests.test_field_types" name="test_field_definition_from_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_field_types" name="test_field_definition_from_dict[backend=torch]" time="0.001" /><testcase classname="tests.test_field_types" name="test_paraxial_image_height_cooke_triplet[backend=numpy]" time="0.061" /><testcase classname="tests.test_field_types" name="test_paraxial_image_height_cooke_triplet[backend=torch]" time="0.097" /><testcase classname="tests.test_field_types" name="test_paraxial_get_ray_origins[backend=numpy]" time="0.127" /><testcase classname="tests.test_field_types" name="test_paraxial_get_ray_origins[backend=torch]" time="0.206" /><testcase classname="tests.test_field_types" name="test_get_paraxial_object_position[backend=numpy]" time="0.130" /><testcase classname="tests.test_field_types" name="test_get_paraxial_object_position[backend=torch]" time="0.148" /><testcase classname="tests.test_field_types" name="test_get_starting_z_offset[backend=numpy]" time="0.062" /><testcase classname="tests.test_field_types" name="test_get_starting_z_offset[backend=torch]" time="0.069" /><testcase classname="tests.test_fields" name="test_field[backend=numpy-0-0]" time="0.001" /><testcase classname="tests.test_fields" name="test_field[backend=numpy-5.3-8.5]" time="0.002" /><testcase classname="tests.test_fields" name="test_field[backend=numpy-0-4.2]" time="0.001" /><testcase classname="tests.test_fields" name="test_field[backend=torch-0-0]" time="0.002" /><testcase classname="tests.test_fields" name="test_field[backend=torch-5.3-8.5]" time="0.002" /><testcase classname="tests.test_fields" name="test_field[backend=torch-0-4.2]" time="0.002" /><testcase classname="tests.test_fields" name="test_field_group_inputs[backend=numpy]" time="0.002" /><testcase classname="tests.test_fields" name="test_field_group_inputs[backend=torch]" time="0.003" /><testcase classname="tests.test_fields" name="test_field_group_getters[backend=numpy]" time="0.002" /><testcase classname="tests.test_fields" name="test_field_group_getters[backend=torch]" time="0.003" /><testcase classname="tests.test_fields" name="test_field_group_get_vig_factor[backend=numpy]" time="0.003" /><testcase classname="tests.test_fields" name="test_field_group_get_vig_factor[backend=torch]" time="0.005" /><testcase classname="tests.test_fields" name="test_field_group_telecentric[backend=numpy]" time="0.001" /><testcase classname="tests.test_fields" name="test_field_group_telecentric[backend=torch]" time="0.001" /><testcase classname="tests.test_fields" name="test_field_to_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_fields" name="test_field_to_dict[backend=torch]" time="0.001" /><testcase classname="tests.test_fields" name="test_field_group_to_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_fields" name="test_field_group_to_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_fields" name="test_field_from_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_fields" name="test_field_from_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_fields" name="test_field_group_from_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_fields" name="test_field_group_from_dict[backend=torch]" time="0.001" /><testcase classname="tests.test_fileio.TestZemaxFileSourceHandler" name="test_is_url" time="0.001" /><testcase classname="tests.test_fileio.TestZemaxFileSourceHandler" name="test_is_not_url" time="0.001" /><testcase classname="tests.test_fileio.TestZemaxFileSourceHandler" name="test_get_local_file_url" time="0.009" /><testcase classname="tests.test_fileio.TestZemaxFileSourceHandler" name="test_get_local_file_url_fail" time="0.002" /><testcase classname="tests.test_fileio.TestZemaxFileSourceHandler" name="test_get_local_file_local_path" time="0.001" /><testcase classname="tests.test_fileio.TestZemaxDataParser" name="test_read_fno" time="0.001" /><testcase classname="tests.test_fileio.TestZemaxDataParser" name="test_read_epd" time="0.001" /><testcase classname="tests.test_fileio.TestZemaxDataParser" name="test_read_object_na" time="0.001" /><testcase classname="tests.test_fileio.TestZemaxDataParser" name="test_read_conic" time="0.001" /><testcase classname="tests.test_fileio.TestZemaxDataParser" name="test_read_glass" time="0.023" /><testcase classname="tests.test_fileio.TestZemaxDataParser" name="test_read_stop" time="0.001" /><testcase classname="tests.test_fileio.TestZemaxDataParser" name="test_read_mode_valid" time="0.001" /><testcase classname="tests.test_fileio.TestZemaxDataParser" name="test_read_mode_invalid" time="0.001" /><testcase classname="tests.test_fileio.TestZemaxDataParser" name="test_read_surface_type" time="0.002" /><testcase classname="tests.test_fileio.TestEndToEnd" name="test_load_zemax_file" time="0.099" /><testcase classname="tests.test_fileio.TestEndToEnd" name="test_load_and_convert_asphere" time="0.035" /><testcase classname="tests.test_fileio" name="test_save_load_json_obj" time="0.056" /><testcase classname="tests.test_fileio" name="test_load_invalid_json" time="0.001" /><testcase classname="tests.test_fileio" name="test_save_load_optiland_file" time="0.378" /><testcase classname="tests.test_fileio" name="test_load_legacy_optiland_file_with_field_type" time="0.292" /><testcase classname="tests.test_flip_geometries" name="test_flip_standard_geometry" time="0.001" /><testcase classname="tests.test_flip_geometries" name="test_flip_plane_geometry" time="0.001" /><testcase classname="tests.test_flip_geometries" name="test_flip_biconic_geometry" time="0.002" /><testcase classname="tests.test_flip_geometries" name="test_flip_chebyshev_geometry" time="0.001" /><testcase classname="tests.test_flip_geometries" name="test_flip_even_asphere_geometry" time="0.001" /><testcase classname="tests.test_flip_geometries" name="test_flip_odd_asphere_geometry" time="0.002" /><testcase classname="tests.test_flip_geometries" name="test_flip_polynomial_geometry" time="0.002" /><testcase classname="tests.test_flip_geometries" name="test_flip_toroidal_geometry" time="0.003" /><testcase classname="tests.test_flip_geometries" name="test_flip_zernike_geometry" time="0.002" /><testcase classname="tests.test_flip_geometries" name="test_flip_biconic_zero_radius" time="0.002" /><testcase classname="tests.test_flip_geometries" name="test_flip_toroidal_zero_radius" time="0.002" /><testcase classname="tests.test_flip_geometries" name="test_flip_standard_inf_radius" time="0.002" /><testcase classname="tests.test_flip_geometries" name="test_flip_biconic_inf_radius" time="0.001" /><testcase classname="tests.test_flip_geometries" name="test_flip_toroidal_inf_radius" time="0.001" /><testcase classname="tests.test_geometries" name="test_unknown_geometry[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries" name="test_unknown_geometry[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestPlane" name="test_str[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestPlane" name="test_str[backend=torch]" time="0.001" /><testcase classname="tests.test_geometries.TestPlane" name="test_plane_sag[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestPlane" name="test_plane_sag[backend=torch]" time="0.001" /><testcase classname="tests.test_geometries.TestPlane" name="test_plane_distance[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestPlane" name="test_plane_distance[backend=torch]" time="0.004" /><testcase classname="tests.test_geometries.TestPlane" name="test_plane_surface_normal[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestPlane" name="test_plane_surface_normal[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestPlane" name="test_to_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestPlane" name="test_to_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestPlane" name="test_from_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestPlane" name="test_from_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_str[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_str[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_sag_sphere[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_sag_sphere[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_sag_parabola[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_sag_parabola[backend=torch]" time="0.006" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_sag_conic[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_sag_conic[backend=torch]" time="0.004" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_distance[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_distance[backend=torch]" time="0.007" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_surface_normal[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_surface_normal[backend=torch]" time="0.004" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_to_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_to_dict[backend=torch]" time="0.001" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_from_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_from_dict[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_From_dict_invalid_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestStandardGeometry" name="test_From_dict_invalid_dict[backend=torch]" time="0.001" /><testcase classname="tests.test_geometries.TestEvenAsphere" name="test_str[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestEvenAsphere" name="test_str[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestEvenAsphere" name="test_sag[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestEvenAsphere" name="test_sag[backend=torch]" time="0.004" /><testcase classname="tests.test_geometries.TestEvenAsphere" name="test_distance[backend=numpy]" time="0.004" /><testcase classname="tests.test_geometries.TestEvenAsphere" name="test_distance[backend=torch]" time="0.021" /><testcase classname="tests.test_geometries.TestEvenAsphere" name="test_surface_normal[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestEvenAsphere" name="test_surface_normal[backend=torch]" time="0.004" /><testcase classname="tests.test_geometries.TestEvenAsphere" name="test_to_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestEvenAsphere" name="test_to_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestEvenAsphere" name="test_from_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestEvenAsphere" name="test_from_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestPolynomialGeometry" name="test_str[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestPolynomialGeometry" name="test_str[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestPolynomialGeometry" name="test_sag[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestPolynomialGeometry" name="test_sag[backend=torch]" time="0.010" /><testcase classname="tests.test_geometries.TestPolynomialGeometry" name="test_distance[backend=numpy]" time="0.006" /><testcase classname="tests.test_geometries.TestPolynomialGeometry" name="test_distance[backend=torch]" time="0.037" /><testcase classname="tests.test_geometries.TestPolynomialGeometry" name="test_surface_normal[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestPolynomialGeometry" name="test_surface_normal[backend=torch]" time="0.005" /><testcase classname="tests.test_geometries.TestPolynomialGeometry" name="test_to_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestPolynomialGeometry" name="test_to_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestPolynomialGeometry" name="test_from_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestPolynomialGeometry" name="test_from_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestChebyshevGeometry" name="test_str[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestChebyshevGeometry" name="test_str[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestChebyshevGeometry" name="test_sag[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestChebyshevGeometry" name="test_sag[backend=torch]" time="0.019" /><testcase classname="tests.test_geometries.TestChebyshevGeometry" name="test_distance[backend=numpy]" time="0.015" /><testcase classname="tests.test_geometries.TestChebyshevGeometry" name="test_distance[backend=torch]" time="0.096" /><testcase classname="tests.test_geometries.TestChebyshevGeometry" name="test_surface_normal[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestChebyshevGeometry" name="test_surface_normal[backend=torch]" time="0.010" /><testcase classname="tests.test_geometries.TestChebyshevGeometry" name="test_invalid_input[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestChebyshevGeometry" name="test_invalid_input[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestChebyshevGeometry" name="test_to_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestChebyshevGeometry" name="test_to_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestChebyshevGeometry" name="test_from_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestChebyshevGeometry" name="test_from_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestOddAsphere" name="test_sag[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestOddAsphere" name="test_sag[backend=torch]" time="0.004" /><testcase classname="tests.test_geometries.TestOddAsphere" name="test_distance[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestOddAsphere" name="test_distance[backend=torch]" time="0.016" /><testcase classname="tests.test_geometries.TestOddAsphere" name="test_surface_normal[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestOddAsphere" name="test_surface_normal[backend=torch]" time="0.006" /><testcase classname="tests.test_geometries.TestOddAsphere" name="test_str[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestOddAsphere" name="test_str[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_init[backend=numpy-10-expectation0]" time="0.002" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_init[backend=numpy-0-expectation1]" time="0.002" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_init[backend=numpy--5-expectation2]" time="0.003" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_init[backend=torch-10-expectation0]" time="0.001" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_init[backend=torch-0-expectation1]" time="0.003" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_init[backend=torch--5-expectation2]" time="0.003" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_get_coefficients[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_get_coefficients[backend=torch]" time="0.001" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_set_coefficients[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_set_coefficients[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_str[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_str[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_sag[backend=numpy-standard-coefficients0]" time="0.012" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_sag[backend=numpy-noll-coefficients1]" time="0.008" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_sag[backend=numpy-fringe-coefficients2]" time="0.006" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_sag[backend=torch-standard-coefficients0]" time="0.034" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_sag[backend=torch-noll-coefficients1]" time="0.032" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_sag[backend=torch-fringe-coefficients2]" time="0.063" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_surface_normal[backend=numpy-standard-coefficients0]" time="0.007" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_surface_normal[backend=numpy-noll-coefficients1]" time="0.004" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_surface_normal[backend=numpy-fringe-coefficients2]" time="0.005" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_surface_normal[backend=torch-standard-coefficients0]" time="0.039" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_surface_normal[backend=torch-noll-coefficients1]" time="0.030" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_surface_normal[backend=torch-fringe-coefficients2]" time="0.038" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_validate_inputs[backend=numpy-x0-y0-1-expectation0]" time="0.008" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_validate_inputs[backend=numpy-x1-y1-1-expectation1]" time="0.005" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_validate_inputs[backend=numpy--1.1-0-1-expectation2]" time="0.007" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_validate_inputs[backend=numpy-0--1.1-1-expectation3]" time="0.004" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_validate_inputs[backend=numpy-1.1-0-1-expectation4]" time="0.002" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_validate_inputs[backend=numpy-0-1.1-1-expectation5]" time="0.002" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_validate_inputs[backend=torch-x0-y0-1-expectation0]" time="0.002" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_validate_inputs[backend=torch-x1-y1-1-expectation1]" time="0.003" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_validate_inputs[backend=torch--1.1-0-1-expectation2]" time="0.003" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_validate_inputs[backend=torch-0--1.1-1-expectation3]" time="0.002" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_validate_inputs[backend=torch-1.1-0-1-expectation4]" time="0.002" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_validate_inputs[backend=torch-0-1.1-1-expectation5]" time="0.002" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_to_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_to_dict[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_from_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestZernikeGeometry" name="test_from_dict[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_str[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_str[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_sag_vertex[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_sag_vertex[backend=torch]" time="0.004" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_normal_vertex[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_normal_vertex[backend=torch]" time="0.009" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_sag_known_points[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_sag_known_points[backend=torch]" time="0.006" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_normal_known_points[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_normal_known_points[backend=torch]" time="0.010" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_cylinder_x_sag[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_cylinder_x_sag[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_cylinder_y_sag[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_cylinder_y_sag[backend=torch]" time="0.004" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroid_no_x_curvature_sag[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroid_no_x_curvature_sag[backend=torch]" time="0.007" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroid_no_y_curvature_sag[backend=numpy]" time="0.005" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroid_no_y_curvature_sag[backend=torch]" time="0.006" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_sag_vs_zemax[backend=numpy]" time="0.004" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_sag_vs_zemax[backend=torch]" time="0.007" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_ray_tracing_comparison[backend=numpy]" time="0.013" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_ray_tracing_comparison[backend=torch]" time="0.043" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_ray_tracing_comparison_negRx[backend=numpy]" time="0.046" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_ray_tracing_comparison_negRx[backend=torch]" time="0.087" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_to_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_to_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_from_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_from_dict[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_from_dict_invalid[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_toroidal_from_dict_invalid[backend=torch]" time="0.001" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_inf_radius_intersect_sphere_normal_incidence[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestToroidalGeometry" name="test_inf_radius_intersect_sphere_normal_incidence[backend=torch]" time="0.004" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_str[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_str[backend=torch]" time="0.004" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_sag_vertex[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_sag_vertex[backend=torch]" time="0.006" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_sag_finite_radii[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_sag_finite_radii[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_sag_rx_infinite[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_sag_rx_infinite[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_sag_ry_infinite[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_sag_ry_infinite[backend=torch]" time="0.004" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_sag_both_infinite_plane[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_sag_both_infinite_plane[backend=torch]" time="0.004" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_sag_with_conics[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_sag_with_conics[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_sag_array_input[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_sag_array_input[backend=torch]" time="0.005" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_surface_normal_vertex[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_surface_normal_vertex[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_surface_normal_spherical_case[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_surface_normal_spherical_case[backend=torch]" time="0.005" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_surface_normal_cylindrical_rx_inf[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_surface_normal_cylindrical_rx_inf[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_surface_normal_array_input[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_surface_normal_array_input[backend=torch]" time="0.007" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_distance_simple[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_distance_simple[backend=torch]" time="0.006" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_distance_planar_biconic[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_distance_planar_biconic[backend=torch]" time="0.003" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_to_dict_from_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_to_dict_from_dict[backend=torch]" time="0.006" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_from_dict_missing_keys[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_from_dict_missing_keys[backend=torch]" time="0.001" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_from_dict_default_conics_tol_max_iter[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestBiconicGeometry" name="test_from_dict_default_conics_tol_max_iter[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_str[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_str[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_sag_with_infinite_radius[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_sag_with_infinite_radius[backend=torch]" time="0.004" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_sag_outside_norm_radius[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_sag_outside_norm_radius[backend=torch]" time="0.005" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_analytical_normal_vs_autodiff[backend=numpy]" time="0.002"><skipped type="pytest.skip" message="This test requires both numpy and torch backends to compare.">C:\Users\golde\code\optiland\tests\test_geometries.py:2193: This test requires both numpy and torch backends to compare.</skipped></testcase><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_analytical_normal_vs_autodiff[backend=torch]" time="1.840" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_sag_vs_zemax[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_sag_vs_zemax[backend=torch]" time="0.011" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_surface_normal_at_vertex[backend=numpy]" time="0.004" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_surface_normal_at_vertex[backend=torch]" time="0.010" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_tracing[backend=numpy]" time="0.060" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_tracing[backend=torch]" time="0.429" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_ray_tracing_autodiff_off_axis[torch]" time="0.080" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_ray_tracing_autodiff_at_vertex[torch]" time="0.060" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_forbes_qbfs_autodiff_inplace_modification[torch]" time="0.097" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_to_dict_from_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestForbesQbfsGeometry" name="test_to_dict_from_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestForbesQ2dGeometry" name="test_str[backend=numpy]" time="0.001" /><testcase classname="tests.test_geometries.TestForbesQ2dGeometry" name="test_str[backend=torch]" time="0.002" /><testcase classname="tests.test_geometries.TestForbesQ2dGeometry" name="test_init_no_coeffs[backend=numpy]" time="0.002" /><testcase classname="tests.test_geometries.TestForbesQ2dGeometry" name="test_init_no_coeffs[backend=torch]" time="0.001" /><testcase classname="tests.test_geometries.TestForbesQ2dGeometry" name="test_sag_symmetric_terms_only[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestForbesQ2dGeometry" name="test_sag_symmetric_terms_only[backend=torch]" time="0.009" /><testcase classname="tests.test_geometries.TestForbesQ2dGeometry" name="test_sag_with_sine_term[backend=numpy]" time="0.004" /><testcase classname="tests.test_geometries.TestForbesQ2dGeometry" name="test_sag_with_sine_term[backend=torch]" time="0.009" /><testcase classname="tests.test_geometries.TestForbesQ2dGeometry" name="test_prepare_coeffs[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestForbesQ2dGeometry" name="test_prepare_coeffs[backend=torch]" time="0.006" /><testcase classname="tests.test_geometries.TestForbesQ2dGeometry" name="test_gradient_stability_at_vertex[torch]" time="0.073" /><testcase classname="tests.test_geometries.TestForbesQ2dGeometry" name="test_to_dict_from_dict[backend=numpy]" time="0.003" /><testcase classname="tests.test_geometries.TestForbesQ2dGeometry" name="test_to_dict_from_dict[backend=torch]" time="0.005" /><testcase classname="tests.test_geometries.TestForbesValidation" name="test_qpoly_qnm_against_paper_formulas[2-0-0.5-0.7071067811865475]" time="0.005" /><testcase classname="tests.test_geometries.TestForbesValidation" name="test_qpoly_qnm_against_paper_formulas[1-1-0.25-2.0647416048350555]" time="0.005" /><testcase classname="tests.test_geometries.TestForbesValidation" name="test_qpoly_qnm_against_paper_formulas[0-1-0.75-0.22941573387056174]" time="0.004"><skipped type="pytest.skip" message="Skipping direct Qnm validation; covered by full sag test.">C:\Users\golde\code\optiland\tests\test_geometries.py:2684: Skipping direct Qnm validation; covered by full sag test.</skipped></testcase><testcase classname="tests.test_geometries.TestForbesValidation" name="test_qnm_values_against_analytical_formula[backend=numpy]" time="0.004" /><testcase classname="tests.test_geometries.TestForbesValidation" name="test_qnm_values_against_analytical_formula[backend=torch]" time="0.013" /><testcase classname="tests.test_geometries.TestForbesValidation" name="test_q2d_normal_against_numerical_derivative" time="0.016" /><testcase classname="tests.test_geometries.TestForbesValidation" name="test_complex_ray_tracing[backend=numpy]" time="0.093" /><testcase classname="tests.test_geometries.TestForbesValidation" name="test_complex_ray_tracing[backend=torch]" time="0.324" /><testcase classname="tests.test_gradient_material" name="test_gradient_material_initialization" time="0.001" /><testcase classname="tests.test_gradient_material" name="test_immutability" time="0.001" /><testcase classname="tests.test_gradient_material" name="test_get_index_on_axis" time="0.002" /><testcase classname="tests.test_gradient_material" name="test_get_index_off_axis" time="0.002" /><testcase classname="tests.test_gradient_material" name="test_get_gradient_on_axis" time="0.007" /><testcase classname="tests.test_gradient_material" name="test_get_gradient_off_axis" time="0.004" /><testcase classname="tests.test_gradient_material" name="test_get_index_and_gradient" time="0.002" /><testcase classname="tests.test_gradient_material" name="test_icontract_invariant_violation" time="0.023" /><testcase classname="tests.test_gradient_material" name="test_icontract_require_violation" time="0.014" /><testcase classname="tests.test_gradient_propagation" name="test_propagate_through_radial_grin_lens" time="0.101" /><testcase classname="tests.test_gradient_surface" name="test_gradient_boundary_surface_inheritance" time="0.001" /><testcase classname="tests.test_gradient_surface" name="test_gradient_boundary_surface_default_instantiation" time="0.001" /><testcase classname="tests.test_gradient_surface" name="test_gradient_boundary_surface_specific_instantiation" time="0.001" /><testcase classname="tests.test_gradient_surface" name="test_gradient_boundary_surface_is_a_marker_type" time="0.001" /><testcase classname="tests.test_grating" name="test_flat_grating_transmission[backend=numpy]" time="0.058" /><testcase classname="tests.test_grating" name="test_flat_grating_transmission[backend=torch]" time="0.144" /><testcase classname="tests.test_grating" name="test_curved_grating_transmission[backend=numpy]" time="0.043" /><testcase classname="tests.test_grating" name="test_curved_grating_transmission[backend=torch]" time="0.197" /><testcase classname="tests.test_grating" name="test_curved_grating_reflection[backend=numpy]" time="0.014" /><testcase classname="tests.test_grating" name="test_curved_grating_reflection[backend=torch]" time="0.029" /><testcase classname="tests.test_grating" name="test_paraxial_flat_grating_transmission[backend=numpy]" time="0.035" /><testcase classname="tests.test_grating" name="test_paraxial_flat_grating_transmission[backend=torch]" time="0.095" /><testcase classname="tests.test_huygens_mtf.TestHuygensMTF" name="test_backend_not_numpy_raises" time="0.141" /><testcase classname="tests.test_huygens_mtf.TestHuygensMTF" name="test_init_sets_attributes_cutoff" time="0.171"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_mtf.TestHuygensMTF object at 0x000001478D757CD0&gt;
real_optic = &lt;optiland.samples.objectives.DoubleGauss object at 0x00000147B01CC050&gt;

    def test_init_sets_attributes_cutoff(self, real_optic):
        with patch("optiland.backend.get_backend", return_value="numpy"):
&gt;           mtf = HuygensMTF(real_optic, max_freq="cutoff", image_size=16)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_huygens_mtf.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\huygens_fresnel.py:71: in __init__
    super().__init__(optic, fields, wavelength)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\huygens_fresnel.py:93: in _calculate_psf
    psf_calculator = HuygensPSF(
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_mtf.TestHuygensMTF" name="test_init_non_primary_wavelength" time="0.165"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_mtf.TestHuygensMTF object at 0x000001478D75C310&gt;
real_optic = &lt;optiland.samples.objectives.DoubleGauss object at 0x00000147953C2810&gt;

    def test_init_non_primary_wavelength(self, real_optic):
&gt;       mtf = HuygensMTF(real_optic, max_freq="cutoff", image_size=16, wavelength=0.55)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_huygens_mtf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\huygens_fresnel.py:71: in __init__
    super().__init__(optic, fields, wavelength)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\huygens_fresnel.py:93: in _calculate_psf
    psf_calculator = HuygensPSF(
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_mtf.TestHuygensMTF" name="test_init_with_numeric_max_freq" time="0.157"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_mtf.TestHuygensMTF object at 0x000001478D75C990&gt;
real_optic = &lt;optiland.samples.objectives.DoubleGauss object at 0x00000147B016CD90&gt;

    def test_init_with_numeric_max_freq(self, real_optic):
&gt;       mtf = HuygensMTF(real_optic, max_freq=200.0, image_size=8)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_huygens_mtf.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\huygens_fresnel.py:71: in __init__
    super().__init__(optic, fields, wavelength)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\huygens_fresnel.py:93: in _calculate_psf
    psf_calculator = HuygensPSF(
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_mtf.TestHuygensMTF" name="test_get_fno" time="0.214"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_mtf.TestHuygensMTF object at 0x000001478D75CFD0&gt;
real_optic = &lt;optiland.samples.objectives.DoubleGauss object at 0x00000147953E3350&gt;

    def test_get_fno(self, real_optic):
&gt;       mtf = HuygensMTF(real_optic, image_size=8)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_huygens_mtf.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\huygens_fresnel.py:71: in __init__
    super().__init__(optic, fields, wavelength)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\huygens_fresnel.py:93: in _calculate_psf
    psf_calculator = HuygensPSF(
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_mtf.TestHuygensMTF" name="test_calculate_psf_stores_data" time="0.250"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_mtf.TestHuygensMTF object at 0x000001478D75D610&gt;
real_optic = &lt;optiland.samples.objectives.DoubleGauss object at 0x000001479F1C0310&gt;

    def test_calculate_psf_stores_data(self, real_optic):
&gt;       mtf = HuygensMTF(real_optic, image_size=8)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_huygens_mtf.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\huygens_fresnel.py:71: in __init__
    super().__init__(optic, fields, wavelength)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\huygens_fresnel.py:93: in _calculate_psf
    psf_calculator = HuygensPSF(
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_mtf.TestHuygensMTF" name="test_generate_mtf_data_normalization" time="0.146"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_mtf.TestHuygensMTF object at 0x000001478D75DC50&gt;
real_optic = &lt;optiland.samples.objectives.DoubleGauss object at 0x00000147ADE16950&gt;

    def test_generate_mtf_data_normalization(self, real_optic):
&gt;       mtf = HuygensMTF(real_optic, image_size=8)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_huygens_mtf.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\huygens_fresnel.py:71: in __init__
    super().__init__(optic, fields, wavelength)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\huygens_fresnel.py:93: in _calculate_psf
    psf_calculator = HuygensPSF(
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_mtf.TestHuygensMTF" name="test_generate_mtf_data_divide_by_zero" time="0.169"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_mtf.TestHuygensMTF object at 0x000001478D75E290&gt;
real_optic = &lt;optiland.samples.objectives.DoubleGauss object at 0x0000014794341AD0&gt;

    def test_generate_mtf_data_divide_by_zero(self, real_optic):
&gt;       mtf = HuygensMTF(real_optic, image_size=8)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_huygens_mtf.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\huygens_fresnel.py:71: in __init__
    super().__init__(optic, fields, wavelength)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\huygens_fresnel.py:93: in _calculate_psf
    psf_calculator = HuygensPSF(
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_mtf.TestHuygensMTF" name="test_plot_field_mtf_runs" time="0.131"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_mtf.TestHuygensMTF object at 0x000001478D75E8D0&gt;
real_optic = &lt;optiland.samples.objectives.DoubleGauss object at 0x00000147A05EA590&gt;

    def test_plot_field_mtf_runs(self, real_optic):
        import matplotlib.pyplot as plt
    
&gt;       mtf = HuygensMTF(real_optic, image_size=8)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_huygens_mtf.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\huygens_fresnel.py:71: in __init__
    super().__init__(optic, fields, wavelength)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\huygens_fresnel.py:93: in _calculate_psf
    psf_calculator = HuygensPSF(
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_mtf.TestHuygensMTF" name="test_get_mtf_units_valid_and_invalid" time="0.143"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_mtf.TestHuygensMTF object at 0x000001478D75EED0&gt;
real_optic = &lt;optiland.samples.objectives.DoubleGauss object at 0x0000014794A83D50&gt;

    def test_get_mtf_units_valid_and_invalid(self, real_optic):
&gt;       mtf = HuygensMTF(real_optic, image_size=8)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_huygens_mtf.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\huygens_fresnel.py:71: in __init__
    super().__init__(optic, fields, wavelength)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\huygens_fresnel.py:93: in _calculate_psf
    psf_calculator = HuygensPSF(
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_mtf.TestHuygensMTF" name="test_integration_with_doublegauss" time="0.124"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_mtf.TestHuygensMTF object at 0x000001478D75F5D0&gt;
real_optic = &lt;optiland.samples.objectives.DoubleGauss object at 0x0000014794A76C90&gt;

    def test_integration_with_doublegauss(self, real_optic):
        """Full PSF + MTF calculation with a real optic (low resolution for speed)."""
&gt;       mtf = HuygensMTF(real_optic, fields=[(0, 0)], image_size=16)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_huygens_mtf.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\huygens_fresnel.py:71: in __init__
    super().__init__(optic, fields, wavelength)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\huygens_fresnel.py:93: in _calculate_psf
    psf_calculator = HuygensPSF(
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_huygens_psf_initialization[field0-cooke_triplet_optic]" time="0.067"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D76E010&gt;
optic_fixture_name = 'cooke_triplet_optic', field = (0, 0)
request = &lt;FixtureRequest for &lt;Function test_huygens_psf_initialization[field0-cooke_triplet_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("field", FIELDS_TO_TEST)
    def test_huygens_psf_initialization(self, optic_fixture_name, field, request):
        """
        Tests the initialization of HuygensPSF instance, checking attributes
        and that the PSF is computed.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_huygens_psf_initialization[field0-double_gauss_optic]" time="0.147"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D76E910&gt;
optic_fixture_name = 'double_gauss_optic', field = (0, 0)
request = &lt;FixtureRequest for &lt;Function test_huygens_psf_initialization[field0-double_gauss_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("field", FIELDS_TO_TEST)
    def test_huygens_psf_initialization(self, optic_fixture_name, field, request):
        """
        Tests the initialization of HuygensPSF instance, checking attributes
        and that the PSF is computed.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_huygens_psf_initialization[field0-reverse_telephoto_optic]" time="0.174"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D76EA50&gt;
optic_fixture_name = 'reverse_telephoto_optic', field = (0, 0)
request = &lt;FixtureRequest for &lt;Function test_huygens_psf_initialization[field0-reverse_telephoto_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("field", FIELDS_TO_TEST)
    def test_huygens_psf_initialization(self, optic_fixture_name, field, request):
        """
        Tests the initialization of HuygensPSF instance, checking attributes
        and that the PSF is computed.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_huygens_psf_initialization[field1-cooke_triplet_optic]" time="0.010"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D76EB90&gt;
optic_fixture_name = 'cooke_triplet_optic', field = (0.5, 0.0)
request = &lt;FixtureRequest for &lt;Function test_huygens_psf_initialization[field1-cooke_triplet_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("field", FIELDS_TO_TEST)
    def test_huygens_psf_initialization(self, optic_fixture_name, field, request):
        """
        Tests the initialization of HuygensPSF instance, checking attributes
        and that the PSF is computed.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_huygens_psf_initialization[field1-double_gauss_optic]" time="0.036"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D76ECD0&gt;
optic_fixture_name = 'double_gauss_optic', field = (0.5, 0.0)
request = &lt;FixtureRequest for &lt;Function test_huygens_psf_initialization[field1-double_gauss_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("field", FIELDS_TO_TEST)
    def test_huygens_psf_initialization(self, optic_fixture_name, field, request):
        """
        Tests the initialization of HuygensPSF instance, checking attributes
        and that the PSF is computed.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_huygens_psf_initialization[field1-reverse_telephoto_optic]" time="0.022"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D76EE10&gt;
optic_fixture_name = 'reverse_telephoto_optic', field = (0.5, 0.0)
request = &lt;FixtureRequest for &lt;Function test_huygens_psf_initialization[field1-reverse_telephoto_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("field", FIELDS_TO_TEST)
    def test_huygens_psf_initialization(self, optic_fixture_name, field, request):
        """
        Tests the initialization of HuygensPSF instance, checking attributes
        and that the PSF is computed.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_huygens_psf_initialization[field2-cooke_triplet_optic]" time="0.026"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D76F010&gt;
optic_fixture_name = 'cooke_triplet_optic', field = (0.0, 0.7)
request = &lt;FixtureRequest for &lt;Function test_huygens_psf_initialization[field2-cooke_triplet_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("field", FIELDS_TO_TEST)
    def test_huygens_psf_initialization(self, optic_fixture_name, field, request):
        """
        Tests the initialization of HuygensPSF instance, checking attributes
        and that the PSF is computed.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_huygens_psf_initialization[field2-double_gauss_optic]" time="0.027"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D76F310&gt;
optic_fixture_name = 'double_gauss_optic', field = (0.0, 0.7)
request = &lt;FixtureRequest for &lt;Function test_huygens_psf_initialization[field2-double_gauss_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("field", FIELDS_TO_TEST)
    def test_huygens_psf_initialization(self, optic_fixture_name, field, request):
        """
        Tests the initialization of HuygensPSF instance, checking attributes
        and that the PSF is computed.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_huygens_psf_initialization[field2-reverse_telephoto_optic]" time="0.014"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D76F610&gt;
optic_fixture_name = 'reverse_telephoto_optic', field = (0.0, 0.7)
request = &lt;FixtureRequest for &lt;Function test_huygens_psf_initialization[field2-reverse_telephoto_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("field", FIELDS_TO_TEST)
    def test_huygens_psf_initialization(self, optic_fixture_name, field, request):
        """
        Tests the initialization of HuygensPSF instance, checking attributes
        and that the PSF is computed.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_huygens_psf_backend_check" time="0.001" /><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_get_image_extent[cooke_triplet_optic]" time="0.013"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D780B90&gt;
optic_fixture_name = 'cooke_triplet_optic'
request = &lt;FixtureRequest for &lt;Function test_get_image_extent[cooke_triplet_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_get_image_extent(self, optic_fixture_name, request):
        """
        Tests the _get_image_extent method's effects (cx, cy, pixel_pitch) and return
        values.
        """
        optic = request.getfixturevalue(optic_fixture_name)
        # Initialize instance (this calls _get_image_extent via _get_image_coordinates
        # via _compute_psf)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_get_image_extent[double_gauss_optic]" time="0.030"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D780E10&gt;
optic_fixture_name = 'double_gauss_optic'
request = &lt;FixtureRequest for &lt;Function test_get_image_extent[double_gauss_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_get_image_extent(self, optic_fixture_name, request):
        """
        Tests the _get_image_extent method's effects (cx, cy, pixel_pitch) and return
        values.
        """
        optic = request.getfixturevalue(optic_fixture_name)
        # Initialize instance (this calls _get_image_extent via _get_image_coordinates
        # via _compute_psf)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_get_image_extent[reverse_telephoto_optic]" time="0.014"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D781090&gt;
optic_fixture_name = 'reverse_telephoto_optic'
request = &lt;FixtureRequest for &lt;Function test_get_image_extent[reverse_telephoto_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_get_image_extent(self, optic_fixture_name, request):
        """
        Tests the _get_image_extent method's effects (cx, cy, pixel_pitch) and return
        values.
        """
        optic = request.getfixturevalue(optic_fixture_name)
        # Initialize instance (this calls _get_image_extent via _get_image_coordinates
        # via _compute_psf)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_get_image_coordinates[cooke_triplet_optic]" time="0.006"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D781E50&gt;
optic_fixture_name = 'cooke_triplet_optic'
request = &lt;FixtureRequest for &lt;Function test_get_image_coordinates[cooke_triplet_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_get_image_coordinates(self, optic_fixture_name, request):
        """
        Tests the _get_image_coordinates method for correct shape and type of output.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_get_image_coordinates[double_gauss_optic]" time="0.023"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D7820D0&gt;
optic_fixture_name = 'double_gauss_optic'
request = &lt;FixtureRequest for &lt;Function test_get_image_coordinates[double_gauss_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_get_image_coordinates(self, optic_fixture_name, request):
        """
        Tests the _get_image_coordinates method for correct shape and type of output.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_get_image_coordinates[reverse_telephoto_optic]" time="0.018"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D782350&gt;
optic_fixture_name = 'reverse_telephoto_optic'
request = &lt;FixtureRequest for &lt;Function test_get_image_coordinates[reverse_telephoto_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_get_image_coordinates(self, optic_fixture_name, request):
        """
        Tests the _get_image_coordinates method for correct shape and type of output.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_compute_psf_properties_and_normalization[cooke_triplet_optic]" time="0.009"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D783110&gt;
optic_fixture_name = 'cooke_triplet_optic'
request = &lt;FixtureRequest for &lt;Function test_compute_psf_properties_and_normalization[cooke_triplet_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_compute_psf_properties_and_normalization(
        self, optic_fixture_name, request
    ):
        """
        Tests properties of the computed PSF: non-negativity and normalization
        (peak value). Uses higher resolution for a more stable peak for
        normalization check.
        """
        optic = request.getfixturevalue(optic_fixture_name)
        field_on_axis = (0, 0)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field_on_axis,  # Test normalization with on-axis field
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_HIGH,  # More rays for better PSF
            image_size=self.IMAGE_SIZE_HIGH,  # Larger image for better peak capture
        )

tests\test_huygens_psf.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_compute_psf_properties_and_normalization[double_gauss_optic]" time="0.033"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D783390&gt;
optic_fixture_name = 'double_gauss_optic'
request = &lt;FixtureRequest for &lt;Function test_compute_psf_properties_and_normalization[double_gauss_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_compute_psf_properties_and_normalization(
        self, optic_fixture_name, request
    ):
        """
        Tests properties of the computed PSF: non-negativity and normalization
        (peak value). Uses higher resolution for a more stable peak for
        normalization check.
        """
        optic = request.getfixturevalue(optic_fixture_name)
        field_on_axis = (0, 0)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field_on_axis,  # Test normalization with on-axis field
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_HIGH,  # More rays for better PSF
            image_size=self.IMAGE_SIZE_HIGH,  # Larger image for better peak capture
        )

tests\test_huygens_psf.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_compute_psf_properties_and_normalization[reverse_telephoto_optic]" time="0.029"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D783610&gt;
optic_fixture_name = 'reverse_telephoto_optic'
request = &lt;FixtureRequest for &lt;Function test_compute_psf_properties_and_normalization[reverse_telephoto_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_compute_psf_properties_and_normalization(
        self, optic_fixture_name, request
    ):
        """
        Tests properties of the computed PSF: non-negativity and normalization
        (peak value). Uses higher resolution for a more stable peak for
        normalization check.
        """
        optic = request.getfixturevalue(optic_fixture_name)
        field_on_axis = (0, 0)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field_on_axis,  # Test normalization with on-axis field
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_HIGH,  # More rays for better PSF
            image_size=self.IMAGE_SIZE_HIGH,  # Larger image for better peak capture
        )

tests\test_huygens_psf.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_strehl_ratio_general[field0-0.05-cooke_triplet_optic]" time="0.020"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D78CC10&gt;
optic_fixture_name = 'cooke_triplet_optic', field = (0, 0)
expected_strehl_min = 0.05
request = &lt;FixtureRequest for &lt;Function test_strehl_ratio_general[field0-0.05-cooke_triplet_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize(
        "field, expected_strehl_min",
        [
            ((0, 0), 0.05),
            ((0.7, 0.0), 0.005),
        ],
    )
    def test_strehl_ratio_general(
        self, optic_fixture_name, field, expected_strehl_min, request
    ):
        """
        Tests the Strehl ratio calculation for various optics and fields.
        Uses higher resolution for more accurate Strehl.
        """
        # For this general test, we use a placeholder minimum.
        # The `test_strehl_ratio_specific_values` is for more precise checks.
        optic = request.getfixturevalue(optic_fixture_name)
        print(
            f"Testing Strehl for {optic.__class__.__name__} at field {field}. "
            f"Expected min: {expected_strehl_min}"
        )
    
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_HIGH,
            image_size=self.IMAGE_SIZE_HIGH,
        )

tests\test_huygens_psf.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_strehl_ratio_general[field0-0.05-double_gauss_optic]" time="0.017"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D78CE90&gt;
optic_fixture_name = 'double_gauss_optic', field = (0, 0)
expected_strehl_min = 0.05
request = &lt;FixtureRequest for &lt;Function test_strehl_ratio_general[field0-0.05-double_gauss_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize(
        "field, expected_strehl_min",
        [
            ((0, 0), 0.05),
            ((0.7, 0.0), 0.005),
        ],
    )
    def test_strehl_ratio_general(
        self, optic_fixture_name, field, expected_strehl_min, request
    ):
        """
        Tests the Strehl ratio calculation for various optics and fields.
        Uses higher resolution for more accurate Strehl.
        """
        # For this general test, we use a placeholder minimum.
        # The `test_strehl_ratio_specific_values` is for more precise checks.
        optic = request.getfixturevalue(optic_fixture_name)
        print(
            f"Testing Strehl for {optic.__class__.__name__} at field {field}. "
            f"Expected min: {expected_strehl_min}"
        )
    
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_HIGH,
            image_size=self.IMAGE_SIZE_HIGH,
        )

tests\test_huygens_psf.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_strehl_ratio_general[field0-0.05-reverse_telephoto_optic]" time="0.054"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D78D110&gt;
optic_fixture_name = 'reverse_telephoto_optic', field = (0, 0)
expected_strehl_min = 0.05
request = &lt;FixtureRequest for &lt;Function test_strehl_ratio_general[field0-0.05-reverse_telephoto_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize(
        "field, expected_strehl_min",
        [
            ((0, 0), 0.05),
            ((0.7, 0.0), 0.005),
        ],
    )
    def test_strehl_ratio_general(
        self, optic_fixture_name, field, expected_strehl_min, request
    ):
        """
        Tests the Strehl ratio calculation for various optics and fields.
        Uses higher resolution for more accurate Strehl.
        """
        # For this general test, we use a placeholder minimum.
        # The `test_strehl_ratio_specific_values` is for more precise checks.
        optic = request.getfixturevalue(optic_fixture_name)
        print(
            f"Testing Strehl for {optic.__class__.__name__} at field {field}. "
            f"Expected min: {expected_strehl_min}"
        )
    
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_HIGH,
            image_size=self.IMAGE_SIZE_HIGH,
        )

tests\test_huygens_psf.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_strehl_ratio_general[field1-0.005-cooke_triplet_optic]" time="0.014"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D78D390&gt;
optic_fixture_name = 'cooke_triplet_optic', field = (0.7, 0.0)
expected_strehl_min = 0.005
request = &lt;FixtureRequest for &lt;Function test_strehl_ratio_general[field1-0.005-cooke_triplet_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize(
        "field, expected_strehl_min",
        [
            ((0, 0), 0.05),
            ((0.7, 0.0), 0.005),
        ],
    )
    def test_strehl_ratio_general(
        self, optic_fixture_name, field, expected_strehl_min, request
    ):
        """
        Tests the Strehl ratio calculation for various optics and fields.
        Uses higher resolution for more accurate Strehl.
        """
        # For this general test, we use a placeholder minimum.
        # The `test_strehl_ratio_specific_values` is for more precise checks.
        optic = request.getfixturevalue(optic_fixture_name)
        print(
            f"Testing Strehl for {optic.__class__.__name__} at field {field}. "
            f"Expected min: {expected_strehl_min}"
        )
    
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_HIGH,
            image_size=self.IMAGE_SIZE_HIGH,
        )

tests\test_huygens_psf.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_strehl_ratio_general[field1-0.005-double_gauss_optic]" time="0.035"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D78D650&gt;
optic_fixture_name = 'double_gauss_optic', field = (0.7, 0.0)
expected_strehl_min = 0.005
request = &lt;FixtureRequest for &lt;Function test_strehl_ratio_general[field1-0.005-double_gauss_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize(
        "field, expected_strehl_min",
        [
            ((0, 0), 0.05),
            ((0.7, 0.0), 0.005),
        ],
    )
    def test_strehl_ratio_general(
        self, optic_fixture_name, field, expected_strehl_min, request
    ):
        """
        Tests the Strehl ratio calculation for various optics and fields.
        Uses higher resolution for more accurate Strehl.
        """
        # For this general test, we use a placeholder minimum.
        # The `test_strehl_ratio_specific_values` is for more precise checks.
        optic = request.getfixturevalue(optic_fixture_name)
        print(
            f"Testing Strehl for {optic.__class__.__name__} at field {field}. "
            f"Expected min: {expected_strehl_min}"
        )
    
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_HIGH,
            image_size=self.IMAGE_SIZE_HIGH,
        )

tests\test_huygens_psf.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_strehl_ratio_general[field1-0.005-reverse_telephoto_optic]" time="0.014"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D78D910&gt;
optic_fixture_name = 'reverse_telephoto_optic', field = (0.7, 0.0)
expected_strehl_min = 0.005
request = &lt;FixtureRequest for &lt;Function test_strehl_ratio_general[field1-0.005-reverse_telephoto_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize(
        "field, expected_strehl_min",
        [
            ((0, 0), 0.05),
            ((0.7, 0.0), 0.005),
        ],
    )
    def test_strehl_ratio_general(
        self, optic_fixture_name, field, expected_strehl_min, request
    ):
        """
        Tests the Strehl ratio calculation for various optics and fields.
        Uses higher resolution for more accurate Strehl.
        """
        # For this general test, we use a placeholder minimum.
        # The `test_strehl_ratio_specific_values` is for more precise checks.
        optic = request.getfixturevalue(optic_fixture_name)
        print(
            f"Testing Strehl for {optic.__class__.__name__} at field {field}. "
            f"Expected min: {expected_strehl_min}"
        )
    
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=field,
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_HIGH,
            image_size=self.IMAGE_SIZE_HIGH,
        )

tests\test_huygens_psf.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_strehl_ratio_specific_values" time="0.007"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D781290&gt;
cooke_triplet_optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147953F8850&gt;
double_gauss_optic = &lt;optiland.samples.objectives.DoubleGauss object at 0x0000014794A35BD0&gt;
reverse_telephoto_optic = &lt;optiland.samples.objectives.ReverseTelephoto object at 0x000001479F1CC850&gt;

    def test_strehl_ratio_specific_values(
        self, cooke_triplet_optic, double_gauss_optic, reverse_telephoto_optic
    ):
        EXPECTED_STREHL_VALUES = {
            "CookeTriplet": {
                (0, 0): 0.3023159962682067,
                (
                    0.7,
                    0.0,
                ): 0.019029390469840174,
            },
            "DoubleGauss": {
                (
                    0,
                    0,
                ): 0.07405715702199461,
                (
                    0.7,
                    0.0,
                ): 0.0063032279399868095,
            },
            "ReverseTelephoto": {
                (
                    0,
                    0,
                ): 0.9785343625747402,
                (
                    0.7,
                    0.0,
                ): 0.881275354472487,
            },
        }
        # Tolerance for Strehl comparison
        strehl_tolerance = 0.001
    
        optics_map = {
            "CookeTriplet": cooke_triplet_optic,
            "DoubleGauss": double_gauss_optic,
            "ReverseTelephoto": reverse_telephoto_optic,
        }
    
        for optic_name, field_strehl_map in EXPECTED_STREHL_VALUES.items():
            optic_under_test = optics_map[optic_name]
            for field, expected_sr in field_strehl_map.items():
                print(
                    f"Testing specific Strehl for {optic_name} at {field}. "
                    f"Expected: ~{expected_sr}"
                )
&gt;               psf_instance = HuygensPSF(
                    optic=optic_under_test,
                    field=field,
                    wavelength=self.WAVELENGTH_GREEN,
                    num_rays=self.NUM_RAYS_HIGH,  # Use high resolution
                    image_size=self.IMAGE_SIZE_HIGH,
                )

tests\test_huygens_psf.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_get_psf_units[cooke_triplet_optic]" time="0.015"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D78E350&gt;
optic_fixture_name = 'cooke_triplet_optic'
request = &lt;FixtureRequest for &lt;Function test_get_psf_units[cooke_triplet_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_get_psf_units(self, optic_fixture_name, request):
        """
        Tests the _get_psf_units method for correct calculation of physical extent.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_get_psf_units[double_gauss_optic]" time="0.038"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D78E490&gt;
optic_fixture_name = 'double_gauss_optic'
request = &lt;FixtureRequest for &lt;Function test_get_psf_units[double_gauss_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_get_psf_units(self, optic_fixture_name, request):
        """
        Tests the _get_psf_units method for correct calculation of physical extent.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_get_psf_units[reverse_telephoto_optic]" time="0.015"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D78E5D0&gt;
optic_fixture_name = 'reverse_telephoto_optic'
request = &lt;FixtureRequest for &lt;Function test_get_psf_units[reverse_telephoto_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_get_psf_units(self, optic_fixture_name, request):
        """
        Tests the _get_psf_units method for correct calculation of physical extent.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_runs_without_error[True-2d-cooke_triplet_optic]" time="0.015"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D78F190&gt;
optic_fixture_name = 'cooke_triplet_optic', projection = '2d', log_scale = True
request = &lt;FixtureRequest for &lt;Function test_view_runs_without_error[True-2d-cooke_triplet_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("projection", ["2d", "3d"])
    @pytest.mark.parametrize("log_scale", [True, False])
    def test_view_runs_without_error(
        self, optic_fixture_name, projection, log_scale, request
    ):
        """
        Tests that the `view` method (inherited from BasePSF) runs without raising
        errors and calls `plt.show()`.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,  # Low res for speed
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_runs_without_error[True-2d-double_gauss_optic]" time="0.039"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D790AD0&gt;
optic_fixture_name = 'double_gauss_optic', projection = '2d', log_scale = True
request = &lt;FixtureRequest for &lt;Function test_view_runs_without_error[True-2d-double_gauss_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("projection", ["2d", "3d"])
    @pytest.mark.parametrize("log_scale", [True, False])
    def test_view_runs_without_error(
        self, optic_fixture_name, projection, log_scale, request
    ):
        """
        Tests that the `view` method (inherited from BasePSF) runs without raising
        errors and calls `plt.show()`.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,  # Low res for speed
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_runs_without_error[True-2d-reverse_telephoto_optic]" time="0.040"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D790D10&gt;
optic_fixture_name = 'reverse_telephoto_optic', projection = '2d'
log_scale = True
request = &lt;FixtureRequest for &lt;Function test_view_runs_without_error[True-2d-reverse_telephoto_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("projection", ["2d", "3d"])
    @pytest.mark.parametrize("log_scale", [True, False])
    def test_view_runs_without_error(
        self, optic_fixture_name, projection, log_scale, request
    ):
        """
        Tests that the `view` method (inherited from BasePSF) runs without raising
        errors and calls `plt.show()`.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,  # Low res for speed
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_runs_without_error[True-3d-cooke_triplet_optic]" time="0.008"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D790F90&gt;
optic_fixture_name = 'cooke_triplet_optic', projection = '3d', log_scale = True
request = &lt;FixtureRequest for &lt;Function test_view_runs_without_error[True-3d-cooke_triplet_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("projection", ["2d", "3d"])
    @pytest.mark.parametrize("log_scale", [True, False])
    def test_view_runs_without_error(
        self, optic_fixture_name, projection, log_scale, request
    ):
        """
        Tests that the `view` method (inherited from BasePSF) runs without raising
        errors and calls `plt.show()`.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,  # Low res for speed
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_runs_without_error[True-3d-double_gauss_optic]" time="0.015"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D791210&gt;
optic_fixture_name = 'double_gauss_optic', projection = '3d', log_scale = True
request = &lt;FixtureRequest for &lt;Function test_view_runs_without_error[True-3d-double_gauss_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("projection", ["2d", "3d"])
    @pytest.mark.parametrize("log_scale", [True, False])
    def test_view_runs_without_error(
        self, optic_fixture_name, projection, log_scale, request
    ):
        """
        Tests that the `view` method (inherited from BasePSF) runs without raising
        errors and calls `plt.show()`.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,  # Low res for speed
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_runs_without_error[True-3d-reverse_telephoto_optic]" time="0.019"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D791490&gt;
optic_fixture_name = 'reverse_telephoto_optic', projection = '3d'
log_scale = True
request = &lt;FixtureRequest for &lt;Function test_view_runs_without_error[True-3d-reverse_telephoto_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("projection", ["2d", "3d"])
    @pytest.mark.parametrize("log_scale", [True, False])
    def test_view_runs_without_error(
        self, optic_fixture_name, projection, log_scale, request
    ):
        """
        Tests that the `view` method (inherited from BasePSF) runs without raising
        errors and calls `plt.show()`.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,  # Low res for speed
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_runs_without_error[False-2d-cooke_triplet_optic]" time="0.008"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D791710&gt;
optic_fixture_name = 'cooke_triplet_optic', projection = '2d'
log_scale = False
request = &lt;FixtureRequest for &lt;Function test_view_runs_without_error[False-2d-cooke_triplet_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("projection", ["2d", "3d"])
    @pytest.mark.parametrize("log_scale", [True, False])
    def test_view_runs_without_error(
        self, optic_fixture_name, projection, log_scale, request
    ):
        """
        Tests that the `view` method (inherited from BasePSF) runs without raising
        errors and calls `plt.show()`.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,  # Low res for speed
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_runs_without_error[False-2d-double_gauss_optic]" time="0.032"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D7919D0&gt;
optic_fixture_name = 'double_gauss_optic', projection = '2d', log_scale = False
request = &lt;FixtureRequest for &lt;Function test_view_runs_without_error[False-2d-double_gauss_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("projection", ["2d", "3d"])
    @pytest.mark.parametrize("log_scale", [True, False])
    def test_view_runs_without_error(
        self, optic_fixture_name, projection, log_scale, request
    ):
        """
        Tests that the `view` method (inherited from BasePSF) runs without raising
        errors and calls `plt.show()`.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,  # Low res for speed
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_runs_without_error[False-2d-reverse_telephoto_optic]" time="0.027"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D791CD0&gt;
optic_fixture_name = 'reverse_telephoto_optic', projection = '2d'
log_scale = False
request = &lt;FixtureRequest for &lt;Function test_view_runs_without_error[False-2d-reverse_telephoto_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("projection", ["2d", "3d"])
    @pytest.mark.parametrize("log_scale", [True, False])
    def test_view_runs_without_error(
        self, optic_fixture_name, projection, log_scale, request
    ):
        """
        Tests that the `view` method (inherited from BasePSF) runs without raising
        errors and calls `plt.show()`.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,  # Low res for speed
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_runs_without_error[False-3d-cooke_triplet_optic]" time="0.015"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D791F90&gt;
optic_fixture_name = 'cooke_triplet_optic', projection = '3d'
log_scale = False
request = &lt;FixtureRequest for &lt;Function test_view_runs_without_error[False-3d-cooke_triplet_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("projection", ["2d", "3d"])
    @pytest.mark.parametrize("log_scale", [True, False])
    def test_view_runs_without_error(
        self, optic_fixture_name, projection, log_scale, request
    ):
        """
        Tests that the `view` method (inherited from BasePSF) runs without raising
        errors and calls `plt.show()`.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,  # Low res for speed
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_runs_without_error[False-3d-double_gauss_optic]" time="0.030"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D792290&gt;
optic_fixture_name = 'double_gauss_optic', projection = '3d', log_scale = False
request = &lt;FixtureRequest for &lt;Function test_view_runs_without_error[False-3d-double_gauss_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("projection", ["2d", "3d"])
    @pytest.mark.parametrize("log_scale", [True, False])
    def test_view_runs_without_error(
        self, optic_fixture_name, projection, log_scale, request
    ):
        """
        Tests that the `view` method (inherited from BasePSF) runs without raising
        errors and calls `plt.show()`.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,  # Low res for speed
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_runs_without_error[False-3d-reverse_telephoto_optic]" time="0.022"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D792590&gt;
optic_fixture_name = 'reverse_telephoto_optic', projection = '3d'
log_scale = False
request = &lt;FixtureRequest for &lt;Function test_view_runs_without_error[False-3d-reverse_telephoto_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    @pytest.mark.parametrize("projection", ["2d", "3d"])
    @pytest.mark.parametrize("log_scale", [True, False])
    def test_view_runs_without_error(
        self, optic_fixture_name, projection, log_scale, request
    ):
        """
        Tests that the `view` method (inherited from BasePSF) runs without raising
        errors and calls `plt.show()`.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,  # Low res for speed
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_invalid_projection" time="0.017"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D792C10&gt;
cooke_triplet_optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147953F8850&gt;

    def test_view_invalid_projection(self, cooke_triplet_optic):
        """
        Tests that `view` raises ValueError for an invalid projection type.
        """
&gt;       psf_instance = HuygensPSF(
            optic=cooke_triplet_optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:385: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_annotate_sampling[2d]" time="0.012"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D793950&gt;
mock_text = &lt;MagicMock name='text' id='1406884970768'&gt;, projection = '2d'
cooke_triplet_optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147953F8850&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    @patch("matplotlib.figure.Figure.text")
    def test_view_annotate_sampling(self, mock_text, projection, cooke_triplet_optic):
&gt;       psf_instance = HuygensPSF(
            optic=cooke_triplet_optic,
            field=(0, 1),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:404: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_annotate_sampling[3d]" time="0.015"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D793BD0&gt;
mock_text = &lt;MagicMock name='text' id='1406949119952'&gt;, projection = '3d'
cooke_triplet_optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147953F8850&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    @patch("matplotlib.figure.Figure.text")
    def test_view_annotate_sampling(self, mock_text, projection, cooke_triplet_optic):
&gt;       psf_instance = HuygensPSF(
            optic=cooke_triplet_optic,
            field=(0, 1),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:404: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_oversampling[2d]" time="0.012"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D7A0850&gt;
projection = '2d'
cooke_triplet_optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147953F8850&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    def test_view_oversampling(self, projection, cooke_triplet_optic):
&gt;       psf_instance = HuygensPSF(
            optic=cooke_triplet_optic,
            field=(0, 1),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:425: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_oversampling[3d]" time="0.008"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D7A0AD0&gt;
projection = '3d'
cooke_triplet_optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147953F8850&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    def test_view_oversampling(self, projection, cooke_triplet_optic):
&gt;       psf_instance = HuygensPSF(
            optic=cooke_triplet_optic,
            field=(0, 1),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:425: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_get_normalization_value_positive[cooke_triplet_optic]" time="0.013"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D7A1810&gt;
optic_fixture_name = 'cooke_triplet_optic'
request = &lt;FixtureRequest for &lt;Function test_get_normalization_value_positive[cooke_triplet_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_get_normalization_value_positive(self, optic_fixture_name, request):
        """
        Tests that _get_normalization returns a positive value.
        The exact value is complex to predict, but it must be positive.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),  # Normalization is based on on-axis ideal case
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_get_normalization_value_positive[double_gauss_optic]" time="0.027"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D7A1A90&gt;
optic_fixture_name = 'double_gauss_optic'
request = &lt;FixtureRequest for &lt;Function test_get_normalization_value_positive[double_gauss_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_get_normalization_value_positive(self, optic_fixture_name, request):
        """
        Tests that _get_normalization returns a positive value.
        The exact value is complex to predict, but it must be positive.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),  # Normalization is based on on-axis ideal case
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_get_normalization_value_positive[reverse_telephoto_optic]" time="0.019"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D7A1D10&gt;
optic_fixture_name = 'reverse_telephoto_optic'
request = &lt;FixtureRequest for &lt;Function test_get_normalization_value_positive[reverse_telephoto_optic]&gt;&gt;

    @pytest.mark.parametrize("optic_fixture_name", OPTIC_FIXTURES)
    def test_get_normalization_value_positive(self, optic_fixture_name, request):
        """
        Tests that _get_normalization returns a positive value.
        The exact value is complex to predict, but it must be positive.
        """
        optic = request.getfixturevalue(optic_fixture_name)
&gt;       psf_instance = HuygensPSF(
            optic=optic,
            field=(0, 0),  # Normalization is based on on-axis ideal case
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_view_psf_not_computed_error_case_not_directly_triggerable" time="0.014"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D7A22D0&gt;
cooke_triplet_optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147953F8850&gt;

    def test_view_psf_not_computed_error_case_not_directly_triggerable(
        self, cooke_triplet_optic
    ):
        """
        This RuntimeError from BasePSF is not directly triggerable in HuygensPSF
        as `psf` is computed in `__init__`. This documents the expected BasePSF
        behavior.
        """
&gt;       psf_instance = HuygensPSF(
            optic=cooke_triplet_optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:471: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_strehl_ratio_psf_not_computed_error_case_not_directly_triggerable" time="0.007"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D7A2990&gt;
cooke_triplet_optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147953F8850&gt;

    def test_strehl_ratio_psf_not_computed_error_case_not_directly_triggerable(
        self, cooke_triplet_optic
    ):
        """
        This RuntimeError from BasePSF is not directly triggerable in HuygensPSF.
        Documents the expected BasePSF behavior.
        """
&gt;       psf_instance = HuygensPSF(
            optic=cooke_triplet_optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=self.IMAGE_SIZE_LOW,
        )

tests\test_huygens_psf.py:493: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_huygens_psf.TestHuygensPSF" name="test_pixel_pitch_override" time="0.014"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_huygens_psf.TestHuygensPSF object at 0x000001478D7A3090&gt;
cooke_triplet_optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147953F8850&gt;

    def test_pixel_pitch_override(self, cooke_triplet_optic):
        """
        Tests that providing a pixel_pitch in the constructor overrides the
        automatic calculation.
        """
        custom_pixel_pitch = 0.005  # 5 um in mm
        image_size = self.IMAGE_SIZE_LOW
    
&gt;       psf_instance = HuygensPSF(
            optic=cooke_triplet_optic,
            field=(0, 0),
            wavelength=self.WAVELENGTH_GREEN,
            num_rays=self.NUM_RAYS_LOW,
            image_size=image_size,
            pixel_pitch=custom_pixel_pitch,
        )

tests\test_huygens_psf.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\psf\huygens_fresnel.py:77: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_image_surface" name="test_initialization[backend=numpy]" time="0.001" /><testcase classname="tests.test_image_surface" name="test_initialization[backend=torch]" time="0.001" /><testcase classname="tests.test_image_surface" name="test_trace_paraxial[backend=numpy]" time="0.001" /><testcase classname="tests.test_image_surface" name="test_trace_paraxial[backend=torch]" time="0.002" /><testcase classname="tests.test_image_surface" name="test_interact[backend=numpy]" time="0.001" /><testcase classname="tests.test_image_surface" name="test_interact[backend=torch]" time="0.001" /><testcase classname="tests.test_jones.TestJonesFresnel" name="test_normal_incidence[backend=numpy]" time="0.001" /><testcase classname="tests.test_jones.TestJonesFresnel" name="test_normal_incidence[backend=torch]" time="0.004" /><testcase classname="tests.test_jones.TestJonesFresnel" name="test_non_normal_incidence[backend=numpy]" time="0.001" /><testcase classname="tests.test_jones.TestJonesFresnel" name="test_non_normal_incidence[backend=torch]" time="0.004" /><testcase classname="tests.test_jones" name="test_jones_polarizer_H[backend=numpy]" time="0.003" /><testcase classname="tests.test_jones" name="test_jones_polarizer_H[backend=torch]" time="0.001" /><testcase classname="tests.test_jones" name="test_jones_polarizer_V[backend=numpy]" time="0.001" /><testcase classname="tests.test_jones" name="test_jones_polarizer_V[backend=torch]" time="0.001" /><testcase classname="tests.test_jones" name="test_jones_polarizer_L45[backend=numpy]" time="0.001" /><testcase classname="tests.test_jones" name="test_jones_polarizer_L45[backend=torch]" time="0.001" /><testcase classname="tests.test_jones" name="test_jones_polarizer_L135[backend=numpy]" time="0.001" /><testcase classname="tests.test_jones" name="test_jones_polarizer_L135[backend=torch]" time="0.002" /><testcase classname="tests.test_jones" name="test_jones_polarizer_rcp[backend=numpy]" time="0.001" /><testcase classname="tests.test_jones" name="test_jones_polarizer_rcp[backend=torch]" time="0.004" /><testcase classname="tests.test_jones" name="test_jones_polarizer_lcp[backend=numpy]" time="0.001" /><testcase classname="tests.test_jones" name="test_jones_polarizer_lcp[backend=torch]" time="0.002" /><testcase classname="tests.test_jones" name="test_jones_linear_diattenuator[backend=numpy]" time="0.001" /><testcase classname="tests.test_jones" name="test_jones_linear_diattenuator[backend=torch]" time="0.008" /><testcase classname="tests.test_jones" name="test_jones_linear_retarder[backend=numpy]" time="0.003" /><testcase classname="tests.test_jones" name="test_jones_linear_retarder[backend=torch]" time="0.012" /><testcase classname="tests.test_jones" name="test_jones_quarter_wave_retarder[backend=numpy]" time="0.003" /><testcase classname="tests.test_jones" name="test_jones_quarter_wave_retarder[backend=torch]" time="0.005" /><testcase classname="tests.test_jones" name="test_jones_half_wave_retarder[backend=numpy]" time="0.002" /><testcase classname="tests.test_jones" name="test_jones_half_wave_retarder[backend=torch]" time="0.007" /><testcase classname="tests.test_material_thermal.TestMaterialFileThermal" name="test_nair_calculation[backend=numpy]" time="0.023" /><testcase classname="tests.test_material_thermal.TestMaterialFileThermal" name="test_nair_calculation[backend=torch]" time="0.020" /><testcase classname="tests.test_material_thermal.TestMaterialFileThermal" name="test_no_correction_if_temp_is_none[backend=numpy]" time="0.029" /><testcase classname="tests.test_material_thermal.TestMaterialFileThermal" name="test_no_correction_if_temp_is_none[backend=torch]" time="0.032" /><testcase classname="tests.test_material_thermal.TestMaterialFileThermal" name="test_no_correction_if_no_thermal_data[backend=numpy]" time="0.027" /><testcase classname="tests.test_material_thermal.TestMaterialFileThermal" name="test_no_correction_if_no_thermal_data[backend=torch]" time="0.031" /><testcase classname="tests.test_material_thermal.TestMaterialFileThermal" name="test_correction_with_temp_and_default_pressure[backend=numpy]" time="0.041" /><testcase classname="tests.test_material_thermal.TestMaterialFileThermal" name="test_correction_with_temp_and_default_pressure[backend=torch]" time="0.057" /><testcase classname="tests.test_material_thermal.TestMaterialFileThermal" name="test_correction_at_reference_temp[backend=numpy]" time="0.060" /><testcase classname="tests.test_material_thermal.TestMaterialFileThermal" name="test_correction_at_reference_temp[backend=torch]" time="0.029" /><testcase classname="tests.test_material_thermal.TestMaterialFileThermal" name="test_full_correction_with_array_input[backend=numpy]" time="0.029" /><testcase classname="tests.test_material_thermal.TestMaterialFileThermal" name="test_full_correction_with_array_input[backend=torch]" time="0.031" /><testcase classname="tests.test_material_thermal.TestMaterialFileThermal" name="test_full_correction_calculation[backend=numpy]" time="0.031" /><testcase classname="tests.test_material_thermal.TestMaterialFileThermal" name="test_full_correction_calculation[backend=torch]" time="0.015" /><testcase classname="tests.test_materials.TestBaseMaterial" name="test_caching[backend=numpy]" time="0.001" /><testcase classname="tests.test_materials.TestBaseMaterial" name="test_caching[backend=torch]" time="0.002" /><testcase classname="tests.test_materials.TestIdealMaterial" name="test_ideal_material_n[backend=numpy]" time="0.001" /><testcase classname="tests.test_materials.TestIdealMaterial" name="test_ideal_material_n[backend=torch]" time="0.002" /><testcase classname="tests.test_materials.TestIdealMaterial" name="test_ideal_material_k[backend=numpy]" time="0.001" /><testcase classname="tests.test_materials.TestIdealMaterial" name="test_ideal_material_k[backend=torch]" time="0.002" /><testcase classname="tests.test_materials.TestIdealMaterial" name="test_ideal_to_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_materials.TestIdealMaterial" name="test_ideal_to_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_materials.TestIdealMaterial" name="test_ideal_from_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_materials.TestIdealMaterial" name="test_ideal_from_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_1[backend=numpy]" time="0.005" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_1[backend=torch]" time="0.005" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_2[backend=numpy]" time="0.014" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_2[backend=torch]" time="0.021" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_3[backend=numpy]" time="0.016" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_3[backend=torch]" time="0.024" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_4[backend=numpy]" time="0.011" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_4[backend=torch]" time="0.016" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_5[backend=numpy]" time="0.024" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_5[backend=torch]" time="0.030" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_6[backend=numpy]" time="0.018" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_6[backend=torch]" time="0.021" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_7[backend=numpy]" time="0.012" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_7[backend=torch]" time="0.007" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_8[backend=numpy]" time="0.006" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_8[backend=torch]" time="0.010" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_9[backend=numpy]" time="0.008" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_formula_9[backend=torch]" time="0.012" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_tabulated_n[backend=numpy]" time="0.009" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_tabulated_n[backend=torch]" time="0.015" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_tabulated_nk[backend=numpy]" time="0.080" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_tabulated_nk[backend=torch]" time="0.073" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_set_formula_type_twice[backend=numpy]" time="0.004" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_set_formula_type_twice[backend=torch]" time="0.004" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_to_dict[backend=numpy]" time="0.004" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_to_dict[backend=torch]" time="0.005" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_from_dict[backend=numpy]" time="0.005" /><testcase classname="tests.test_materials.TestMaterialFile" name="test_from_dict[backend=torch]" time="0.005" /><testcase classname="tests.test_materials.TestMaterial" name="test_standard_material[backend=numpy]" time="0.032" /><testcase classname="tests.test_materials.TestMaterial" name="test_standard_material[backend=torch]" time="0.032" /><testcase classname="tests.test_materials.TestMaterial" name="test_nonexistent_material[backend=numpy]" time="0.047" /><testcase classname="tests.test_materials.TestMaterial" name="test_nonexistent_material[backend=torch]" time="0.060" /><testcase classname="tests.test_materials.TestMaterial" name="test_non_robust_failure[backend=numpy]" time="0.046" /><testcase classname="tests.test_materials.TestMaterial" name="test_non_robust_failure[backend=torch]" time="0.031" /><testcase classname="tests.test_materials.TestMaterial" name="test_min_wavelength_filtering[backend=numpy]" time="0.033" /><testcase classname="tests.test_materials.TestMaterial" name="test_min_wavelength_filtering[backend=torch]" time="0.047" /><testcase classname="tests.test_materials.TestMaterial" name="test_max_wavelength_filtering[backend=numpy]" time="0.035" /><testcase classname="tests.test_materials.TestMaterial" name="test_max_wavelength_filtering[backend=torch]" time="0.036" /><testcase classname="tests.test_materials.TestMaterial" name="test_raise_material_error_method[backend=numpy]" time="0.060" /><testcase classname="tests.test_materials.TestMaterial" name="test_raise_material_error_method[backend=torch]" time="0.047" /><testcase classname="tests.test_materials.TestMaterial" name="test_to_dict[backend=numpy]" time="0.020" /><testcase classname="tests.test_materials.TestMaterial" name="test_to_dict[backend=torch]" time="0.028" /><testcase classname="tests.test_materials.TestMaterial" name="test_from_dict[backend=numpy]" time="0.019" /><testcase classname="tests.test_materials.TestMaterial" name="test_from_dict[backend=torch]" time="0.026" /><testcase classname="tests.test_materials.TestMaterial" name="test_raise_warning[backend=numpy]" time="0.026" /><testcase classname="tests.test_materials.TestMaterial" name="test_raise_warning[backend=torch]" time="0.018" /><testcase classname="tests.test_materials" name="test_refractive_index[backend=numpy]" time="0.003" /><testcase classname="tests.test_materials" name="test_refractive_index[backend=torch]" time="0.004" /><testcase classname="tests.test_materials" name="test_extinction_coefficient[backend=numpy]" time="0.002" /><testcase classname="tests.test_materials" name="test_extinction_coefficient[backend=torch]" time="0.002" /><testcase classname="tests.test_materials" name="test_coefficients[backend=numpy]" time="0.002" /><testcase classname="tests.test_materials" name="test_coefficients[backend=torch]" time="0.004" /><testcase classname="tests.test_materials" name="test_abbe_to_dict[backend=numpy]" time="0.003" /><testcase classname="tests.test_materials" name="test_abbe_to_dict[backend=torch]" time="0.003" /><testcase classname="tests.test_materials" name="test_abbe_from_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_materials" name="test_abbe_from_dict[backend=torch]" time="0.006" /><testcase classname="tests.test_materials" name="test_abbe_out_of_bounds_wavelength[backend=numpy]" time="0.002" /><testcase classname="tests.test_materials" name="test_abbe_out_of_bounds_wavelength[backend=torch]" time="0.002" /><testcase classname="tests.test_materials" name="test_glasses_selection[backend=numpy]" time="0.025" /><testcase classname="tests.test_materials" name="test_glasses_selection[backend=torch]" time="0.020" /><testcase classname="tests.test_materials" name="test_get_nd_vd[backend=numpy]" time="0.032" /><testcase classname="tests.test_materials" name="test_get_nd_vd[backend=torch]" time="0.030" /><testcase classname="tests.test_materials" name="test_downsample_glass_map[backend=numpy]" time="0.166" /><testcase classname="tests.test_materials" name="test_downsample_glass_map[backend=torch]" time="0.171" /><testcase classname="tests.test_materials" name="test_find_closest_glass[backend=numpy]" time="0.182" /><testcase classname="tests.test_materials" name="test_find_closest_glass[backend=torch]" time="0.217" /><testcase classname="tests.test_materials" name="test_plot_nk" time="0.085" /><testcase classname="tests.test_ml.TestOpticalSystemModule" name="test_init_runtime_error_wrong_backend" time="0.092" /><testcase classname="tests.test_ml.TestOpticalSystemModule" name="test_init_enables_gradients" time="0.086" /><testcase classname="tests.test_ml.TestOpticalSystemModule" name="test_init_parameter_creation" time="0.084" /><testcase classname="tests.test_ml.TestOpticalSystemModule" name="test_default_loss_function" time="0.090" /><testcase classname="tests.test_ml.TestOpticalSystemModule" name="test_sync_params_to_problem_and_bounds" time="0.075" /><testcase classname="tests.test_ml.TestOpticalSystemModule" name="test_forward_pass_and_optimization" time="2.113" /><testcase classname="tests.test_ml.TestOpticalSystemModule" name="test_custom_objective_function" time="0.063" /><testcase classname="tests.test_mmdft_psf" name="test_initialization[backend=numpy]" time="0.070"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C92D40&gt;

    def test_initialization(make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(image_size=1024)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_initialization[backend=torch]" time="0.158"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C33C40&gt;

    def test_initialization(make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(image_size=1024)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_num_rays[backend=numpy-32-32-1.32622273171]" time="0.125"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C18E00&gt;
num_rays = 32, expected_pupil_sampling = 32
expected_pixel_pitch = 1.32622273171

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling, expected_pixel_pitch",
        [
            (  32,  32, 1.32622273171),
            (  64,  45, 0.94119032573),
            ( 128,  64, 0.67380671047),
            ( 256,  90, 0.47594283517),
            (1024, 181, 0.24064525374),
        ],
    )
    def test_calcs_from_num_rays(make_mmdftpsf,
                                num_rays,
                                expected_pupil_sampling,
                                expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_num_rays[backend=numpy-64-45-0.94119032573]" time="0.117"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D9FC40&gt;
num_rays = 64, expected_pupil_sampling = 45
expected_pixel_pitch = 0.94119032573

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling, expected_pixel_pitch",
        [
            (  32,  32, 1.32622273171),
            (  64,  45, 0.94119032573),
            ( 128,  64, 0.67380671047),
            ( 256,  90, 0.47594283517),
            (1024, 181, 0.24064525374),
        ],
    )
    def test_calcs_from_num_rays(make_mmdftpsf,
                                num_rays,
                                expected_pupil_sampling,
                                expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_num_rays[backend=numpy-128-64-0.67380671047]" time="0.129"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C83C40&gt;
num_rays = 128, expected_pupil_sampling = 64
expected_pixel_pitch = 0.67380671047

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling, expected_pixel_pitch",
        [
            (  32,  32, 1.32622273171),
            (  64,  45, 0.94119032573),
            ( 128,  64, 0.67380671047),
            ( 256,  90, 0.47594283517),
            (1024, 181, 0.24064525374),
        ],
    )
    def test_calcs_from_num_rays(make_mmdftpsf,
                                num_rays,
                                expected_pupil_sampling,
                                expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_num_rays[backend=numpy-256-90-0.47594283517]" time="0.185"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D5B420&gt;
num_rays = 256, expected_pupil_sampling = 90
expected_pixel_pitch = 0.47594283517

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling, expected_pixel_pitch",
        [
            (  32,  32, 1.32622273171),
            (  64,  45, 0.94119032573),
            ( 128,  64, 0.67380671047),
            ( 256,  90, 0.47594283517),
            (1024, 181, 0.24064525374),
        ],
    )
    def test_calcs_from_num_rays(make_mmdftpsf,
                                num_rays,
                                expected_pupil_sampling,
                                expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_num_rays[backend=numpy-1024-181-0.24064525374]" time="0.122"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D0BC40&gt;
num_rays = 1024, expected_pupil_sampling = 181
expected_pixel_pitch = 0.24064525374

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling, expected_pixel_pitch",
        [
            (  32,  32, 1.32622273171),
            (  64,  45, 0.94119032573),
            ( 128,  64, 0.67380671047),
            ( 256,  90, 0.47594283517),
            (1024, 181, 0.24064525374),
        ],
    )
    def test_calcs_from_num_rays(make_mmdftpsf,
                                num_rays,
                                expected_pupil_sampling,
                                expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_num_rays[backend=torch-32-32-1.32622273171]" time="0.174"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D57C40&gt;
num_rays = 32, expected_pupil_sampling = 32
expected_pixel_pitch = 1.32622273171

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling, expected_pixel_pitch",
        [
            (  32,  32, 1.32622273171),
            (  64,  45, 0.94119032573),
            ( 128,  64, 0.67380671047),
            ( 256,  90, 0.47594283517),
            (1024, 181, 0.24064525374),
        ],
    )
    def test_calcs_from_num_rays(make_mmdftpsf,
                                num_rays,
                                expected_pupil_sampling,
                                expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_num_rays[backend=torch-64-45-0.94119032573]" time="0.176"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794CA42C0&gt;
num_rays = 64, expected_pupil_sampling = 45
expected_pixel_pitch = 0.94119032573

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling, expected_pixel_pitch",
        [
            (  32,  32, 1.32622273171),
            (  64,  45, 0.94119032573),
            ( 128,  64, 0.67380671047),
            ( 256,  90, 0.47594283517),
            (1024, 181, 0.24064525374),
        ],
    )
    def test_calcs_from_num_rays(make_mmdftpsf,
                                num_rays,
                                expected_pupil_sampling,
                                expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_num_rays[backend=torch-128-64-0.67380671047]" time="0.173"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x00000147AD8F2FC0&gt;
num_rays = 128, expected_pupil_sampling = 64
expected_pixel_pitch = 0.67380671047

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling, expected_pixel_pitch",
        [
            (  32,  32, 1.32622273171),
            (  64,  45, 0.94119032573),
            ( 128,  64, 0.67380671047),
            ( 256,  90, 0.47594283517),
            (1024, 181, 0.24064525374),
        ],
    )
    def test_calcs_from_num_rays(make_mmdftpsf,
                                num_rays,
                                expected_pupil_sampling,
                                expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_num_rays[backend=torch-256-90-0.47594283517]" time="0.173"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C18AE0&gt;
num_rays = 256, expected_pupil_sampling = 90
expected_pixel_pitch = 0.47594283517

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling, expected_pixel_pitch",
        [
            (  32,  32, 1.32622273171),
            (  64,  45, 0.94119032573),
            ( 128,  64, 0.67380671047),
            ( 256,  90, 0.47594283517),
            (1024, 181, 0.24064525374),
        ],
    )
    def test_calcs_from_num_rays(make_mmdftpsf,
                                num_rays,
                                expected_pupil_sampling,
                                expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_num_rays[backend=torch-1024-181-0.24064525374]" time="0.121"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D57600&gt;
num_rays = 1024, expected_pupil_sampling = 181
expected_pixel_pitch = 0.24064525374

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling, expected_pixel_pitch",
        [
            (  32,  32, 1.32622273171),
            (  64,  45, 0.94119032573),
            ( 128,  64, 0.67380671047),
            ( 256,  90, 0.47594283517),
            (1024, 181, 0.24064525374),
        ],
    )
    def test_calcs_from_num_rays(make_mmdftpsf,
                                num_rays,
                                expected_pupil_sampling,
                                expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_pixel_pitch[backend=numpy-0.25-1390]" time="0.073"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D27A60&gt;
pixel_pitch = 0.25, expected_image_size = 1390

    @pytest.mark.parametrize(
        "pixel_pitch, expected_image_size",
        [
            (0.25, 1390),
            (0.50,  695),
            (0.75,  463),
            (1.00,  347),
            (1.50,  231),
            (2.00,  173)
        ],
    )
    def test_calcs_from_pixel_pitch(make_mmdftpsf, pixel_pitch, expected_image_size):
&gt;       mmdftpsf = make_mmdftpsf(pixel_pitch=pixel_pitch, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_pixel_pitch[backend=numpy-0.5-695]" time="0.077"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D1B380&gt;
pixel_pitch = 0.5, expected_image_size = 695

    @pytest.mark.parametrize(
        "pixel_pitch, expected_image_size",
        [
            (0.25, 1390),
            (0.50,  695),
            (0.75,  463),
            (1.00,  347),
            (1.50,  231),
            (2.00,  173)
        ],
    )
    def test_calcs_from_pixel_pitch(make_mmdftpsf, pixel_pitch, expected_image_size):
&gt;       mmdftpsf = make_mmdftpsf(pixel_pitch=pixel_pitch, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_pixel_pitch[backend=numpy-0.75-463]" time="0.077"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794FE3BA0&gt;
pixel_pitch = 0.75, expected_image_size = 463

    @pytest.mark.parametrize(
        "pixel_pitch, expected_image_size",
        [
            (0.25, 1390),
            (0.50,  695),
            (0.75,  463),
            (1.00,  347),
            (1.50,  231),
            (2.00,  173)
        ],
    )
    def test_calcs_from_pixel_pitch(make_mmdftpsf, pixel_pitch, expected_image_size):
&gt;       mmdftpsf = make_mmdftpsf(pixel_pitch=pixel_pitch, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_pixel_pitch[backend=numpy-1.0-347]" time="0.068"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D4FBA0&gt;
pixel_pitch = 1.0, expected_image_size = 347

    @pytest.mark.parametrize(
        "pixel_pitch, expected_image_size",
        [
            (0.25, 1390),
            (0.50,  695),
            (0.75,  463),
            (1.00,  347),
            (1.50,  231),
            (2.00,  173)
        ],
    )
    def test_calcs_from_pixel_pitch(make_mmdftpsf, pixel_pitch, expected_image_size):
&gt;       mmdftpsf = make_mmdftpsf(pixel_pitch=pixel_pitch, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_pixel_pitch[backend=numpy-1.5-231]" time="0.066"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D0FBA0&gt;
pixel_pitch = 1.5, expected_image_size = 231

    @pytest.mark.parametrize(
        "pixel_pitch, expected_image_size",
        [
            (0.25, 1390),
            (0.50,  695),
            (0.75,  463),
            (1.00,  347),
            (1.50,  231),
            (2.00,  173)
        ],
    )
    def test_calcs_from_pixel_pitch(make_mmdftpsf, pixel_pitch, expected_image_size):
&gt;       mmdftpsf = make_mmdftpsf(pixel_pitch=pixel_pitch, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_pixel_pitch[backend=numpy-2.0-173]" time="0.060"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D7F1A0&gt;
pixel_pitch = 2.0, expected_image_size = 173

    @pytest.mark.parametrize(
        "pixel_pitch, expected_image_size",
        [
            (0.25, 1390),
            (0.50,  695),
            (0.75,  463),
            (1.00,  347),
            (1.50,  231),
            (2.00,  173)
        ],
    )
    def test_calcs_from_pixel_pitch(make_mmdftpsf, pixel_pitch, expected_image_size):
&gt;       mmdftpsf = make_mmdftpsf(pixel_pitch=pixel_pitch, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_pixel_pitch[backend=torch-0.25-1390]" time="0.138"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D0F740&gt;
pixel_pitch = 0.25, expected_image_size = 1390

    @pytest.mark.parametrize(
        "pixel_pitch, expected_image_size",
        [
            (0.25, 1390),
            (0.50,  695),
            (0.75,  463),
            (1.00,  347),
            (1.50,  231),
            (2.00,  173)
        ],
    )
    def test_calcs_from_pixel_pitch(make_mmdftpsf, pixel_pitch, expected_image_size):
&gt;       mmdftpsf = make_mmdftpsf(pixel_pitch=pixel_pitch, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_pixel_pitch[backend=torch-0.5-695]" time="0.142"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C33380&gt;
pixel_pitch = 0.5, expected_image_size = 695

    @pytest.mark.parametrize(
        "pixel_pitch, expected_image_size",
        [
            (0.25, 1390),
            (0.50,  695),
            (0.75,  463),
            (1.00,  347),
            (1.50,  231),
            (2.00,  173)
        ],
    )
    def test_calcs_from_pixel_pitch(make_mmdftpsf, pixel_pitch, expected_image_size):
&gt;       mmdftpsf = make_mmdftpsf(pixel_pitch=pixel_pitch, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_pixel_pitch[backend=torch-0.75-463]" time="0.147"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x00000147AD8F3380&gt;
pixel_pitch = 0.75, expected_image_size = 463

    @pytest.mark.parametrize(
        "pixel_pitch, expected_image_size",
        [
            (0.25, 1390),
            (0.50,  695),
            (0.75,  463),
            (1.00,  347),
            (1.50,  231),
            (2.00,  173)
        ],
    )
    def test_calcs_from_pixel_pitch(make_mmdftpsf, pixel_pitch, expected_image_size):
&gt;       mmdftpsf = make_mmdftpsf(pixel_pitch=pixel_pitch, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_pixel_pitch[backend=torch-1.0-347]" time="0.149"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C925C0&gt;
pixel_pitch = 1.0, expected_image_size = 347

    @pytest.mark.parametrize(
        "pixel_pitch, expected_image_size",
        [
            (0.25, 1390),
            (0.50,  695),
            (0.75,  463),
            (1.00,  347),
            (1.50,  231),
            (2.00,  173)
        ],
    )
    def test_calcs_from_pixel_pitch(make_mmdftpsf, pixel_pitch, expected_image_size):
&gt;       mmdftpsf = make_mmdftpsf(pixel_pitch=pixel_pitch, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_pixel_pitch[backend=torch-1.5-231]" time="0.192"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794FE3600&gt;
pixel_pitch = 1.5, expected_image_size = 231

    @pytest.mark.parametrize(
        "pixel_pitch, expected_image_size",
        [
            (0.25, 1390),
            (0.50,  695),
            (0.75,  463),
            (1.00,  347),
            (1.50,  231),
            (2.00,  173)
        ],
    )
    def test_calcs_from_pixel_pitch(make_mmdftpsf, pixel_pitch, expected_image_size):
&gt;       mmdftpsf = make_mmdftpsf(pixel_pitch=pixel_pitch, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_pixel_pitch[backend=torch-2.0-173]" time="0.150"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C83B00&gt;
pixel_pitch = 2.0, expected_image_size = 173

    @pytest.mark.parametrize(
        "pixel_pitch, expected_image_size",
        [
            (0.25, 1390),
            (0.50,  695),
            (0.75,  463),
            (1.00,  347),
            (1.50,  231),
            (2.00,  173)
        ],
    )
    def test_calcs_from_pixel_pitch(make_mmdftpsf, pixel_pitch, expected_image_size):
&gt;       mmdftpsf = make_mmdftpsf(pixel_pitch=pixel_pitch, image_size=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_image_size[backend=numpy-128-2.71661753109]" time="0.096"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D9DF80&gt;
image_size = 128, expected_pixel_pitch = 2.71661753109

    @pytest.mark.parametrize(
        "image_size, expected_pixel_pitch",
        [
            ( 128, 2.71661753109),
            ( 256, 1.35830876554),
            ( 512, 0.67915438277),
            (1024, 0.33957719139),
            (2048, 0.16978859569),
            (4096, 0.08489429785),
        ],
    )
    def test_calcs_from_image_size(make_mmdftpsf, image_size, expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(image_size=image_size, pixel_pitch=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_image_size[backend=numpy-256-1.35830876554]" time="0.076"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D4F740&gt;
image_size = 256, expected_pixel_pitch = 1.35830876554

    @pytest.mark.parametrize(
        "image_size, expected_pixel_pitch",
        [
            ( 128, 2.71661753109),
            ( 256, 1.35830876554),
            ( 512, 0.67915438277),
            (1024, 0.33957719139),
            (2048, 0.16978859569),
            (4096, 0.08489429785),
        ],
    )
    def test_calcs_from_image_size(make_mmdftpsf, image_size, expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(image_size=image_size, pixel_pitch=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_image_size[backend=numpy-512-0.67915438277]" time="0.129"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D9CE00&gt;
image_size = 512, expected_pixel_pitch = 0.67915438277

    @pytest.mark.parametrize(
        "image_size, expected_pixel_pitch",
        [
            ( 128, 2.71661753109),
            ( 256, 1.35830876554),
            ( 512, 0.67915438277),
            (1024, 0.33957719139),
            (2048, 0.16978859569),
            (4096, 0.08489429785),
        ],
    )
    def test_calcs_from_image_size(make_mmdftpsf, image_size, expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(image_size=image_size, pixel_pitch=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_image_size[backend=numpy-1024-0.33957719139]" time="0.079"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D7D300&gt;
image_size = 1024, expected_pixel_pitch = 0.33957719139

    @pytest.mark.parametrize(
        "image_size, expected_pixel_pitch",
        [
            ( 128, 2.71661753109),
            ( 256, 1.35830876554),
            ( 512, 0.67915438277),
            (1024, 0.33957719139),
            (2048, 0.16978859569),
            (4096, 0.08489429785),
        ],
    )
    def test_calcs_from_image_size(make_mmdftpsf, image_size, expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(image_size=image_size, pixel_pitch=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_image_size[backend=numpy-2048-0.16978859569]" time="0.067"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x00000147AD8F3060&gt;
image_size = 2048, expected_pixel_pitch = 0.16978859569

    @pytest.mark.parametrize(
        "image_size, expected_pixel_pitch",
        [
            ( 128, 2.71661753109),
            ( 256, 1.35830876554),
            ( 512, 0.67915438277),
            (1024, 0.33957719139),
            (2048, 0.16978859569),
            (4096, 0.08489429785),
        ],
    )
    def test_calcs_from_image_size(make_mmdftpsf, image_size, expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(image_size=image_size, pixel_pitch=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_image_size[backend=numpy-4096-0.08489429785]" time="0.053"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D4EA20&gt;
image_size = 4096, expected_pixel_pitch = 0.08489429785

    @pytest.mark.parametrize(
        "image_size, expected_pixel_pitch",
        [
            ( 128, 2.71661753109),
            ( 256, 1.35830876554),
            ( 512, 0.67915438277),
            (1024, 0.33957719139),
            (2048, 0.16978859569),
            (4096, 0.08489429785),
        ],
    )
    def test_calcs_from_image_size(make_mmdftpsf, image_size, expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(image_size=image_size, pixel_pitch=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_image_size[backend=torch-128-2.71661753109]" time="0.095"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D9FE20&gt;
image_size = 128, expected_pixel_pitch = 2.71661753109

    @pytest.mark.parametrize(
        "image_size, expected_pixel_pitch",
        [
            ( 128, 2.71661753109),
            ( 256, 1.35830876554),
            ( 512, 0.67915438277),
            (1024, 0.33957719139),
            (2048, 0.16978859569),
            (4096, 0.08489429785),
        ],
    )
    def test_calcs_from_image_size(make_mmdftpsf, image_size, expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(image_size=image_size, pixel_pitch=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_image_size[backend=torch-256-1.35830876554]" time="0.164"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C928E0&gt;
image_size = 256, expected_pixel_pitch = 1.35830876554

    @pytest.mark.parametrize(
        "image_size, expected_pixel_pitch",
        [
            ( 128, 2.71661753109),
            ( 256, 1.35830876554),
            ( 512, 0.67915438277),
            (1024, 0.33957719139),
            (2048, 0.16978859569),
            (4096, 0.08489429785),
        ],
    )
    def test_calcs_from_image_size(make_mmdftpsf, image_size, expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(image_size=image_size, pixel_pitch=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_image_size[backend=torch-512-0.67915438277]" time="0.213"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D274C0&gt;
image_size = 512, expected_pixel_pitch = 0.67915438277

    @pytest.mark.parametrize(
        "image_size, expected_pixel_pitch",
        [
            ( 128, 2.71661753109),
            ( 256, 1.35830876554),
            ( 512, 0.67915438277),
            (1024, 0.33957719139),
            (2048, 0.16978859569),
            (4096, 0.08489429785),
        ],
    )
    def test_calcs_from_image_size(make_mmdftpsf, image_size, expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(image_size=image_size, pixel_pitch=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_image_size[backend=torch-1024-0.33957719139]" time="0.155"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C836A0&gt;
image_size = 1024, expected_pixel_pitch = 0.33957719139

    @pytest.mark.parametrize(
        "image_size, expected_pixel_pitch",
        [
            ( 128, 2.71661753109),
            ( 256, 1.35830876554),
            ( 512, 0.67915438277),
            (1024, 0.33957719139),
            (2048, 0.16978859569),
            (4096, 0.08489429785),
        ],
    )
    def test_calcs_from_image_size(make_mmdftpsf, image_size, expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(image_size=image_size, pixel_pitch=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_image_size[backend=torch-2048-0.16978859569]" time="0.119"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794FE0720&gt;
image_size = 2048, expected_pixel_pitch = 0.16978859569

    @pytest.mark.parametrize(
        "image_size, expected_pixel_pitch",
        [
            ( 128, 2.71661753109),
            ( 256, 1.35830876554),
            ( 512, 0.67915438277),
            (1024, 0.33957719139),
            (2048, 0.16978859569),
            (4096, 0.08489429785),
        ],
    )
    def test_calcs_from_image_size(make_mmdftpsf, image_size, expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(image_size=image_size, pixel_pitch=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_calcs_from_image_size[backend=torch-4096-0.08489429785]" time="0.140"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C93E20&gt;
image_size = 4096, expected_pixel_pitch = 0.08489429785

    @pytest.mark.parametrize(
        "image_size, expected_pixel_pitch",
        [
            ( 128, 2.71661753109),
            ( 256, 1.35830876554),
            ( 512, 0.67915438277),
            (1024, 0.33957719139),
            (2048, 0.16978859569),
            (4096, 0.08489429785),
        ],
    )
    def test_calcs_from_image_size(make_mmdftpsf, image_size, expected_pixel_pitch):
&gt;       mmdftpsf = make_mmdftpsf(image_size=image_size, pixel_pitch=None)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_num_rays_below_32[backend=numpy-32-None-expectation0]" time="0.079"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794CA4720&gt;
num_rays = 32, image_size = None
expectation = &lt;contextlib.nullcontext object at 0x000001478D815310&gt;

    @pytest.mark.parametrize(
        "num_rays,image_size,expectation",
        [
            (32, None, does_not_raise()),
            (64, None, does_not_raise()),
            (12, 16, does_not_raise()),
            (
                16,
                None,
                pytest.raises(
                    ValueError,
                    match="num_rays must be at least 32 if image_size and pixel_pitch are "
                          "not specified.",
                ),
            ),
        ],
    )
    def test_num_rays_below_32(make_mmdftpsf, num_rays, image_size, expectation):
        with expectation:
&gt;           make_mmdftpsf(num_rays=num_rays, image_size=image_size)

tests\test_mmdft_psf.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_num_rays_below_32[backend=numpy-64-None-expectation1]" time="0.058"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014795023CE0&gt;
num_rays = 64, image_size = None
expectation = &lt;contextlib.nullcontext object at 0x000001478D814BD0&gt;

    @pytest.mark.parametrize(
        "num_rays,image_size,expectation",
        [
            (32, None, does_not_raise()),
            (64, None, does_not_raise()),
            (12, 16, does_not_raise()),
            (
                16,
                None,
                pytest.raises(
                    ValueError,
                    match="num_rays must be at least 32 if image_size and pixel_pitch are "
                          "not specified.",
                ),
            ),
        ],
    )
    def test_num_rays_below_32(make_mmdftpsf, num_rays, image_size, expectation):
        with expectation:
&gt;           make_mmdftpsf(num_rays=num_rays, image_size=image_size)

tests\test_mmdft_psf.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_num_rays_below_32[backend=numpy-12-16-expectation2]" time="0.080"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D58F40&gt;
num_rays = 12, image_size = 16
expectation = &lt;contextlib.nullcontext object at 0x000001478D814C90&gt;

    @pytest.mark.parametrize(
        "num_rays,image_size,expectation",
        [
            (32, None, does_not_raise()),
            (64, None, does_not_raise()),
            (12, 16, does_not_raise()),
            (
                16,
                None,
                pytest.raises(
                    ValueError,
                    match="num_rays must be at least 32 if image_size and pixel_pitch are "
                          "not specified.",
                ),
            ),
        ],
    )
    def test_num_rays_below_32(make_mmdftpsf, num_rays, image_size, expectation):
        with expectation:
&gt;           make_mmdftpsf(num_rays=num_rays, image_size=image_size)

tests\test_mmdft_psf.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_num_rays_below_32[backend=numpy-16-None-expectation3]" time="0.079" /><testcase classname="tests.test_mmdft_psf" name="test_num_rays_below_32[backend=torch-32-None-expectation0]" time="0.169"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794CA76A0&gt;
num_rays = 32, image_size = None
expectation = &lt;contextlib.nullcontext object at 0x000001478D815310&gt;

    @pytest.mark.parametrize(
        "num_rays,image_size,expectation",
        [
            (32, None, does_not_raise()),
            (64, None, does_not_raise()),
            (12, 16, does_not_raise()),
            (
                16,
                None,
                pytest.raises(
                    ValueError,
                    match="num_rays must be at least 32 if image_size and pixel_pitch are "
                          "not specified.",
                ),
            ),
        ],
    )
    def test_num_rays_below_32(make_mmdftpsf, num_rays, image_size, expectation):
        with expectation:
&gt;           make_mmdftpsf(num_rays=num_rays, image_size=image_size)

tests\test_mmdft_psf.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_num_rays_below_32[backend=torch-64-None-expectation1]" time="0.112"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D0ECA0&gt;
num_rays = 64, image_size = None
expectation = &lt;contextlib.nullcontext object at 0x000001478D814BD0&gt;

    @pytest.mark.parametrize(
        "num_rays,image_size,expectation",
        [
            (32, None, does_not_raise()),
            (64, None, does_not_raise()),
            (12, 16, does_not_raise()),
            (
                16,
                None,
                pytest.raises(
                    ValueError,
                    match="num_rays must be at least 32 if image_size and pixel_pitch are "
                          "not specified.",
                ),
            ),
        ],
    )
    def test_num_rays_below_32(make_mmdftpsf, num_rays, image_size, expectation):
        with expectation:
&gt;           make_mmdftpsf(num_rays=num_rays, image_size=image_size)

tests\test_mmdft_psf.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_num_rays_below_32[backend=torch-12-16-expectation2]" time="0.147"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D5ACA0&gt;
num_rays = 12, image_size = 16
expectation = &lt;contextlib.nullcontext object at 0x000001478D814C90&gt;

    @pytest.mark.parametrize(
        "num_rays,image_size,expectation",
        [
            (32, None, does_not_raise()),
            (64, None, does_not_raise()),
            (12, 16, does_not_raise()),
            (
                16,
                None,
                pytest.raises(
                    ValueError,
                    match="num_rays must be at least 32 if image_size and pixel_pitch are "
                          "not specified.",
                ),
            ),
        ],
    )
    def test_num_rays_below_32(make_mmdftpsf, num_rays, image_size, expectation):
        with expectation:
&gt;           make_mmdftpsf(num_rays=num_rays, image_size=image_size)

tests\test_mmdft_psf.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_num_rays_below_32[backend=torch-16-None-expectation3]" time="0.128" /><testcase classname="tests.test_mmdft_psf" name="test_image_size[backend=numpy-64-128]" time="0.126"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D4F100&gt;
num_rays = 64, image_size = 128

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (64, 128),
            (65, 256),
            (64, 257),
        ],
    )
    def test_image_size(make_mmdftpsf, num_rays, image_size):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=image_size)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_image_size[backend=numpy-65-256]" time="0.135"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D7CFE0&gt;
num_rays = 65, image_size = 256

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (64, 128),
            (65, 256),
            (64, 257),
        ],
    )
    def test_image_size(make_mmdftpsf, num_rays, image_size):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=image_size)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_image_size[backend=numpy-64-257]" time="0.107"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D4F060&gt;
num_rays = 64, image_size = 257

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (64, 128),
            (65, 256),
            (64, 257),
        ],
    )
    def test_image_size(make_mmdftpsf, num_rays, image_size):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=image_size)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_image_size[backend=torch-64-128]" time="0.193"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D7CD60&gt;
num_rays = 64, image_size = 128

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (64, 128),
            (65, 256),
            (64, 257),
        ],
    )
    def test_image_size(make_mmdftpsf, num_rays, image_size):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=image_size)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_image_size[backend=torch-65-256]" time="0.196"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C18AE0&gt;
num_rays = 65, image_size = 256

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (64, 128),
            (65, 256),
            (64, 257),
        ],
    )
    def test_image_size(make_mmdftpsf, num_rays, image_size):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=image_size)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_image_size[backend=torch-64-257]" time="0.163"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C83880&gt;
num_rays = 64, image_size = 257

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (64, 128),
            (65, 256),
            (64, 257),
        ],
    )
    def test_image_size(make_mmdftpsf, num_rays, image_size):
&gt;       mmdftpsf = make_mmdftpsf(num_rays=num_rays, image_size=image_size)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_invalid_image_size[backend=numpy]" time="0.114"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D589A0&gt;

    def test_invalid_image_size(make_mmdftpsf):
        with pytest.raises(
            ValueError,
            match=r"Supplied image_size of \d+ not less than or equal to calculated "
                  r"pad size of \d+",
        ):
&gt;           make_mmdftpsf(image_size=400, pixel_pitch=1)

tests\test_mmdft_psf.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_invalid_image_size[backend=torch]" time="0.156"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D4DF80&gt;

    def test_invalid_image_size(make_mmdftpsf):
        with pytest.raises(
            ValueError,
            match=r"Supplied image_size of \d+ not less than or equal to calculated "
                  r"pad size of \d+",
        ):
&gt;           make_mmdftpsf(image_size=400, pixel_pitch=1)

tests\test_mmdft_psf.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_strehl_ratio[backend=numpy]" time="0.092"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C80900&gt;

    def test_strehl_ratio(make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(image_size=256)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_strehl_ratio[backend=torch]" time="0.129"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D5AFC0&gt;

    def test_strehl_ratio(make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(image_size=256)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view[backend=numpy-2d-False]" time="0.065"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">projection = '2d', log = False
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D1ADE0&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_mmdftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view[backend=numpy-3d-False]" time="0.064"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">projection = '3d', log = False
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x00000147950223E0&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_mmdftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view[backend=numpy-2d-True]" time="0.089"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">projection = '2d', log = True
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D1A980&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_mmdftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view[backend=numpy-3d-True]" time="0.076"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">projection = '3d', log = True
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014795021F80&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_mmdftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view[backend=torch-2d-False]" time="0.140"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">projection = '2d', log = False
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x000001479525F9C0&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_mmdftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view[backend=torch-3d-False]" time="0.127"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">projection = '3d', log = False
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D4C180&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_mmdftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view[backend=torch-2d-True]" time="0.127"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">projection = '2d', log = True
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794FE2AC0&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_mmdftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view[backend=torch-3d-True]" time="0.119"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">projection = '3d', log = True
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D0F100&gt;
set_test_backend = None

    @pytest.mark.parametrize(
        "projection, log",
        [
            ("2d", False),
            ("3d", False),
            ("2d", True),
            ("3d", True),
        ],
    )
    def test_view(projection, log, make_mmdftpsf, set_test_backend):
        # Skip for torch since view isn't implemented there
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_find_bounds[backend=numpy]" time="0.064"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D4F740&gt;

    def test_find_bounds(make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_find_bounds[backend=torch]" time="0.101"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C82AC0&gt;

    def test_find_bounds(make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view_invalid_projection[backend=numpy]" time="0.051"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x000001479525CF40&gt;

    def test_view_invalid_projection(make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view_invalid_projection[backend=torch]" time="0.117"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D4CAE0&gt;

    def test_view_invalid_projection(make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view_annotate_sampling[backend=numpy-2d]" time="0.063"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">mock_text = &lt;MagicMock name='text' id='1406938252432'&gt;, projection = '2d'
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C82A20&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    @patch("matplotlib.figure.Figure.text")
    def test_view_annotate_sampling(mock_text, projection, make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view_annotate_sampling[backend=numpy-3d]" time="0.092"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">mock_text = &lt;MagicMock name='text' id='1407126053904'&gt;, projection = '3d'
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794FE1BC0&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    @patch("matplotlib.figure.Figure.text")
    def test_view_annotate_sampling(mock_text, projection, make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view_annotate_sampling[backend=torch-2d]" time="0.124"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">mock_text = &lt;MagicMock name='text' id='1407342578512'&gt;, projection = '2d'
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D59620&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    @patch("matplotlib.figure.Figure.text")
    def test_view_annotate_sampling(mock_text, projection, make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view_annotate_sampling[backend=torch-3d]" time="0.123"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">mock_text = &lt;MagicMock name='text' id='1406938409104'&gt;, projection = '3d'
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D4F740&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    @patch("matplotlib.figure.Figure.text")
    def test_view_annotate_sampling(mock_text, projection, make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view_oversampling[backend=numpy-2d]" time="0.068"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">projection = '2d'
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C83F60&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    def test_view_oversampling(projection, make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view_oversampling[backend=numpy-3d]" time="0.096"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">projection = '3d'
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x000001479525D580&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    def test_view_oversampling(projection, make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view_oversampling[backend=torch-2d]" time="0.104"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">projection = '2d'
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C825C0&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    def test_view_oversampling(projection, make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_view_oversampling[backend=torch-3d]" time="0.132"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">projection = '3d'
make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C91080&gt;

    @pytest.mark.parametrize(
        "projection",
        [
            "2d",
            "3d",
        ],
    )
    def test_view_oversampling(projection, make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_get_units_finite_obj[backend=numpy]" time="0.056"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D59760&gt;

    def test_get_units_finite_obj(make_mmdftpsf):
        def tweak(optic):
            optic.surface_group.surfaces[0].geometry.cs.z = -be.array(1e6)
    
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1), tweak_optic=tweak)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_get_units_finite_obj[backend=torch]" time="0.101"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014795022B60&gt;

    def test_get_units_finite_obj(make_mmdftpsf):
        def tweak(optic):
            optic.surface_group.surfaces[0].geometry.cs.z = -be.array(1e6)
    
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1), tweak_optic=tweak)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_psf_log_tick_formatter[backend=numpy]" time="0.073"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C316C0&gt;

    def test_psf_log_tick_formatter(make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_psf_log_tick_formatter[backend=torch]" time="0.103"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D5AAC0&gt;

    def test_psf_log_tick_formatter(make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_invalid_working_FNO[backend=numpy]" time="0.108"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014795023E20&gt;

    def test_invalid_working_FNO(make_mmdftpsf):
        def tweak(optic):
            optic.surface_group.surfaces[0].geometry.cs.z = -be.array(1e100)
    
        with pytest.raises(ValueError):
&gt;           mmdftpsf = make_mmdftpsf(field=(0, 1), tweak_optic=tweak)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_invalid_working_FNO[backend=torch]" time="0.199"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D09300&gt;

    def test_invalid_working_FNO(make_mmdftpsf):
        def tweak(optic):
            optic.surface_group.surfaces[0].geometry.cs.z = -be.array(1e100)
    
        with pytest.raises(ValueError):
&gt;           mmdftpsf = make_mmdftpsf(field=(0, 1), tweak_optic=tweak)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_interpolate_zoom_factor_one[backend=numpy]" time="0.081"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D55300&gt;

    def test_interpolate_zoom_factor_one(make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_interpolate_zoom_factor_one[backend=torch]" time="0.109"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794C18B80&gt;

    def test_interpolate_zoom_factor_one(make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_large_threshold[backend=numpy]" time="0.082"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D0BC40&gt;

    def test_large_threshold(make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_large_threshold[backend=torch]" time="0.150"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf = &lt;function make_mmdftpsf.&lt;locals&gt;._factory at 0x0000014794D54360&gt;

    def test_large_threshold(make_mmdftpsf):
&gt;       mmdftpsf = make_mmdftpsf(field=(0, 1))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mmdft_psf.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:29: in _factory
    return MMDFTPSF(
optiland\psf\mmdft.py:80: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=numpy-32-64]" time="0.089"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794C90D60&gt;
num_rays = 32, image_size = 64

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=numpy-45-128]" time="0.104"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794C332E0&gt;
num_rays = 45, image_size = 128

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=numpy-64-256]" time="0.099"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794C90720&gt;
num_rays = 64, image_size = 256

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=numpy-90-512]" time="0.075"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794C32D40&gt;
num_rays = 90, image_size = 512

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=numpy-181-2048]" time="0.070"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794C18F40&gt;
num_rays = 181, image_size = 2048

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=numpy-128-128]" time="0.075"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794D1BC40&gt;
num_rays = 128, image_size = 128

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=numpy-256-256]" time="0.059"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794C1ADE0&gt;
num_rays = 256, image_size = 256

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=numpy-512-512]" time="0.098"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794D09EE0&gt;
num_rays = 512, image_size = 512

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=torch-32-64]" time="0.184"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794C90FE0&gt;
num_rays = 32, image_size = 64

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=torch-45-128]" time="0.119"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794CA5800&gt;
num_rays = 45, image_size = 128

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=torch-64-256]" time="0.121"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794D9EFC0&gt;
num_rays = 64, image_size = 256

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=torch-90-512]" time="0.118"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794D26480&gt;
num_rays = 90, image_size = 512

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=torch-181-2048]" time="0.120"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794C92B60&gt;
num_rays = 181, image_size = 2048

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=torch-128-128]" time="0.147"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794D572E0&gt;
num_rays = 128, image_size = 128

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=torch-256-256]" time="0.116"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794D9EE80&gt;
num_rays = 256, image_size = 256

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mmdft_psf" name="test_fft_agreement[backend=torch-512-512]" time="0.120"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">make_mmdftpsf_and_fftpsf = &lt;function make_mmdftpsf_and_fftpsf.&lt;locals&gt;._factory at 0x0000014794C185E0&gt;
num_rays = 512, image_size = 512

    @pytest.mark.parametrize(
        "num_rays, image_size",
        [
            (32, 64),
            (45, 128),
            (64, 256),
            (90, 512),
            (181, 2048),
            (128, 128),
            (256, 256),
            (512, 512)
        ],
    )
    def test_fft_agreement(make_mmdftpsf_and_fftpsf, num_rays, image_size):
&gt;       fftpsf, mmdftpsf = make_mmdftpsf_and_fftpsf(num_rays=num_rays,
                                                    image_size=image_size)

tests\test_mmdft_psf.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_mmdft_psf.py:49: in _factory
    fftpsf = FFTPSF(optic,
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_monte_carlo" name="test_run" time="0.803" /><testcase classname="tests.test_monte_carlo" name="test_run_no_compensator" time="0.188" /><testcase classname="tests.test_monte_carlo" name="test_view_histogram" time="0.335" /><testcase classname="tests.test_monte_carlo" name="test_view_histogram_no_kde" time="0.418" /><testcase classname="tests.test_monte_carlo" name="test_view_cdf" time="0.360" /><testcase classname="tests.test_monte_carlo" name="test_view_heatmap" time="0.365" /><testcase classname="tests.test_monte_carlo" name="test_invalid_plot_type" time="0.222" /><testcase classname="tests.test_monte_carlo" name="test_validate_no_operands" time="0.228" /><testcase classname="tests.test_monte_carlo" name="test_validate_no_perturbations" time="0.211" /><testcase classname="tests.test_mtf.TestGeometricMTF" name="test_view_mtf_defaults[backend=numpy]" time="1.039" /><testcase classname="tests.test_mtf.TestGeometricMTF" name="test_view_mtf_defaults[backend=torch]" time="2.476" /><testcase classname="tests.test_mtf.TestGeometricMTF" name="test_view_mtf_custom_fig[backend=numpy]" time="0.837" /><testcase classname="tests.test_mtf.TestGeometricMTF" name="test_view_mtf_custom_fig[backend=torch]" time="1.734" /><testcase classname="tests.test_mtf.TestGeometricMTF" name="test_generate_data_scaled[backend=numpy]" time="0.801" /><testcase classname="tests.test_mtf.TestGeometricMTF" name="test_generate_data_scaled[backend=torch]" time="2.801" /><testcase classname="tests.test_mtf.TestGeometricMTF" name="test_generate_data_unscaled[backend=numpy]" time="0.790" /><testcase classname="tests.test_mtf.TestGeometricMTF" name="test_generate_data_unscaled[backend=torch]" time="2.561" /><testcase classname="tests.test_mtf.TestGeometricMTF" name="test_max_freq_specification[backend=numpy]" time="1.229" /><testcase classname="tests.test_mtf.TestGeometricMTF" name="test_max_freq_specification[backend=torch]" time="2.774" /><testcase classname="tests.test_mtf.TestFFTMTF" name="test_view_mtf_defaults[backend=numpy]" time="0.105"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F073D50&gt;
set_test_backend = None
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x0000014796445790&gt;

    def test_view_mtf_defaults(self, set_test_backend, optic):
&gt;       m = FFTMTF(optic)
            ^^^^^^^^^^^^^

tests\test_mtf.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_view_mtf_defaults[backend=torch]" time="0.156"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F073FD0&gt;
set_test_backend = None
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147AC5219D0&gt;

    def test_view_mtf_defaults(self, set_test_backend, optic):
&gt;       m = FFTMTF(optic)
            ^^^^^^^^^^^^^

tests\test_mtf.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_view_mtf_custom_fig[backend=numpy]" time="0.092"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F074C50&gt;
set_test_backend = None
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x0000014795C8C110&gt;

    def test_view_mtf_custom_fig(self, set_test_backend, optic):
&gt;       m = FFTMTF(optic)
            ^^^^^^^^^^^^^

tests\test_mtf.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_view_mtf_custom_fig[backend=torch]" time="0.147"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F074ED0&gt;
set_test_backend = None
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147ABCD3B50&gt;

    def test_view_mtf_custom_fig(self, set_test_backend, optic):
&gt;       m = FFTMTF(optic)
            ^^^^^^^^^^^^^

tests\test_mtf.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_generate_data_infinite_object[backend=numpy]" time="0.098"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F075AD0&gt;
set_test_backend = None
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147964A5990&gt;

    def test_generate_data_infinite_object(self, set_test_backend, optic):
        """Default (infinite object distance) should produce an MTF array."""
&gt;       m = FFTMTF(optic)
            ^^^^^^^^^^^^^

tests\test_mtf.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_generate_data_infinite_object[backend=torch]" time="0.161"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F075D50&gt;
set_test_backend = None
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147969F1C10&gt;

    def test_generate_data_infinite_object(self, set_test_backend, optic):
        """Default (infinite object distance) should produce an MTF array."""
&gt;       m = FFTMTF(optic)
            ^^^^^^^^^^^^^

tests\test_mtf.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_generate_data_finite_object[backend=numpy]" time="0.086"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F076950&gt;
set_test_backend = None
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147A61F8750&gt;

    def test_generate_data_finite_object(self, set_test_backend, optic):
        """With a finite object distance, MTF still gets generated."""
        # Push the first surface very far away to mimic a finite-object scenario
        optic.surface_group.surfaces[0].geometry.cs.z = be.array(1e6)
&gt;       m = FFTMTF(optic)
            ^^^^^^^^^^^^^

tests\test_mtf.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_generate_data_finite_object[backend=torch]" time="0.162"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F076BD0&gt;
set_test_backend = None
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147ABD3CDD0&gt;

    def test_generate_data_finite_object(self, set_test_backend, optic):
        """With a finite object distance, MTF still gets generated."""
        # Push the first surface very far away to mimic a finite-object scenario
        optic.surface_group.surfaces[0].geometry.cs.z = be.array(1e6)
&gt;       m = FFTMTF(optic)
            ^^^^^^^^^^^^^

tests\test_mtf.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_num_rays_and_grid_size[32-32-backend=numpy]" time="0.082"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F077990&gt;
set_test_backend = None, num_rays = 32, expected_pupil_sampling = 32
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x0000014794A3F990&gt;

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(
        self, set_test_backend, num_rays, expected_pupil_sampling, optic
    ):
&gt;       m = FFTMTF(optic, num_rays=num_rays, grid_size=None)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mtf.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_num_rays_and_grid_size[32-32-backend=torch]" time="0.195"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F077D10&gt;
set_test_backend = None, num_rays = 32, expected_pupil_sampling = 32
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x000001479527EF90&gt;

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(
        self, set_test_backend, num_rays, expected_pupil_sampling, optic
    ):
&gt;       m = FFTMTF(optic, num_rays=num_rays, grid_size=None)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mtf.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_num_rays_and_grid_size[64-45-backend=numpy]" time="0.074"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F06BED0&gt;
set_test_backend = None, num_rays = 64, expected_pupil_sampling = 45
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x0000014795212010&gt;

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(
        self, set_test_backend, num_rays, expected_pupil_sampling, optic
    ):
&gt;       m = FFTMTF(optic, num_rays=num_rays, grid_size=None)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mtf.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_num_rays_and_grid_size[64-45-backend=torch]" time="0.176"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478EF50990&gt;
set_test_backend = None, num_rays = 64, expected_pupil_sampling = 45
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x0000014795294A90&gt;

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(
        self, set_test_backend, num_rays, expected_pupil_sampling, optic
    ):
&gt;       m = FFTMTF(optic, num_rays=num_rays, grid_size=None)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mtf.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_num_rays_and_grid_size[128-64-backend=numpy]" time="0.083"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478EDCBF10&gt;
set_test_backend = None, num_rays = 128, expected_pupil_sampling = 64
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147952353D0&gt;

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(
        self, set_test_backend, num_rays, expected_pupil_sampling, optic
    ):
&gt;       m = FFTMTF(optic, num_rays=num_rays, grid_size=None)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mtf.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_num_rays_and_grid_size[128-64-backend=torch]" time="0.128"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F080890&gt;
set_test_backend = None, num_rays = 128, expected_pupil_sampling = 64
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147B04DF190&gt;

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(
        self, set_test_backend, num_rays, expected_pupil_sampling, optic
    ):
&gt;       m = FFTMTF(optic, num_rays=num_rays, grid_size=None)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mtf.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_num_rays_and_grid_size[256-90-backend=numpy]" time="0.070"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F0809D0&gt;
set_test_backend = None, num_rays = 256, expected_pupil_sampling = 90
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x0000014795031350&gt;

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(
        self, set_test_backend, num_rays, expected_pupil_sampling, optic
    ):
&gt;       m = FFTMTF(optic, num_rays=num_rays, grid_size=None)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mtf.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_num_rays_and_grid_size[256-90-backend=torch]" time="0.132"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F080B10&gt;
set_test_backend = None, num_rays = 256, expected_pupil_sampling = 90
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147951E2F10&gt;

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(
        self, set_test_backend, num_rays, expected_pupil_sampling, optic
    ):
&gt;       m = FFTMTF(optic, num_rays=num_rays, grid_size=None)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mtf.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_num_rays_and_grid_size[1024-181-backend=numpy]" time="0.075"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F080C50&gt;
set_test_backend = None, num_rays = 1024, expected_pupil_sampling = 181
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x000001478D84F5D0&gt;

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(
        self, set_test_backend, num_rays, expected_pupil_sampling, optic
    ):
&gt;       m = FFTMTF(optic, num_rays=num_rays, grid_size=None)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mtf.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_mtf.TestFFTMTF" name="test_num_rays_and_grid_size[1024-181-backend=torch]" time="0.124"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_mtf.TestFFTMTF object at 0x000001478F080D10&gt;
set_test_backend = None, num_rays = 1024, expected_pupil_sampling = 181
optic = &lt;optiland.samples.objectives.CookeTriplet object at 0x00000147964A7C50&gt;

    @pytest.mark.parametrize(
        "num_rays,expected_pupil_sampling",
        [
            (32, 32),
            (64, 45),
            (128, 64),
            (256, 90),
            (1024, 181),
        ],
    )
    def test_num_rays_and_grid_size(
        self, set_test_backend, num_rays, expected_pupil_sampling, optic
    ):
&gt;       m = FFTMTF(optic, num_rays=num_rays, grid_size=None)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_mtf.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\fft.py:71: in __init__
    super().__init__(optic, fields, wavelength, strategy, remove_tilt, **kwargs)
optiland\mtf\base.py:66: in __init__
    self._calculate_psf()
optiland\mtf\fft.py:87: in _calculate_psf
    self.psf = [
optiland\mtf\fft.py:88: in &lt;listcomp&gt;
    FFTPSF(
optiland\psf\fft.py:110: in __init__
    super().__init__(
optiland\psf\base.py:78: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_object_surface" name="test_is_infinite[backend=numpy]" time="0.004" /><testcase classname="tests.test_object_surface" name="test_is_infinite[backend=torch]" time="0.003" /><testcase classname="tests.test_object_surface" name="test_set_aperture[backend=numpy]" time="0.003" /><testcase classname="tests.test_object_surface" name="test_set_aperture[backend=torch]" time="0.005" /><testcase classname="tests.test_object_surface" name="test_trace[backend=numpy]" time="0.006" /><testcase classname="tests.test_object_surface" name="test_trace[backend=torch]" time="0.006" /><testcase classname="tests.test_object_surface" name="test_trace_paraxial[backend=numpy]" time="0.004" /><testcase classname="tests.test_object_surface" name="test_trace_paraxial[backend=torch]" time="0.004" /><testcase classname="tests.test_object_surface" name="test_trace_real[backend=numpy]" time="0.002" /><testcase classname="tests.test_object_surface" name="test_trace_real[backend=torch]" time="0.003" /><testcase classname="tests.test_object_surface" name="test_interact[backend=numpy]" time="0.002" /><testcase classname="tests.test_object_surface" name="test_interact[backend=torch]" time="0.005" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_f1[backend=numpy]" time="0.006" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_f1[backend=torch]" time="0.012" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_f2[backend=numpy]" time="0.007" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_f2[backend=torch]" time="0.013" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_F1[backend=numpy]" time="0.005" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_F1[backend=torch]" time="0.010" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_F2[backend=numpy]" time="0.005" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_F2[backend=torch]" time="0.013" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_P1[backend=numpy]" time="0.008" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_P1[backend=torch]" time="0.029" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_P2[backend=numpy]" time="0.016" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_P2[backend=torch]" time="0.048" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_N1[backend=numpy]" time="0.007" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_N1[backend=torch]" time="0.011" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_N2[backend=numpy]" time="0.005" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_N2[backend=torch]" time="0.020" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_EPL[backend=numpy]" time="0.003" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_EPL[backend=torch]" time="0.008" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_EPD[backend=numpy]" time="0.002" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_EPD[backend=torch]" time="0.005" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_XPL[backend=numpy]" time="0.003" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_XPL[backend=torch]" time="0.009" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_XPD[backend=numpy]" time="0.007" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_XPD[backend=torch]" time="0.019" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_magnification[backend=numpy]" time="0.002" /><testcase classname="tests.test_operand.TestParaxialOperand" name="test_magnification[backend=torch]" time="0.003" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_seidel[backend=numpy]" time="0.011" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_seidel[backend=torch]" time="0.065" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TSC[backend=numpy]" time="0.015" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TSC[backend=torch]" time="0.069" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_SC[backend=numpy]" time="0.015" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_SC[backend=torch]" time="0.072" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_CC[backend=numpy]" time="0.020" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_CC[backend=torch]" time="0.065" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TCC[backend=numpy]" time="0.019" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TCC[backend=torch]" time="0.072" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TAC[backend=numpy]" time="0.016" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TAC[backend=torch]" time="0.066" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_AC[backend=numpy]" time="0.016" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_AC[backend=torch]" time="0.068" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TPC[backend=numpy]" time="0.015" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TPC[backend=torch]" time="0.063" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_PC[backend=numpy]" time="0.019" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_PC[backend=torch]" time="0.078" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_DC[backend=numpy]" time="0.014" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_DC[backend=torch]" time="0.082" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TAchC[backend=numpy]" time="0.016" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TAchC[backend=torch]" time="0.086" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_LchC[backend=numpy]" time="0.013" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_LchC[backend=torch]" time="0.080" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TchC[backend=numpy]" time="0.014" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TchC[backend=torch]" time="0.056" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TSC_sum[backend=numpy]" time="0.013" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TSC_sum[backend=torch]" time="0.063" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_SC_sum[backend=numpy]" time="0.013" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_SC_sum[backend=torch]" time="0.052" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_CC_sum[backend=numpy]" time="0.013" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_CC_sum[backend=torch]" time="0.063" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TCC_sum[backend=numpy]" time="0.021" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TCC_sum[backend=torch]" time="0.067" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TAC_sum[backend=numpy]" time="0.015" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TAC_sum[backend=torch]" time="0.056" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_AC_sum[backend=numpy]" time="0.015" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_AC_sum[backend=torch]" time="0.065" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TPC_sum[backend=numpy]" time="0.017" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TPC_sum[backend=torch]" time="0.062" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_PC_sum[backend=numpy]" time="0.014" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_PC_sum[backend=torch]" time="0.069" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_DC_sum[backend=numpy]" time="0.026" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_DC_sum[backend=torch]" time="0.086" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TAchC_sum[backend=numpy]" time="0.034" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TAchC_sum[backend=torch]" time="0.065" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_LchC_sum[backend=numpy]" time="0.024" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_LchC_sum[backend=torch]" time="0.077" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TchC_sum[backend=numpy]" time="0.018" /><testcase classname="tests.test_operand.TestAberrationOperand" name="test_TchC_sum[backend=torch]" time="0.092" /><testcase classname="tests.test_operand.TestRayOperand" name="test_x_intercept[backend=numpy]" time="0.014" /><testcase classname="tests.test_operand.TestRayOperand" name="test_x_intercept[backend=torch]" time="0.057" /><testcase classname="tests.test_operand.TestRayOperand" name="test_y_intercept[backend=numpy]" time="0.012" /><testcase classname="tests.test_operand.TestRayOperand" name="test_y_intercept[backend=torch]" time="0.066" /><testcase classname="tests.test_operand.TestRayOperand" name="test_z_intercept[backend=numpy]" time="0.014" /><testcase classname="tests.test_operand.TestRayOperand" name="test_z_intercept[backend=torch]" time="0.061" /><testcase classname="tests.test_operand.TestRayOperand" name="test_x_intercept_lcs[backend=numpy]" time="0.009" /><testcase classname="tests.test_operand.TestRayOperand" name="test_x_intercept_lcs[backend=torch]" time="0.035" /><testcase classname="tests.test_operand.TestRayOperand" name="test_y_intercept_lcs[backend=numpy]" time="0.011" /><testcase classname="tests.test_operand.TestRayOperand" name="test_y_intercept_lcs[backend=torch]" time="0.041" /><testcase classname="tests.test_operand.TestRayOperand" name="test_z_intercept_lcs[backend=numpy]" time="0.014" /><testcase classname="tests.test_operand.TestRayOperand" name="test_z_intercept_lcs[backend=torch]" time="0.049" /><testcase classname="tests.test_operand.TestRayOperand" name="test_L[backend=numpy]" time="0.011" /><testcase classname="tests.test_operand.TestRayOperand" name="test_L[backend=torch]" time="0.049" /><testcase classname="tests.test_operand.TestRayOperand" name="test_M[backend=numpy]" time="0.013" /><testcase classname="tests.test_operand.TestRayOperand" name="test_M[backend=torch]" time="0.035" /><testcase classname="tests.test_operand.TestRayOperand" name="test_N[backend=numpy]" time="0.011" /><testcase classname="tests.test_operand.TestRayOperand" name="test_N[backend=torch]" time="0.046" /><testcase classname="tests.test_operand.TestRayOperand" name="test_rms_spot_size[backend=numpy]" time="0.146" /><testcase classname="tests.test_operand.TestRayOperand" name="test_rms_spot_size[backend=torch]" time="0.229" /><testcase classname="tests.test_operand.TestRayOperand" name="test_rms_spot_size_all_wave[backend=numpy]" time="0.128" /><testcase classname="tests.test_operand.TestRayOperand" name="test_rms_spot_size_all_wave[backend=torch]" time="0.220" /><testcase classname="tests.test_operand.TestRayOperand" name="test_opd_diff[backend=numpy]" time="0.013"><failure message="ValueError: Gaussian quadrature must have between 1 and 6 rings.">self = &lt;tests.test_operand.TestRayOperand object at 0x000001478F0F42D0&gt;
set_test_backend = None
hubble = &lt;optiland.samples.telescopes.HubbleTelescope object at 0x0000014796582B50&gt;

    def test_opd_diff(self, set_test_backend, hubble):
        data = {
            "optic": hubble,
            "Hx": 0.0,
            "Hy": 1.0,
            "wavelength": 0.55,
            "num_rays": 3,
        }
&gt;       assert_allclose(operand.RayOperand.OPD_difference(**data), 0.0732334055041471)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_operand.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optimization\operand\ray.py:372: in OPD_difference
    wf = wavefront.Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:283: in generate_points
    radius = self._get_radius(num_rings)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.GaussianQuadrature object at 0x000001479502DF90&gt;
num_rings = None

    def _get_radius(self, num_rings: int) -&gt; be.ndarray:
        """Get the radius values for the given number of rings.
    
        Args:
            num_rings (int): Number of rings for Gaussian quadrature.
    
        Returns:
            be.ndarray: Radius values for the given number of rings.
    
        Raises:
            ValueError: If the number of rings is not between 1 and 6.
    
        """
        radius_dict = {
            1: be.array([0.70711]),
            2: be.array([0.45970, 0.88807]),
            3: be.array([0.33571, 0.70711, 0.94196]),
            4: be.array([0.26350, 0.57446, 0.81853, 0.96466]),
            5: be.array([0.21659, 0.48038, 0.70711, 0.87706, 0.97626]),
            6: be.array([0.18375, 0.41158, 0.61700, 0.78696, 0.91138, 0.98300]),
        }
        if num_rings not in radius_dict:
&gt;           raise ValueError("Gaussian quadrature must have between 1 and 6 rings.")
E           ValueError: Gaussian quadrature must have between 1 and 6 rings.

optiland\distribution.py:315: ValueError</failure></testcase><testcase classname="tests.test_operand.TestRayOperand" name="test_opd_diff[backend=torch]" time="0.051"><failure message="ValueError: Gaussian quadrature must have between 1 and 6 rings.">self = &lt;tests.test_operand.TestRayOperand object at 0x000001478F0F4590&gt;
set_test_backend = None
hubble = &lt;optiland.samples.telescopes.HubbleTelescope object at 0x0000014797633910&gt;

    def test_opd_diff(self, set_test_backend, hubble):
        data = {
            "optic": hubble,
            "Hx": 0.0,
            "Hy": 1.0,
            "wavelength": 0.55,
            "num_rays": 3,
        }
&gt;       assert_allclose(operand.RayOperand.OPD_difference(**data), 0.0732334055041471)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_operand.py:301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optimization\operand\ray.py:372: in OPD_difference
    wf = wavefront.Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:283: in generate_points
    radius = self._get_radius(num_rings)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.GaussianQuadrature object at 0x00000147963DD4D0&gt;
num_rings = None

    def _get_radius(self, num_rings: int) -&gt; be.ndarray:
        """Get the radius values for the given number of rings.
    
        Args:
            num_rings (int): Number of rings for Gaussian quadrature.
    
        Returns:
            be.ndarray: Radius values for the given number of rings.
    
        Raises:
            ValueError: If the number of rings is not between 1 and 6.
    
        """
        radius_dict = {
            1: be.array([0.70711]),
            2: be.array([0.45970, 0.88807]),
            3: be.array([0.33571, 0.70711, 0.94196]),
            4: be.array([0.26350, 0.57446, 0.81853, 0.96466]),
            5: be.array([0.21659, 0.48038, 0.70711, 0.87706, 0.97626]),
            6: be.array([0.18375, 0.41158, 0.61700, 0.78696, 0.91138, 0.98300]),
        }
        if num_rings not in radius_dict:
&gt;           raise ValueError("Gaussian quadrature must have between 1 and 6 rings.")
E           ValueError: Gaussian quadrature must have between 1 and 6 rings.

optiland\distribution.py:315: ValueError</failure></testcase><testcase classname="tests.test_operand.TestRayOperand" name="test_opd_diff_on_axis[backend=numpy]" time="0.011"><failure message="ValueError: Gaussian quadrature must have between 1 and 6 rings.">self = &lt;tests.test_operand.TestRayOperand object at 0x000001478F0F51D0&gt;
set_test_backend = None
hubble = &lt;optiland.samples.telescopes.HubbleTelescope object at 0x0000014795CF8D50&gt;

    def test_opd_diff_on_axis(self, set_test_backend, hubble):
        data = {
            "optic": hubble,
            "Hx": 0.0,
            "Hy": 0.0,
            "wavelength": 0.55,
            "num_rays": 3,
        }
        assert_allclose(
&gt;           operand.RayOperand.OPD_difference(**data),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            0.0013295118803701674,
        )

tests\test_operand.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optimization\operand\ray.py:372: in OPD_difference
    wf = wavefront.Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:283: in generate_points
    radius = self._get_radius(num_rings)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.GaussianQuadrature object at 0x00000147943AF210&gt;
num_rings = None

    def _get_radius(self, num_rings: int) -&gt; be.ndarray:
        """Get the radius values for the given number of rings.
    
        Args:
            num_rings (int): Number of rings for Gaussian quadrature.
    
        Returns:
            be.ndarray: Radius values for the given number of rings.
    
        Raises:
            ValueError: If the number of rings is not between 1 and 6.
    
        """
        radius_dict = {
            1: be.array([0.70711]),
            2: be.array([0.45970, 0.88807]),
            3: be.array([0.33571, 0.70711, 0.94196]),
            4: be.array([0.26350, 0.57446, 0.81853, 0.96466]),
            5: be.array([0.21659, 0.48038, 0.70711, 0.87706, 0.97626]),
            6: be.array([0.18375, 0.41158, 0.61700, 0.78696, 0.91138, 0.98300]),
        }
        if num_rings not in radius_dict:
&gt;           raise ValueError("Gaussian quadrature must have between 1 and 6 rings.")
E           ValueError: Gaussian quadrature must have between 1 and 6 rings.

optiland\distribution.py:315: ValueError</failure></testcase><testcase classname="tests.test_operand.TestRayOperand" name="test_opd_diff_on_axis[backend=torch]" time="0.041"><failure message="ValueError: Gaussian quadrature must have between 1 and 6 rings.">self = &lt;tests.test_operand.TestRayOperand object at 0x000001478F0F5450&gt;
set_test_backend = None
hubble = &lt;optiland.samples.telescopes.HubbleTelescope object at 0x0000014795D33850&gt;

    def test_opd_diff_on_axis(self, set_test_backend, hubble):
        data = {
            "optic": hubble,
            "Hx": 0.0,
            "Hy": 0.0,
            "wavelength": 0.55,
            "num_rays": 3,
        }
        assert_allclose(
&gt;           operand.RayOperand.OPD_difference(**data),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            0.0013295118803701674,
        )

tests\test_operand.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optimization\operand\ray.py:372: in OPD_difference
    wf = wavefront.Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:283: in generate_points
    radius = self._get_radius(num_rings)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.GaussianQuadrature object at 0x0000014795D31650&gt;
num_rings = None

    def _get_radius(self, num_rings: int) -&gt; be.ndarray:
        """Get the radius values for the given number of rings.
    
        Args:
            num_rings (int): Number of rings for Gaussian quadrature.
    
        Returns:
            be.ndarray: Radius values for the given number of rings.
    
        Raises:
            ValueError: If the number of rings is not between 1 and 6.
    
        """
        radius_dict = {
            1: be.array([0.70711]),
            2: be.array([0.45970, 0.88807]),
            3: be.array([0.33571, 0.70711, 0.94196]),
            4: be.array([0.26350, 0.57446, 0.81853, 0.96466]),
            5: be.array([0.21659, 0.48038, 0.70711, 0.87706, 0.97626]),
            6: be.array([0.18375, 0.41158, 0.61700, 0.78696, 0.91138, 0.98300]),
        }
        if num_rings not in radius_dict:
&gt;           raise ValueError("Gaussian quadrature must have between 1 and 6 rings.")
E           ValueError: Gaussian quadrature must have between 1 and 6 rings.

optiland\distribution.py:315: ValueError</failure></testcase><testcase classname="tests.test_operand.TestRayOperand" name="test_opd_diff_new_dist[backend=numpy]" time="0.030"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_operand.TestRayOperand object at 0x000001478F0F6090&gt;
set_test_backend = None
hubble = &lt;optiland.samples.telescopes.HubbleTelescope object at 0x00000147963C1AD0&gt;

    def test_opd_diff_new_dist(self, set_test_backend, hubble):
        data = {
            "optic": hubble,
            "Hx": 0.0,
            "Hy": 1.0,
            "wavelength": 0.55,
            "num_rays": 100,
            "distribution": "hexapolar",
        }
&gt;       assert_allclose(operand.RayOperand.OPD_difference(**data), 0.2211995620762635)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_operand.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optimization\operand\ray.py:372: in OPD_difference
    wf = wavefront.Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x00000147963C0F90&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_operand.TestRayOperand" name="test_opd_diff_new_dist[backend=torch]" time="0.085"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_operand.TestRayOperand object at 0x000001478F0F6310&gt;
set_test_backend = None
hubble = &lt;optiland.samples.telescopes.HubbleTelescope object at 0x00000147964861D0&gt;

    def test_opd_diff_new_dist(self, set_test_backend, hubble):
        data = {
            "optic": hubble,
            "Hx": 0.0,
            "Hy": 1.0,
            "wavelength": 0.55,
            "num_rays": 100,
            "distribution": "hexapolar",
        }
&gt;       assert_allclose(operand.RayOperand.OPD_difference(**data), 0.2211995620762635)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_operand.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optimization\operand\ray.py:372: in OPD_difference
    wf = wavefront.Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014796484450&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_operand.TestRayOperand" name="test_clearance[backend=numpy]" time="0.050" /><testcase classname="tests.test_operand.TestRayOperand" name="test_clearance[backend=torch]" time="0.203" /><testcase classname="tests.test_operand.TestRayOperand" name="test_AOI[backend=numpy]" time="0.096" /><testcase classname="tests.test_operand.TestRayOperand" name="test_AOI[backend=torch]" time="0.232" /><testcase classname="tests.test_operand.TestLensOperand" name="test_edge_thickness_simple_biconvex[backend=numpy]" time="0.031" /><testcase classname="tests.test_operand.TestLensOperand" name="test_edge_thickness_simple_biconvex[backend=torch]" time="0.065" /><testcase classname="tests.test_operand.TestLensOperand" name="test_edge_thickness_plano_concave[backend=numpy]" time="0.036" /><testcase classname="tests.test_operand.TestLensOperand" name="test_edge_thickness_plano_concave[backend=torch]" time="0.051" /><testcase classname="tests.test_operand.TestLensOperand" name="test_edge_thickness_different_semi_apertures[backend=numpy]" time="0.027" /><testcase classname="tests.test_operand.TestLensOperand" name="test_edge_thickness_different_semi_apertures[backend=torch]" time="0.062" /><testcase classname="tests.test_operand.TestLensOperand" name="test_edge_thickness_aspheric_surface[backend=numpy]" time="0.029" /><testcase classname="tests.test_operand.TestLensOperand" name="test_edge_thickness_aspheric_surface[backend=torch]" time="0.062" /><testcase classname="tests.test_operand.TestOperand" name="test_get_value[backend=numpy]" time="0.003" /><testcase classname="tests.test_operand.TestOperand" name="test_get_value[backend=torch]" time="0.010" /><testcase classname="tests.test_operand.TestOperand" name="test_invalid_operand[backend=numpy]" time="0.004" /><testcase classname="tests.test_operand.TestOperand" name="test_invalid_operand[backend=torch]" time="0.004" /><testcase classname="tests.test_operand.TestOperand" name="test_delta[backend=numpy]" time="0.004" /><testcase classname="tests.test_operand.TestOperand" name="test_delta[backend=torch]" time="0.018" /><testcase classname="tests.test_operand.TestOperand" name="test_fun[backend=numpy]" time="0.006" /><testcase classname="tests.test_operand.TestOperand" name="test_fun[backend=torch]" time="0.026" /><testcase classname="tests.test_operand.TestOperand" name="test_reregister_operand[backend=numpy]" time="0.005" /><testcase classname="tests.test_operand.TestOperand" name="test_reregister_operand[backend=torch]" time="0.002" /><testcase classname="tests.test_operand.TestOperand" name="test_contains[backend=numpy]" time="0.002" /><testcase classname="tests.test_operand.TestOperand" name="test_contains[backend=torch]" time="0.002" /><testcase classname="tests.test_operand.TestOperand" name="test_repr[backend=numpy]" time="0.001" /><testcase classname="tests.test_operand.TestOperand" name="test_repr[backend=torch]" time="0.002" /><testcase classname="tests.test_operand.TestOperand" name="test_invalid_bounds[backend=numpy]" time="0.001" /><testcase classname="tests.test_operand.TestOperand" name="test_invalid_bounds[backend=torch]" time="0.002" /><testcase classname="tests.test_operand.TestOperand" name="test_invalid_bounds_and_target[backend=numpy]" time="0.001" /><testcase classname="tests.test_operand.TestOperand" name="test_invalid_bounds_and_target[backend=torch]" time="0.001" /><testcase classname="tests.test_operand.TestOperand" name="test_delta_ineq[backend=numpy]" time="0.008" /><testcase classname="tests.test_operand.TestOperand" name="test_delta_ineq[backend=torch]" time="0.028" /><testcase classname="tests.test_operand.TestOperand" name="test_delta_ineq_no_bounds[backend=numpy]" time="0.010" /><testcase classname="tests.test_operand.TestOperand" name="test_delta_ineq_no_bounds[backend=torch]" time="0.016" /><testcase classname="tests.test_operand.TestOperand" name="test_delta_with_bounds[backend=numpy]" time="0.009" /><testcase classname="tests.test_operand.TestOperand" name="test_delta_with_bounds[backend=torch]" time="0.029" /><testcase classname="tests.test_operand.TestOperand" name="test_invalid_delta[backend=numpy]" time="0.007" /><testcase classname="tests.test_operand.TestOperand" name="test_invalid_delta[backend=torch]" time="0.012" /><testcase classname="tests.test_operand.TestOperandManager" name="test_add[backend=numpy]" time="0.003" /><testcase classname="tests.test_operand.TestOperandManager" name="test_add[backend=torch]" time="0.003" /><testcase classname="tests.test_operand.TestOperandManager" name="test_clear[backend=numpy]" time="0.002" /><testcase classname="tests.test_operand.TestOperandManager" name="test_clear[backend=torch]" time="0.004" /><testcase classname="tests.test_operand.TestOperandManager" name="test_iter[backend=numpy]" time="0.002" /><testcase classname="tests.test_operand.TestOperandManager" name="test_iter[backend=torch]" time="0.001" /><testcase classname="tests.test_operand.TestOperandManager" name="test_getitem[backend=numpy]" time="0.003" /><testcase classname="tests.test_operand.TestOperandManager" name="test_getitem[backend=torch]" time="0.003" /><testcase classname="tests.test_operand.TestOperandManager" name="test_setitem[backend=numpy]" time="0.002" /><testcase classname="tests.test_operand.TestOperandManager" name="test_setitem[backend=torch]" time="0.002" /><testcase classname="tests.test_operand.TestOperandManager" name="test_len[backend=numpy]" time="0.002" /><testcase classname="tests.test_operand.TestOperandManager" name="test_len[backend=torch]" time="0.003" /><testcase classname="tests.test_operand.TestOperandManager" name="test_getitem_error[backend=numpy]" time="0.002" /><testcase classname="tests.test_operand.TestOperandManager" name="test_getitem_error[backend=torch]" time="0.002" /><testcase classname="tests.test_operand.TestOperandManager" name="test_setitem_invalid_type[backend=numpy]" time="0.005" /><testcase classname="tests.test_operand.TestOperandManager" name="test_setitem_invalid_type[backend=torch]" time="0.003" /><testcase classname="tests.test_operand.TestOperandManager" name="test_delitem[backend=numpy]" time="0.010" /><testcase classname="tests.test_operand.TestOperandManager" name="test_delitem[backend=torch]" time="0.004" /><testcase classname="tests.test_optic.TestOptic" name="test_initialization[backend=numpy]" time="0.002" /><testcase classname="tests.test_optic.TestOptic" name="test_initialization[backend=torch]" time="0.001" /><testcase classname="tests.test_optic.TestOptic" name="test_add_surface[backend=numpy]" time="0.018" /><testcase classname="tests.test_optic.TestOptic" name="test_add_surface[backend=torch]" time="0.026" /><testcase classname="tests.test_optic.TestOptic" name="test_add_field[backend=numpy]" time="0.002" /><testcase classname="tests.test_optic.TestOptic" name="test_add_field[backend=torch]" time="0.003" /><testcase classname="tests.test_optic.TestOptic" name="test_add_wavelength[backend=numpy]" time="0.002" /><testcase classname="tests.test_optic.TestOptic" name="test_add_wavelength[backend=torch]" time="0.005" /><testcase classname="tests.test_optic.TestOptic" name="test_set_aperture[backend=numpy]" time="0.002" /><testcase classname="tests.test_optic.TestOptic" name="test_set_aperture[backend=torch]" time="0.001" /><testcase classname="tests.test_optic.TestOptic" name="test_set_field_type[backend=numpy]" time="0.002" /><testcase classname="tests.test_optic.TestOptic" name="test_set_field_type[backend=torch]" time="0.002" /><testcase classname="tests.test_optic.TestOptic" name="test_set_comment[backend=numpy]" time="0.063" /><testcase classname="tests.test_optic.TestOptic" name="test_set_comment[backend=torch]" time="0.048" /><testcase classname="tests.test_optic.TestOptic" name="test_set_radius[backend=numpy]" time="0.024" /><testcase classname="tests.test_optic.TestOptic" name="test_set_radius[backend=torch]" time="0.023" /><testcase classname="tests.test_optic.TestOptic" name="test_set_conic[backend=numpy]" time="0.029" /><testcase classname="tests.test_optic.TestOptic" name="test_set_conic[backend=torch]" time="0.022" /><testcase classname="tests.test_optic.TestOptic" name="test_set_thickness[backend=numpy]" time="0.037" /><testcase classname="tests.test_optic.TestOptic" name="test_set_thickness[backend=torch]" time="0.039" /><testcase classname="tests.test_optic.TestOptic" name="test_set_index[backend=numpy]" time="0.003" /><testcase classname="tests.test_optic.TestOptic" name="test_set_index[backend=torch]" time="0.004" /><testcase classname="tests.test_optic.TestOptic" name="test_set_material[backend=numpy]" time="0.031" /><testcase classname="tests.test_optic.TestOptic" name="test_set_material[backend=torch]" time="0.031" /><testcase classname="tests.test_optic.TestOptic" name="test_set_asphere_coeff[backend=numpy]" time="0.003" /><testcase classname="tests.test_optic.TestOptic" name="test_set_asphere_coeff[backend=torch]" time="0.004" /><testcase classname="tests.test_optic.TestOptic" name="test_set_polarization[backend=numpy]" time="0.003" /><testcase classname="tests.test_optic.TestOptic" name="test_set_polarization[backend=torch]" time="0.002" /><testcase classname="tests.test_optic.TestOptic" name="test_optic_default_apodization[backend=numpy]" time="0.002" /><testcase classname="tests.test_optic.TestOptic" name="test_optic_default_apodization[backend=torch]" time="0.002" /><testcase classname="tests.test_optic.TestOptic" name="test_optic_set_apodization[backend=numpy]" time="0.003" /><testcase classname="tests.test_optic.TestOptic" name="test_optic_set_apodization[backend=torch]" time="0.003" /><testcase classname="tests.test_optic.TestOptic" name="test_set_invalid_polarization[backend=numpy]" time="0.003" /><testcase classname="tests.test_optic.TestOptic" name="test_set_invalid_polarization[backend=torch]" time="0.004" /><testcase classname="tests.test_optic.TestOptic" name="test_set_pickup[backend=numpy]" time="0.002" /><testcase classname="tests.test_optic.TestOptic" name="test_set_pickup[backend=torch]" time="0.005" /><testcase classname="tests.test_optic.TestOptic" name="test_clear_pickups[backend=numpy]" time="0.004" /><testcase classname="tests.test_optic.TestOptic" name="test_clear_pickups[backend=torch]" time="0.005" /><testcase classname="tests.test_optic.TestOptic" name="test_set_solve[backend=numpy]" time="0.155" /><testcase classname="tests.test_optic.TestOptic" name="test_set_solve[backend=torch]" time="0.138" /><testcase classname="tests.test_optic.TestOptic" name="test_clear_solves[backend=numpy]" time="0.100" /><testcase classname="tests.test_optic.TestOptic" name="test_clear_solves[backend=torch]" time="0.132" /><testcase classname="tests.test_optic.TestOptic" name="test_scale_system[backend=numpy]" time="0.001" /><testcase classname="tests.test_optic.TestOptic" name="test_scale_system[backend=torch]" time="0.005" /><testcase classname="tests.test_optic.TestOptic" name="test_reset[backend=numpy]" time="0.004" /><testcase classname="tests.test_optic.TestOptic" name="test_reset[backend=torch]" time="0.006" /><testcase classname="tests.test_optic.TestOptic" name="test_n[backend=numpy]" time="0.005" /><testcase classname="tests.test_optic.TestOptic" name="test_n[backend=torch]" time="0.003" /><testcase classname="tests.test_optic.TestOptic" name="test_update_paraxial[backend=numpy]" time="0.197" /><testcase classname="tests.test_optic.TestOptic" name="test_update_paraxial[backend=torch]" time="0.174" /><testcase classname="tests.test_optic.TestOptic" name="test_update[backend=numpy]" time="0.135" /><testcase classname="tests.test_optic.TestOptic" name="test_update[backend=torch]" time="0.133" /><testcase classname="tests.test_optic.TestOptic" name="test_image_solve[backend=numpy]" time="0.144" /><testcase classname="tests.test_optic.TestOptic" name="test_image_solve[backend=torch]" time="0.135" /><testcase classname="tests.test_optic.TestOptic" name="test_trace[backend=numpy]" time="0.521" /><testcase classname="tests.test_optic.TestOptic" name="test_trace[backend=torch]" time="0.757" /><testcase classname="tests.test_optic.TestOptic" name="test_trace_generic[backend=numpy]" time="0.163" /><testcase classname="tests.test_optic.TestOptic" name="test_trace_generic[backend=torch]" time="0.209" /><testcase classname="tests.test_optic.TestOptic" name="test_trace_invalid_field[backend=numpy]" time="0.486"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">self = &lt;tests.test_optic.TestOptic object at 0x000001478F16BE50&gt;
set_test_backend = None

    def test_trace_invalid_field(self, set_test_backend):
        lens = HeliarLens()
&gt;       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE &lt;class 'ValueError'&gt;

tests\test_optic.py:360: Failed</failure></testcase><testcase classname="tests.test_optic.TestOptic" name="test_trace_invalid_field[backend=torch]" time="0.665"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">self = &lt;tests.test_optic.TestOptic object at 0x000001478F170110&gt;
set_test_backend = None

    def test_trace_invalid_field(self, set_test_backend):
        lens = HeliarLens()
&gt;       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE &lt;class 'ValueError'&gt;

tests\test_optic.py:360: Failed</failure></testcase><testcase classname="tests.test_optic.TestOptic" name="test_trace_generic_invalid_field[backend=numpy]" time="0.105" /><testcase classname="tests.test_optic.TestOptic" name="test_trace_generic_invalid_field[backend=torch]" time="0.124" /><testcase classname="tests.test_optic.TestOptic" name="test_trace_generic_invalid_pupil[backend=numpy]" time="0.109" /><testcase classname="tests.test_optic.TestOptic" name="test_trace_generic_invalid_pupil[backend=torch]" time="0.111" /><testcase classname="tests.test_optic.TestOptic" name="test_trace_polarized[backend=numpy]" time="0.826" /><testcase classname="tests.test_optic.TestOptic" name="test_trace_polarized[backend=torch]" time="0.990" /><testcase classname="tests.test_optic.TestOptic" name="test_object_property[backend=numpy]" time="0.001" /><testcase classname="tests.test_optic.TestOptic" name="test_object_property[backend=torch]" time="0.001" /><testcase classname="tests.test_optic.TestOptic" name="test_image_surface_property[backend=numpy]" time="0.002" /><testcase classname="tests.test_optic.TestOptic" name="test_image_surface_property[backend=torch]" time="0.002" /><testcase classname="tests.test_optic.TestOptic" name="test_total_track_property[backend=numpy]" time="0.116" /><testcase classname="tests.test_optic.TestOptic" name="test_total_track_property[backend=torch]" time="0.168" /><testcase classname="tests.test_optic.TestOptic" name="test_total_track_error[backend=numpy]" time="0.117" /><testcase classname="tests.test_optic.TestOptic" name="test_total_track_error[backend=torch]" time="0.115" /><testcase classname="tests.test_optic.TestOptic" name="test_polarization_state_property[backend=numpy]" time="0.105" /><testcase classname="tests.test_optic.TestOptic" name="test_polarization_state_property[backend=torch]" time="0.128" /><testcase classname="tests.test_optic.TestOptic" name="test_polarization_state_error[backend=numpy]" time="0.107" /><testcase classname="tests.test_optic.TestOptic" name="test_polarization_state_error[backend=torch]" time="0.119" /><testcase classname="tests.test_optic.TestOptic" name="test_to_dict[backend=numpy]" time="0.102" /><testcase classname="tests.test_optic.TestOptic" name="test_to_dict[backend=torch]" time="0.113" /><testcase classname="tests.test_optic.TestOptic" name="test_from_dict[backend=numpy]" time="0.482" /><testcase classname="tests.test_optic.TestOptic" name="test_from_dict[backend=torch]" time="0.482" /><testcase classname="tests.test_optic.TestOptic" name="test_invalid_field_type[backend=numpy]" time="0.001" /><testcase classname="tests.test_optic.TestOptic" name="test_invalid_field_type[backend=torch]" time="0.001" /><testcase classname="tests.test_optic.TestOptic" name="test_no_stop[backend=numpy]" time="0.002" /><testcase classname="tests.test_optic.TestOptic" name="test_no_stop[backend=torch]" time="0.001" /><testcase classname="tests.test_optic.TestOptic" name="test_add_infinite_object" time="0.054" /><testcase classname="tests.test_optic.TestOptic" name="test_add_finite_object" time="0.062" /><testcase classname="tests.test_optic.TestOptic" name="test_invalid_coordinate_system[backend=numpy]" time="0.003" /><testcase classname="tests.test_optic.TestOptic" name="test_invalid_coordinate_system[backend=torch]" time="0.002" /><testcase classname="tests.test_optic.TestOptic" name="test_flip_optic[backend=numpy]" time="0.102" /><testcase classname="tests.test_optic.TestOptic" name="test_flip_optic[backend=torch]" time="0.110" /><testcase classname="tests.test_optic.TestOptic" name="test_invalid_flip[backend=numpy]" time="0.001" /><testcase classname="tests.test_optic.TestOptic" name="test_invalid_flip[backend=torch]" time="0.003" /><testcase classname="tests.test_optic.TestOptic" name="test_flip_solves_pickups[backend=numpy]" time="0.051" /><testcase classname="tests.test_optic.TestOptic" name="test_flip_solves_pickups[backend=torch]" time="0.111" /><testcase classname="tests.test_optic.TestOptic" name="test_plot_surface_sag[backend=numpy]" time="0.028" /><testcase classname="tests.test_optic.TestOptic" name="test_plot_surface_sag[backend=torch]" time="0.042" /><testcase classname="tests.test_optimization.TestOptimizationProblem" name="test_add_operand" time="0.208" /><testcase classname="tests.test_optimization.TestOptimizationProblem" name="test_add_variable" time="0.205" /><testcase classname="tests.test_optimization.TestOptimizationProblem" name="test_clear_operands" time="0.186" /><testcase classname="tests.test_optimization.TestOptimizationProblem" name="test_clear_variables" time="0.169" /><testcase classname="tests.test_optimization.TestOptimizationProblem" name="test_fun_array" time="0.207" /><testcase classname="tests.test_optimization.TestOptimizationProblem" name="test_sum_squared" time="0.219" /><testcase classname="tests.test_optimization.TestOptimizationProblem" name="test_rss" time="0.056" /><testcase classname="tests.test_optimization.TestOptimizationProblem" name="test_update_optics" time="0.052" /><testcase classname="tests.test_optimization.TestOptimizationProblem" name="test_operand_info" time="0.109" /><testcase classname="tests.test_optimization.TestOptimizationProblem" name="test_variable_info" time="0.175" /><testcase classname="tests.test_optimization.TestOptimizationProblem" name="test_merit_info" time="0.200" /><testcase classname="tests.test_optimization.TestOptimizationProblem" name="test_info" time="0.066" /><testcase classname="tests.test_optimization.TestOptimizerGeneric" name="test_optimize" time="0.214" /><testcase classname="tests.test_optimization.TestOptimizerGeneric" name="test_undo" time="0.207" /><testcase classname="tests.test_optimization.TestOptimizerGeneric" name="test_fun_nan_rss" time="1.073" /><testcase classname="tests.test_optimization.TestLeastSquares" name="test_optimize" time="0.252" /><testcase classname="tests.test_optimization.TestLeastSquares" name="test_no_bounds" time="0.200" /><testcase classname="tests.test_optimization.TestLeastSquares" name="test_verbose" time="0.226" /><testcase classname="tests.test_optimization.TestLeastSquares" name="test_method_trf_with_bounds" time="0.183" /><testcase classname="tests.test_optimization.TestLeastSquares" name="test_method_dogbox_with_bounds" time="0.182" /><testcase classname="tests.test_optimization.TestLeastSquares" name="test_method_lm_with_bounds_warning" time="0.204" /><testcase classname="tests.test_optimization.TestLeastSquares" name="test_unknown_method_choice_warning" time="0.212" /><testcase classname="tests.test_optimization.TestLeastSquaresErrorHandling" name="test_nan_residual_handling" time="0.184" /><testcase classname="tests.test_optimization.TestLeastSquaresErrorHandling" name="test_exception_in_residual_handling" time="0.176" /><testcase classname="tests.test_optimization.TestLeastSquaresErrorHandling" name="test_optimize_no_operands" time="0.169" /><testcase classname="tests.test_optimization.TestDualAnnealing" name="test_optimize" time="0.238" /><testcase classname="tests.test_optimization.TestDualAnnealing" name="test_raise_error_no_bounds" time="0.199" /><testcase classname="tests.test_optimization.TestDifferentialEvolution" name="test_optimize" time="0.365" /><testcase classname="tests.test_optimization.TestDifferentialEvolution" name="test_raise_error_no_bounds" time="0.201" /><testcase classname="tests.test_optimization.TestDifferentialEvolution" name="test_workers" time="0.396" /><testcase classname="tests.test_optimization.TestSHGO" name="test_optimize" time="13.111" /><testcase classname="tests.test_optimization.TestSHGO" name="test_raise_error_no_bounds" time="0.155" /><testcase classname="tests.test_optimization.TestBasinHopping" name="test_optimize" time="2.063" /><testcase classname="tests.test_optimization.TestBasinHopping" name="test_raise_error_with_bounds" time="0.177" /><testcase classname="tests.test_optimization.TestGlassExpert" name="test_optimize" time="0.401" /><testcase classname="tests.test_optimization.TestGlassExpert" name="test_optimize_fail_num_neighbours" time="0.114" /><testcase classname="tests.test_optimization.TestGlassExpert" name="test_vprint_verbose_true" time="0.083" /><testcase classname="tests.test_optimization.TestGlassExpert" name="test_vprint_verbose_false" time="0.057" /><testcase classname="tests.test_optimization.TestOptimizerWithBounds" name="test_optimize_with_reciprocal_scaler_and_min_bounds" time="0.184" /><testcase classname="tests.test_optimization.TestOptimizerWithBounds" name="test_optimize_with_reciprocal_scaler_and_max_bounds" time="0.221" /><testcase classname="tests.test_optimization.TestOptimizerWithBounds" name="test_optimize_with_reciprocal_scaler_and_crossing_bounds" time="0.159" /><testcase classname="tests.test_optimization_scaling.TestIdentityScaler" name="test_scale[backend=numpy]" time="0.001" /><testcase classname="tests.test_optimization_scaling.TestIdentityScaler" name="test_scale[backend=torch]" time="0.001" /><testcase classname="tests.test_optimization_scaling.TestIdentityScaler" name="test_inverse_scale[backend=numpy]" time="0.001" /><testcase classname="tests.test_optimization_scaling.TestIdentityScaler" name="test_inverse_scale[backend=torch]" time="0.001" /><testcase classname="tests.test_optimization_scaling.TestLinearScaler" name="test_scale[backend=numpy]" time="0.002" /><testcase classname="tests.test_optimization_scaling.TestLinearScaler" name="test_scale[backend=torch]" time="0.001" /><testcase classname="tests.test_optimization_scaling.TestLinearScaler" name="test_inverse_scale[backend=numpy]" time="0.002" /><testcase classname="tests.test_optimization_scaling.TestLinearScaler" name="test_inverse_scale[backend=torch]" time="0.002" /><testcase classname="tests.test_optimization_scaling.TestReciprocalScaler" name="test_scale[backend=numpy]" time="0.001" /><testcase classname="tests.test_optimization_scaling.TestReciprocalScaler" name="test_scale[backend=torch]" time="0.002" /><testcase classname="tests.test_optimization_scaling.TestReciprocalScaler" name="test_inverse_scale[backend=numpy]" time="0.002" /><testcase classname="tests.test_optimization_scaling.TestReciprocalScaler" name="test_inverse_scale[backend=torch]" time="0.002" /><testcase classname="tests.test_optimization_scaling.TestReciprocalScaler" name="test_scale_zero[backend=numpy]" time="0.001" /><testcase classname="tests.test_optimization_scaling.TestReciprocalScaler" name="test_scale_zero[backend=torch]" time="0.001" /><testcase classname="tests.test_optimization_scaling.TestReciprocalScaler" name="test_inverse_scale_zero[backend=numpy]" time="0.001" /><testcase classname="tests.test_optimization_scaling.TestReciprocalScaler" name="test_inverse_scale_zero[backend=torch]" time="0.001" /><testcase classname="tests.test_optimization_scaling.TestPowerScaler" name="test_scale[backend=numpy]" time="0.002" /><testcase classname="tests.test_optimization_scaling.TestPowerScaler" name="test_scale[backend=torch]" time="0.002" /><testcase classname="tests.test_optimization_scaling.TestPowerScaler" name="test_inverse_scale[backend=numpy]" time="0.002" /><testcase classname="tests.test_optimization_scaling.TestPowerScaler" name="test_inverse_scale[backend=torch]" time="0.003" /><testcase classname="tests.test_optimization_scaling.TestLogScaler" name="test_scale[backend=numpy]" time="0.002" /><testcase classname="tests.test_optimization_scaling.TestLogScaler" name="test_scale[backend=torch]" time="0.007" /><testcase classname="tests.test_optimization_scaling.TestLogScaler" name="test_inverse_scale[backend=numpy]" time="0.023" /><testcase classname="tests.test_optimization_scaling.TestLogScaler" name="test_inverse_scale[backend=torch]" time="0.002" /><testcase classname="tests.test_paraxial" name="test_paraxial_init[backend=numpy]" time="0.001" /><testcase classname="tests.test_paraxial" name="test_paraxial_init[backend=torch]" time="0.001" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values0]" time="0.139" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values1]" time="0.003" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values2]" time="0.005" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values3]" time="0.005" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values4]" time="0.032" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values5]" time="0.033" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values6]" time="0.072" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values7]" time="0.063" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values8]" time="0.081" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values9]" time="0.084" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values10]" time="0.152" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values11]" time="0.129" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values12]" time="0.264" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values13]" time="0.095" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values14]" time="0.118" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values15]" time="0.113" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values16]" time="0.142" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values17]" time="0.142" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values18]" time="0.137" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=numpy-optic_and_values19]" time="0.004" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values0]" time="0.126" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values1]" time="0.013" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values2]" time="0.016" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values3]" time="0.014" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values4]" time="0.039" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values5]" time="0.045" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values6]" time="0.073" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values7]" time="0.083" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values8]" time="0.115" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values9]" time="0.078" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values10]" time="0.176" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values11]" time="0.189" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values12]" time="0.287" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values13]" time="0.121" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values14]" time="0.130" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values15]" time="0.114" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values16]" time="0.225" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values17]" time="0.183" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values18]" time="0.178" /><testcase classname="tests.test_paraxial" name="test_calculate_f1[backend=torch-optic_and_values19]" time="0.011" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values0]" time="0.116" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values1]" time="0.004" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values2]" time="0.003" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values3]" time="0.026" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values4]" time="0.049" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values5]" time="0.032" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values6]" time="0.057" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values7]" time="0.053" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values8]" time="0.086" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values9]" time="0.090" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values10]" time="0.143" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values11]" time="0.155" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values12]" time="0.346" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values13]" time="0.116" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values14]" time="0.099" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values15]" time="0.099" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values16]" time="0.144" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values17]" time="0.111" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values18]" time="0.161" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=numpy-optic_and_values19]" time="0.003" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values0]" time="0.140" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values1]" time="0.014" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values2]" time="0.021" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values3]" time="0.017" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values4]" time="0.048" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values5]" time="0.040" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values6]" time="0.082" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values7]" time="0.093" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values8]" time="0.092" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values9]" time="0.091" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values10]" time="0.162" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values11]" time="0.170" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values12]" time="0.304" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values13]" time="0.091" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values14]" time="0.138" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values15]" time="0.115" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values16]" time="0.225" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values17]" time="0.199" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values18]" time="0.191" /><testcase classname="tests.test_paraxial" name="test_calculate_f2[backend=torch-optic_and_values19]" time="0.024" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values0]" time="0.119" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values1]" time="0.003" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values2]" time="0.004" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values3]" time="0.007" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values4]" time="0.029" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values5]" time="0.030" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values6]" time="0.072" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values7]" time="0.068" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values8]" time="0.079" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values9]" time="0.082" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values10]" time="0.157" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values11]" time="0.135" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values12]" time="0.262" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values13]" time="0.112" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values14]" time="0.089" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values15]" time="0.122" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values16]" time="0.144" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values17]" time="0.119" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values18]" time="0.135" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=numpy-optic_and_values19]" time="0.003" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values0]" time="0.135" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values1]" time="0.008" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values2]" time="0.014" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values3]" time="0.012" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values4]" time="0.045" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values5]" time="0.033" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values6]" time="0.078" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values7]" time="0.075" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values8]" time="0.086" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values9]" time="0.087" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values10]" time="0.171" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values11]" time="0.155" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values12]" time="0.339" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values13]" time="0.126" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values14]" time="0.155" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values15]" time="0.113" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values16]" time="0.223" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values17]" time="0.199" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values18]" time="0.275" /><testcase classname="tests.test_paraxial" name="test_calculate_F1[backend=torch-optic_and_values19]" time="0.016" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values0]" time="0.149" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values1]" time="0.006" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values2]" time="0.005" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values3]" time="0.007" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values4]" time="0.033" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values5]" time="0.037" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values6]" time="0.081" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values7]" time="0.063" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values8]" time="0.074" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values9]" time="0.086" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values10]" time="0.160" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values11]" time="0.152" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values12]" time="0.262" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values13]" time="0.091" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values14]" time="0.129" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values15]" time="0.106" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values16]" time="0.157" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values17]" time="0.119" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values18]" time="0.147" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=numpy-optic_and_values19]" time="0.005" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values0]" time="0.125" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values1]" time="0.008" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values2]" time="0.012" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values3]" time="0.023" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values4]" time="0.039" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values5]" time="0.044" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values6]" time="0.078" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values7]" time="0.080" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values8]" time="0.114" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values9]" time="0.096" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values10]" time="0.183" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values11]" time="0.161" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values12]" time="0.418" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values13]" time="0.141" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values14]" time="0.123" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values15]" time="0.155" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values16]" time="0.302" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values17]" time="0.231" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values18]" time="0.242" /><testcase classname="tests.test_paraxial" name="test_calculate_F2[backend=torch-optic_and_values19]" time="0.017" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values0]" time="0.170" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values1]" time="0.005" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values2]" time="0.008" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values3]" time="0.011" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values4]" time="0.036" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values5]" time="0.032" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values6]" time="0.079" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values7]" time="0.032" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values8]" time="0.074" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values9]" time="0.085" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values10]" time="0.150" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values11]" time="0.160" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values12]" time="0.282" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values13]" time="0.137" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values14]" time="0.137" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values15]" time="0.138" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values16]" time="0.206" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values17]" time="0.163" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values18]" time="0.196" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=numpy-optic_and_values19]" time="0.006" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values0]" time="0.184" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values1]" time="0.023" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values2]" time="0.027" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values3]" time="0.029" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values4]" time="0.051" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values5]" time="0.056" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values6]" time="0.111" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values7]" time="0.092" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values8]" time="0.128" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values9]" time="0.145" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values10]" time="0.194" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values11]" time="0.188" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values12]" time="0.353" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values13]" time="0.130" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values14]" time="0.133" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values15]" time="0.110" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values16]" time="0.269" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values17]" time="0.206" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values18]" time="0.219" /><testcase classname="tests.test_paraxial" name="test_calculate_P1[backend=torch-optic_and_values19]" time="0.015" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values0]" time="0.106" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values1]" time="0.005" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values2]" time="0.006" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values3]" time="0.012" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values4]" time="0.035" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values5]" time="0.033" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values6]" time="0.054" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values7]" time="0.060" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values8]" time="0.086" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values9]" time="0.102" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values10]" time="0.156" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values11]" time="0.169" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values12]" time="0.281" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values13]" time="0.091" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values14]" time="0.113" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values15]" time="0.115" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values16]" time="0.161" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values17]" time="0.127" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values18]" time="0.141" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=numpy-optic_and_values19]" time="0.008" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values0]" time="0.148" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values1]" time="0.016" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values2]" time="0.028" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values3]" time="0.034" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values4]" time="0.044" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values5]" time="0.034" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values6]" time="0.087" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values7]" time="0.069" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values8]" time="0.106" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values9]" time="0.088" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values10]" time="0.172" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values11]" time="0.165" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values12]" time="0.278" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values13]" time="0.118" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values14]" time="0.144" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values15]" time="0.118" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values16]" time="0.256" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values17]" time="0.179" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values18]" time="0.208" /><testcase classname="tests.test_paraxial" name="test_calculate_P2[backend=torch-optic_and_values19]" time="0.017" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values0]" time="0.137" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values1]" time="0.007" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values2]" time="0.007" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values3]" time="0.017" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values4]" time="0.051" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values5]" time="0.033" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values6]" time="0.050" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values7]" time="0.070" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values8]" time="0.098" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values9]" time="0.107" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values10]" time="0.150" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values11]" time="0.129" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values12]" time="0.240" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values13]" time="0.166" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values14]" time="0.240" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values15]" time="0.143" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values16]" time="0.251" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values17]" time="0.152" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values18]" time="0.238" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=numpy-optic_and_values19]" time="0.007" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values0]" time="0.170" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values1]" time="0.021" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values2]" time="0.026" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values3]" time="0.027" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values4]" time="0.057" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values5]" time="0.050" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values6]" time="0.104" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values7]" time="0.073" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values8]" time="0.101" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values9]" time="0.113" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values10]" time="0.213" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values11]" time="0.179" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values12]" time="0.334" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values13]" time="0.119" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values14]" time="0.141" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values15]" time="0.121" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values16]" time="0.252" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values17]" time="0.242" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values18]" time="0.294" /><testcase classname="tests.test_paraxial" name="test_calculate_P1anti[backend=torch-optic_and_values19]" time="0.029" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values0]" time="0.155" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values1]" time="0.006" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values2]" time="0.011" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values3]" time="0.010" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values4]" time="0.036" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values5]" time="0.025" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values6]" time="0.073" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values7]" time="0.076" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values8]" time="0.109" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values9]" time="0.082" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values10]" time="0.195" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values11]" time="0.134" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values12]" time="0.312" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values13]" time="0.095" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values14]" time="0.134" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values15]" time="0.101" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values16]" time="0.147" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values17]" time="0.139" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values18]" time="0.168" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=numpy-optic_and_values19]" time="0.006" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values0]" time="0.161" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values1]" time="0.030" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values2]" time="0.031" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values3]" time="0.041" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values4]" time="0.057" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values5]" time="0.054" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values6]" time="0.088" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values7]" time="0.101" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values8]" time="0.126" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values9]" time="0.138" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values10]" time="0.260" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values11]" time="0.235" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values12]" time="0.384" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values13]" time="0.163" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values14]" time="0.156" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values15]" time="0.149" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values16]" time="0.261" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values17]" time="0.187" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values18]" time="0.217" /><testcase classname="tests.test_paraxial" name="test_calculate_P2anti[backend=torch-optic_and_values19]" time="0.025" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values0]" time="0.108" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values1]" time="0.005" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values2]" time="0.007" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values3]" time="0.011" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values4]" time="0.027" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values5]" time="0.018" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values6]" time="0.066" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values7]" time="0.062" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values8]" time="0.080" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values9]" time="0.074" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values10]" time="0.136" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values11]" time="0.184" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values12]" time="0.401" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values13]" time="0.137" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values14]" time="0.085" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values15]" time="0.107" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values16]" time="0.146" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values17]" time="0.114" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values18]" time="0.122" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=numpy-optic_and_values19]" time="0.005" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values0]" time="0.149" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values1]" time="0.016" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values2]" time="0.021" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values3]" time="0.044" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values4]" time="0.055" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values5]" time="0.044" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values6]" time="0.100" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values7]" time="0.104" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values8]" time="0.123" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values9]" time="0.101" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values10]" time="0.202" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values11]" time="0.194" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values12]" time="0.337" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values13]" time="0.172" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values14]" time="0.142" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values15]" time="0.144" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values16]" time="0.333" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values17]" time="0.167" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values18]" time="0.219" /><testcase classname="tests.test_paraxial" name="test_calculate_N1[backend=torch-optic_and_values19]" time="0.018" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values0]" time="0.115" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values1]" time="0.004" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values2]" time="0.006" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values3]" time="0.016" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values4]" time="0.021" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values5]" time="0.028" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values6]" time="0.054" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values7]" time="0.062" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values8]" time="0.085" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values9]" time="0.075" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values10]" time="0.129" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values11]" time="0.143" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values12]" time="0.284" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values13]" time="0.106" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values14]" time="0.123" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values15]" time="0.113" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values16]" time="0.138" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values17]" time="0.138" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values18]" time="0.153" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=numpy-optic_and_values19]" time="0.006" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values0]" time="0.134" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values1]" time="0.019" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values2]" time="0.036" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values3]" time="0.028" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values4]" time="0.041" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values5]" time="0.042" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values6]" time="0.092" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values7]" time="0.077" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values8]" time="0.101" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values9]" time="0.100" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values10]" time="0.202" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values11]" time="0.175" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values12]" time="0.305" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values13]" time="0.117" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values14]" time="0.146" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values15]" time="0.131" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values16]" time="0.239" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values17]" time="0.197" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values18]" time="0.202" /><testcase classname="tests.test_paraxial" name="test_calculate_N2[backend=torch-optic_and_values19]" time="0.015" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values0]" time="0.105" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values1]" time="0.003" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values2]" time="0.004" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values3]" time="0.007" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values4]" time="0.044" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values5]" time="0.027" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values6]" time="0.057" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values7]" time="0.059" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values8]" time="0.104" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values9]" time="0.068" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values10]" time="0.164" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values11]" time="0.147" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values12]" time="0.284" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values13]" time="0.110" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values14]" time="0.126" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values15]" time="0.118" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values16]" time="0.129" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values17]" time="0.100" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values18]" time="0.127" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=numpy-optic_and_values19]" time="0.006" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values0]" time="0.124" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values1]" time="0.023" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values2]" time="0.021" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values3]" time="0.017" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values4]" time="0.029" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values5]" time="0.030" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values6]" time="0.066" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values7]" time="0.062" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values8]" time="0.079" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values9]" time="0.091" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values10]" time="0.186" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values11]" time="0.173" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values12]" time="0.393" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values13]" time="0.101" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values14]" time="0.130" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values15]" time="0.113" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values16]" time="0.208" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values17]" time="0.158" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values18]" time="0.180" /><testcase classname="tests.test_paraxial" name="test_calculate_EPL[backend=torch-optic_and_values19]" time="0.008" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values0]" time="0.102" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values1]" time="0.002" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values2]" time="0.005" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values3]" time="0.005" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values4]" time="0.031" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values5]" time="0.023" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values6]" time="0.058" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values7]" time="0.054" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values8]" time="0.081" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values9]" time="0.078" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values10]" time="0.137" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values11]" time="0.131" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values12]" time="0.268" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values13]" time="0.105" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values14]" time="0.114" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values15]" time="0.110" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values16]" time="0.189" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values17]" time="0.135" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values18]" time="0.135" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=numpy-optic_and_values19]" time="0.004" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values0]" time="0.144" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values1]" time="0.006" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values2]" time="0.032" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values3]" time="0.021" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values4]" time="0.033" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values5]" time="0.029" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values6]" time="0.075" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values7]" time="0.069" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values8]" time="0.081" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values9]" time="0.073" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values10]" time="0.170" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values11]" time="0.116" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values12]" time="0.296" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values13]" time="0.134" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values14]" time="0.256" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values15]" time="0.125" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values16]" time="0.255" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values17]" time="0.216" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values18]" time="0.227" /><testcase classname="tests.test_paraxial" name="test_calculate_EPD[backend=torch-optic_and_values19]" time="0.010" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values0]" time="0.134" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values1]" time="0.005" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values2]" time="0.006" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values3]" time="0.009" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values4]" time="0.023" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values5]" time="0.042" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values6]" time="0.066" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values7]" time="0.064" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values8]" time="0.088" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values9]" time="0.083" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values10]" time="0.155" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values11]" time="0.168" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values12]" time="0.305" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values13]" time="0.078" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values14]" time="0.101" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values15]" time="0.068" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values16]" time="0.135" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values17]" time="0.128" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values18]" time="0.124" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=numpy-optic_and_values19]" time="0.004" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values0]" time="0.149" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values1]" time="0.012" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values2]" time="0.015" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values3]" time="0.010" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values4]" time="0.018" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values5]" time="0.021" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values6]" time="0.058" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values7]" time="0.049" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values8]" time="0.052" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values9]" time="0.073" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values10]" time="0.138" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values11]" time="0.129" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values12]" time="0.250" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values13]" time="0.097" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values14]" time="0.109" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values15]" time="0.102" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values16]" time="0.196" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values17]" time="0.170" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values18]" time="0.140" /><testcase classname="tests.test_paraxial" name="test_calculate_XPL[backend=torch-optic_and_values19]" time="0.002" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values0]" time="0.038" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values1]" time="0.001" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values2]" time="0.002" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values3]" time="0.007" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values4]" time="0.008" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values5]" time="0.013" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values6]" time="0.016" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values7]" time="0.016" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values8]" time="0.026" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values9]" time="0.027" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values10]" time="0.046" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values11]" time="0.056" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values12]" time="0.096" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values13]" time="0.028" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values14]" time="0.036" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values15]" time="0.035" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values16]" time="0.057" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values17]" time="0.038" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values18]" time="0.045" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=numpy-optic_and_values19]" time="0.001" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values0]" time="0.043" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values1]" time="0.003" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values2]" time="0.010" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values3]" time="0.007" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values4]" time="0.013" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values5]" time="0.013" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values6]" time="0.027" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values7]" time="0.026" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values8]" time="0.034" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values9]" time="0.065" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values10]" time="0.074" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values11]" time="0.067" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values12]" time="0.124" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values13]" time="0.046" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values14]" time="0.049" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values15]" time="0.047" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values16]" time="0.080" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values17]" time="0.067" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values18]" time="0.077" /><testcase classname="tests.test_paraxial" name="test_calculate_XPD[backend=torch-optic_and_values19]" time="0.007" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values0]" time="0.050" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values1]" time="0.001" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values2]" time="0.001" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values3]" time="0.002" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values4]" time="0.010" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values5]" time="0.016" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values6]" time="0.029" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values7]" time="0.022" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values8]" time="0.035" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values9]" time="0.034" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values10]" time="0.059" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values11]" time="0.057" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values12]" time="0.108" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values13]" time="0.039" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values14]" time="0.044" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values15]" time="0.038" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values16]" time="0.058" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values17]" time="0.045" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values18]" time="0.053" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=numpy-optic_and_values19]" time="0.002" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values0]" time="0.052" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values1]" time="0.003" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values2]" time="0.003" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values3]" time="0.002" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values4]" time="0.012" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values5]" time="0.013" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values6]" time="0.028" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values7]" time="0.025" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values8]" time="0.032" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values9]" time="0.034" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values10]" time="0.066" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values11]" time="0.062" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values12]" time="0.109" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values13]" time="0.038" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values14]" time="0.046" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values15]" time="0.039" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values16]" time="0.070" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values17]" time="0.059" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values18]" time="0.064" /><testcase classname="tests.test_paraxial" name="test_calculate_FNO[backend=torch-optic_and_values19]" time="0.004" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values0]" time="0.045" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values1]" time="0.002" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values2]" time="0.004" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values3]" time="0.004" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values4]" time="0.015" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values5]" time="0.011" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values6]" time="0.024" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values7]" time="0.021" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values8]" time="0.031" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values9]" time="0.035" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values10]" time="0.062" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values11]" time="0.058" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values12]" time="0.109" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values13]" time="0.040" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values14]" time="0.055" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values15]" time="0.044" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values16]" time="0.071" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values17]" time="0.054" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values18]" time="0.060" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=numpy-optic_and_values19]" time="0.003" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values0]" time="0.062" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values1]" time="0.009" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values2]" time="0.014" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values3]" time="0.015" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values4]" time="0.019" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values5]" time="0.018" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values6]" time="0.038" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values7]" time="0.034" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values8]" time="0.042" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values9]" time="0.041" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values10]" time="0.078" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values11]" time="0.074" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values12]" time="0.134" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values13]" time="0.048" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values14]" time="0.056" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values15]" time="0.061" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values16]" time="0.086" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values17]" time="0.074" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values18]" time="0.076" /><testcase classname="tests.test_paraxial" name="test_calculate_invariant[backend=torch-optic_and_values19]" time="0.011" /><testcase classname="tests.test_paraxial" name="test_EPD_float_by_stop_size_finite[backend=numpy]" time="0.030" /><testcase classname="tests.test_paraxial" name="test_EPD_float_by_stop_size_finite[backend=torch]" time="0.035" /><testcase classname="tests.test_paraxial" name="test_EPD_float_by_stop_size_infinite[backend=numpy]" time="0.028" /><testcase classname="tests.test_paraxial" name="test_EPD_float_by_stop_size_infinite[backend=torch]" time="0.033" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_init_with_invalid_surface_type[backend=numpy]" time="0.002" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_init_with_invalid_surface_type[backend=torch]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_missing_paraxial_surface[backend=numpy]" time="0.010" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_missing_paraxial_surface[backend=torch]" time="0.012" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_resolve_material_string_success[backend=numpy]" time="0.013" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_resolve_material_string_success[backend=torch]" time="0.012" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_resolve_material_string_failure[backend=numpy]" time="0.005" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_resolve_material_string_failure[backend=torch]" time="0.005" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_resolve_material_float[backend=numpy]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_resolve_material_float[backend=torch]" time="0.002" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_resolve_material_basematerial[backend=numpy]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_resolve_material_basematerial[backend=torch]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_resolve_material_invalid_type[backend=numpy]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_resolve_material_invalid_type[backend=torch]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_get_paraxial_surface_index_found[backend=numpy]" time="0.011" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_get_paraxial_surface_index_found[backend=torch]" time="0.010" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_get_paraxial_surface_index_not_found[backend=numpy]" time="0.010" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_get_paraxial_surface_index_not_found[backend=torch]" time="0.011" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_calculate_radii_zero_focal_length[backend=numpy]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_calculate_radii_zero_focal_length[backend=torch]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_calculate_radii_positive_and_negative[backend=numpy]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_calculate_radii_positive_and_negative[backend=torch]" time="0.002" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_remove_paraxial_surface_valid_and_invalid[backend=numpy]" time="0.014" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_remove_paraxial_surface_valid_and_invalid[backend=torch]" time="0.014" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_convert_replaces_surface[backend=numpy]" time="0.002" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_convert_replaces_surface[backend=torch]" time="0.004" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_convert_to_thick_lens_function[backend=numpy]" time="0.057" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_convert_to_thick_lens_function[backend=torch]" time="0.054" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_biconvex_unsolvable_linear_case[backend=numpy]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_biconvex_unsolvable_linear_case[backend=torch]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_biconvex_discriminant_negative[backend=numpy]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_biconvex_discriminant_negative[backend=torch]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_biconvex_no_positive_solution[backend=numpy]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_biconvex_no_positive_solution[backend=torch]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_biconcave_unsolvable_linear_case[backend=numpy]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_biconcave_unsolvable_linear_case[backend=torch]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_biconcave_discriminant_negative[backend=numpy]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_biconcave_discriminant_negative[backend=torch]" time="0.003" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_biconcave_no_negative_solution[backend=numpy]" time="0.001" /><testcase classname="tests.test_paraxial_to_thick.TestParaxialToThickLensConverter" name="test_biconcave_no_negative_solution[backend=torch]" time="0.001" /><testcase classname="tests.test_perturbation" name="test_scalar_sampler[backend=numpy]" time="0.000" /><testcase classname="tests.test_perturbation" name="test_scalar_sampler[backend=torch]" time="0.000" /><testcase classname="tests.test_perturbation" name="test_range_sampler[backend=numpy]" time="0.001" /><testcase classname="tests.test_perturbation" name="test_range_sampler[backend=torch]" time="0.001" /><testcase classname="tests.test_perturbation" name="test_range_cycle_twice[backend=numpy]" time="0.002" /><testcase classname="tests.test_perturbation" name="test_range_cycle_twice[backend=torch]" time="0.002" /><testcase classname="tests.test_perturbation" name="test_distribution_sampler_normal[backend=numpy]" time="0.001" /><testcase classname="tests.test_perturbation" name="test_distribution_sampler_normal[backend=torch]" time="0.004" /><testcase classname="tests.test_perturbation" name="test_distribution_sampler_uniform[backend=numpy]" time="0.001" /><testcase classname="tests.test_perturbation" name="test_distribution_sampler_uniform[backend=torch]" time="0.001" /><testcase classname="tests.test_perturbation" name="test_distribution_sampler_unknown[backend=numpy]" time="0.001" /><testcase classname="tests.test_perturbation" name="test_distribution_sampler_unknown[backend=torch]" time="0.001" /><testcase classname="tests.test_perturbation" name="test_perturbation_apply[backend=numpy]" time="0.043" /><testcase classname="tests.test_perturbation" name="test_perturbation_apply[backend=torch]" time="0.042" /><testcase classname="tests.test_perturbation" name="test_range_sampler_reset[backend=numpy]" time="0.001" /><testcase classname="tests.test_perturbation" name="test_range_sampler_reset[backend=torch]" time="0.001" /><testcase classname="tests.test_perturbation" name="test_distribution_sampler_seed[backend=numpy]" time="0.001" /><testcase classname="tests.test_perturbation" name="test_distribution_sampler_seed[backend=torch]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestRadialAperture" name="test_clip[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestRadialAperture" name="test_clip[backend=torch]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestRadialAperture" name="test_scale[backend=numpy]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestRadialAperture" name="test_scale[backend=torch]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestRadialAperture" name="test_to_dict[backend=numpy]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestRadialAperture" name="test_to_dict[backend=torch]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestRadialAperture" name="test_from_dict[backend=numpy]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestRadialAperture" name="test_from_dict[backend=torch]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestRadialAperture" name="test_view" time="0.032" /><testcase classname="tests.test_physical_apertures.TestRadialAperture" name="test_extent[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestRadialAperture" name="test_extent[backend=torch]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestOffsetRadialAperture" name="test_clip[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestOffsetRadialAperture" name="test_clip[backend=torch]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestOffsetRadialAperture" name="test_scale[backend=numpy]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestOffsetRadialAperture" name="test_scale[backend=torch]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestOffsetRadialAperture" name="test_to_dict[backend=numpy]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestOffsetRadialAperture" name="test_to_dict[backend=torch]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestOffsetRadialAperture" name="test_from_dict[backend=numpy]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestOffsetRadialAperture" name="test_from_dict[backend=torch]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestOffsetRadialAperture" name="test_extent[backend=numpy]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestOffsetRadialAperture" name="test_extent[backend=torch]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestOffsetRadialAperture" name="test_view" time="0.012" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_union_aperture[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_union_aperture[backend=torch]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_intersection_aperture[backend=numpy]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_intersection_aperture[backend=torch]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_difference_aperture[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_difference_aperture[backend=torch]" time="0.002" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_union_type[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_union_type[backend=torch]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_intersection_type[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_intersection_type[backend=torch]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_difference_type[backend=numpy]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_difference_type[backend=torch]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_extent[backend=numpy]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_extent[backend=torch]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_view[backend=numpy]" time="0.038" /><testcase classname="tests.test_physical_apertures.TestBooleanApertures" name="test_view[backend=torch]" time="0.041" /><testcase classname="tests.test_physical_apertures.TestRectangularAperture" name="test_clip[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestRectangularAperture" name="test_clip[backend=torch]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestRectangularAperture" name="test_scale[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestRectangularAperture" name="test_scale[backend=torch]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestRectangularAperture" name="test_to_dict[backend=numpy]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestRectangularAperture" name="test_to_dict[backend=torch]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestRectangularAperture" name="test_from_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestRectangularAperture" name="test_from_dict[backend=torch]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestRectangularAperture" name="test_extent[backend=numpy]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestRectangularAperture" name="test_extent[backend=torch]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestRectangularAperture" name="test_view[backend=numpy]" time="0.016" /><testcase classname="tests.test_physical_apertures.TestRectangularAperture" name="test_view[backend=torch]" time="0.012" /><testcase classname="tests.test_physical_apertures.TestEllipticalAperture" name="test_clip[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestEllipticalAperture" name="test_clip[backend=torch]" time="0.002" /><testcase classname="tests.test_physical_apertures.TestEllipticalAperture" name="test_scale[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestEllipticalAperture" name="test_scale[backend=torch]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestEllipticalAperture" name="test_to_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestEllipticalAperture" name="test_to_dict[backend=torch]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestEllipticalAperture" name="test_from_dict[backend=numpy]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestEllipticalAperture" name="test_from_dict[backend=torch]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestEllipticalAperture" name="test_extent[backend=numpy]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestEllipticalAperture" name="test_extent[backend=torch]" time="0.000" /><testcase classname="tests.test_physical_apertures.TestEllipticalAperture" name="test_view[backend=numpy]" time="0.013" /><testcase classname="tests.test_physical_apertures.TestEllipticalAperture" name="test_view[backend=torch]" time="0.015" /><testcase classname="tests.test_physical_apertures.TestPolygonAperture" name="test_clip[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestPolygonAperture" name="test_clip[backend=torch]" time="0.003" /><testcase classname="tests.test_physical_apertures.TestPolygonAperture" name="test_scale[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestPolygonAperture" name="test_scale[backend=torch]" time="0.002" /><testcase classname="tests.test_physical_apertures.TestPolygonAperture" name="test_to_dict[backend=numpy]" time="0.002" /><testcase classname="tests.test_physical_apertures.TestPolygonAperture" name="test_to_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_physical_apertures.TestPolygonAperture" name="test_from_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestPolygonAperture" name="test_from_dict[backend=torch]" time="0.002" /><testcase classname="tests.test_physical_apertures.TestPolygonAperture" name="test_extent[backend=numpy]" time="0.002" /><testcase classname="tests.test_physical_apertures.TestPolygonAperture" name="test_extent[backend=torch]" time="0.004" /><testcase classname="tests.test_physical_apertures.TestPolygonAperture" name="test_view[backend=numpy]" time="0.024" /><testcase classname="tests.test_physical_apertures.TestPolygonAperture" name="test_view[backend=torch]" time="0.034" /><testcase classname="tests.test_physical_apertures.TestFileAperture" name="test_clip[backend=numpy]" time="0.007" /><testcase classname="tests.test_physical_apertures.TestFileAperture" name="test_clip[backend=torch]" time="0.008" /><testcase classname="tests.test_physical_apertures.TestFileAperture" name="test_scale[backend=numpy]" time="0.004" /><testcase classname="tests.test_physical_apertures.TestFileAperture" name="test_scale[backend=torch]" time="0.003" /><testcase classname="tests.test_physical_apertures.TestFileAperture" name="test_to_dict[backend=numpy]" time="0.003" /><testcase classname="tests.test_physical_apertures.TestFileAperture" name="test_to_dict[backend=torch]" time="0.004" /><testcase classname="tests.test_physical_apertures.TestFileAperture" name="test_from_dict" time="0.003" /><testcase classname="tests.test_physical_apertures.TestFileAperture" name="test_extent[backend=numpy]" time="0.002" /><testcase classname="tests.test_physical_apertures.TestFileAperture" name="test_extent[backend=torch]" time="0.002" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_none_input[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_none_input[backend=torch]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_scalar_input[backend=numpy-2-1.0]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_scalar_input[backend=numpy-0.0-0.0]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_scalar_input[backend=numpy-3.5-1.75]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_scalar_input[backend=torch-2-1.0]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_scalar_input[backend=torch-0.0-0.0]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_scalar_input[backend=torch-3.5-1.75]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_valid_base_aperture_instance[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_valid_base_aperture_instance[backend=torch]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_invalid_input_raises_value_error[backend=numpy-circle]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_invalid_input_raises_value_error[backend=numpy-invalid_input1]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_invalid_input_raises_value_error[backend=numpy-invalid_input2]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_invalid_input_raises_value_error[backend=numpy-invalid_input3]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_invalid_input_raises_value_error[backend=numpy-invalid_input4]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_invalid_input_raises_value_error[backend=torch-circle]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_invalid_input_raises_value_error[backend=torch-invalid_input1]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_invalid_input_raises_value_error[backend=torch-invalid_input2]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_invalid_input_raises_value_error[backend=torch-invalid_input3]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_invalid_input_raises_value_error[backend=torch-invalid_input4]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_custom_base_aperture_subclass[backend=numpy]" time="0.001" /><testcase classname="tests.test_physical_apertures.TestConfigureAperture" name="test_custom_base_aperture_subclass[backend=torch]" time="0.001" /><testcase classname="tests.test_pickup.TestPickup" name="test_apply_radius[backend=numpy]" time="0.034" /><testcase classname="tests.test_pickup.TestPickup" name="test_apply_radius[backend=torch]" time="0.034" /><testcase classname="tests.test_pickup.TestPickup" name="test_apply_conic[backend=numpy]" time="0.032" /><testcase classname="tests.test_pickup.TestPickup" name="test_apply_conic[backend=torch]" time="0.034" /><testcase classname="tests.test_pickup.TestPickup" name="test_apply_thickness[backend=numpy]" time="0.032" /><testcase classname="tests.test_pickup.TestPickup" name="test_apply_thickness[backend=torch]" time="0.037" /><testcase classname="tests.test_pickup.TestPickup" name="test_invalid_attr_type[backend=numpy]" time="0.031" /><testcase classname="tests.test_pickup.TestPickup" name="test_invalid_attr_type[backend=torch]" time="0.032" /><testcase classname="tests.test_pickup.TestPickup" name="test_invalid_set_attr[backend=numpy]" time="0.032" /><testcase classname="tests.test_pickup.TestPickup" name="test_invalid_set_attr[backend=torch]" time="0.034" /><testcase classname="tests.test_pickup.TestPickup" name="test_to_dict[backend=numpy]" time="0.028" /><testcase classname="tests.test_pickup.TestPickup" name="test_to_dict[backend=torch]" time="0.030" /><testcase classname="tests.test_pickup.TestPickup" name="test_from_dict[backend=numpy]" time="0.030" /><testcase classname="tests.test_pickup.TestPickup" name="test_from_dict[backend=torch]" time="0.032" /><testcase classname="tests.test_pickup.TestPickupManager" name="test_add_pickup[backend=numpy]" time="0.032" /><testcase classname="tests.test_pickup.TestPickupManager" name="test_add_pickup[backend=torch]" time="0.030" /><testcase classname="tests.test_pickup.TestPickupManager" name="test_apply_pickups[backend=numpy]" time="0.031" /><testcase classname="tests.test_pickup.TestPickupManager" name="test_apply_pickups[backend=torch]" time="0.031" /><testcase classname="tests.test_pickup.TestPickupManager" name="test_clear_pickups[backend=numpy]" time="0.028" /><testcase classname="tests.test_pickup.TestPickupManager" name="test_clear_pickups[backend=torch]" time="0.030" /><testcase classname="tests.test_pickup.TestPickupManager" name="test_to_dict[backend=numpy]" time="0.030" /><testcase classname="tests.test_pickup.TestPickupManager" name="test_to_dict[backend=torch]" time="0.030" /><testcase classname="tests.test_pickup.TestPickupManager" name="test_from_dict[backend=numpy]" time="0.033" /><testcase classname="tests.test_pickup.TestPickupManager" name="test_from_dict[backend=torch]" time="0.031" /><testcase classname="tests.test_rays" name="test_translate[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays" name="test_translate[backend=torch]" time="0.001" /><testcase classname="tests.test_rays" name="test__process_input[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays" name="test__process_input[backend=torch]" time="0.003" /><testcase classname="tests.test_rays" name="test_real_rays_init[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays" name="test_real_rays_init[backend=torch]" time="0.001" /><testcase classname="tests.test_rays" name="test_rotate_x[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays" name="test_rotate_x[backend=torch]" time="0.002" /><testcase classname="tests.test_rays" name="test_rotate_y[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays" name="test_rotate_y[backend=torch]" time="0.002" /><testcase classname="tests.test_rays" name="test_rotate_z[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays" name="test_rotate_z[backend=torch]" time="0.003" /><testcase classname="tests.test_rays" name="test_propagate[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays" name="test_propagate[backend=torch]" time="0.002" /><testcase classname="tests.test_rays" name="test_clip[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays" name="test_clip[backend=torch]" time="0.001" /><testcase classname="tests.test_rays" name="test_paraxial_rays_init[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays" name="test_paraxial_rays_init[backend=torch]" time="0.002" /><testcase classname="tests.test_rays" name="test_paraxial_propagate[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays" name="test_paraxial_propagate[backend=torch]" time="0.001" /><testcase classname="tests.test_rays" name="test_reflect[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays" name="test_reflect[backend=torch]" time="0.003" /><testcase classname="tests.test_rays" name="test_real_rays_str[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays" name="test_real_rays_str[backend=torch]" time="0.002" /><testcase classname="tests.test_rays.TestPolarizationState" name="test_constructor[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizationState" name="test_constructor[backend=torch]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizationState" name="test_constructor_invalid[backend=numpy]" time="0.000" /><testcase classname="tests.test_rays.TestPolarizationState" name="test_constructor_invalid[backend=torch]" time="0.000" /><testcase classname="tests.test_rays.TestPolarizationState" name="test_str[backend=numpy]" time="0.000" /><testcase classname="tests.test_rays.TestPolarizationState" name="test_str[backend=torch]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizationState" name="test_str_unpolarized[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizationState" name="test_str_unpolarized[backend=torch]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizationState" name="test_repr[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizationState" name="test_repr[backend=torch]" time="0.001" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_unpolarized[backend=numpy]" time="0.000" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_unpolarized[backend=torch]" time="0.000" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_horizontal[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_horizontal[backend=torch]" time="0.001" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_vertical[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_vertical[backend=torch]" time="0.001" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_linear_45[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_linear_45[backend=torch]" time="0.001" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_linear_minus_45[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_linear_minus_45[backend=torch]" time="0.001" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_right_circular[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_right_circular[backend=torch]" time="0.003" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_left_circular[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_left_circular[backend=torch]" time="0.001" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_invalid[backend=numpy]" time="0.000" /><testcase classname="tests.test_rays.TestCreatePolarization" name="test_create_polarization_invalid[backend=torch]" time="0.000" /><testcase classname="tests.test_rays.TestPolarizedRays" name="test_init[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizedRays" name="test_init[backend=torch]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizedRays" name="test_get_output_field[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizedRays" name="test_get_output_field[backend=torch]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizedRays" name="test_update_intensity[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizedRays" name="test_update_intensity[backend=torch]" time="0.003" /><testcase classname="tests.test_rays.TestPolarizedRays" name="test_update[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizedRays" name="test_update[backend=torch]" time="0.002" /><testcase classname="tests.test_rays.TestPolarizedRays" name="test_get_3d_electric_field[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizedRays" name="test_get_3d_electric_field[backend=torch]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizedRays" name="test_get_3d_electric_field_error[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestPolarizedRays" name="test_get_3d_electric_field_error[backend=torch]" time="0.002" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_generate_rays[backend=numpy]" time="0.046" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_generate_rays[backend=torch]" time="0.058" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_generate_rays_telecentric[backend=numpy]" time="0.017" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_generate_rays_telecentric[backend=torch]" time="0.039" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_generate_rays_invalid_field_type[backend=numpy]" time="0.015" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_generate_rays_invalid_field_type[backend=torch]" time="0.049" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_invalid_polarization[backend=numpy]" time="0.045" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_invalid_polarization[backend=torch]" time="0.056" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_generate_polarized_rays[backend=numpy]" time="0.043" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_generate_polarized_rays[backend=torch]" time="0.055" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_get_ray_origins_infinite_object[backend=numpy]" time="0.043" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_get_ray_origins_infinite_object[backend=torch]" time="0.055" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_get_ray_origins_invalid_field_type[backend=numpy]" time="0.040" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_get_ray_origins_invalid_field_type[backend=torch]" time="0.044" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_invalid_ray_origin_telecentric[backend=numpy]" time="0.043" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_invalid_ray_origin_telecentric[backend=torch]" time="0.052" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_normalize[backend=numpy]" time="0.001" /><testcase classname="tests.test_rays.TestRayGenerator" name="test_normalize[backend=torch]" time="0.001" /><testcase classname="tests.test_rays.TestOpticTrace" name="test_trace_single_field_scalar_input[backend=numpy]" time="0.046" /><testcase classname="tests.test_rays.TestOpticTrace" name="test_trace_single_field_scalar_input[backend=torch]" time="0.068" /><testcase classname="tests.test_rays.TestOpticTrace" name="test_trace_multiple_fields_array_input[backend=numpy]" time="0.051"><failure message="ValueError: operands could not be broadcast together with shapes (276,) (2,)">self = &lt;tests.test_rays.TestOpticTrace object at 0x000001478F49EB50&gt;
sample_optic = &lt;optiland.samples.objectives.TessarLens object at 0x000001479A7C9ED0&gt;

    def test_trace_multiple_fields_array_input(self, sample_optic):
        """Tests .trace() with multiple field points using array inputs for Hx, Hy."""
        num_rays_grid_size = 20
        num_fields = 2
        Hx_all = be.array([0.0, 0.0])
        Hy_all = be.array([0.7, 1.0])
    
        from optiland.distribution import create_distribution
        dist = create_distribution("uniform")
        dist.generate_points(num_rays_grid_size)
        num_pupil_points = len(dist.x)
    
&gt;       rays = sample_optic.trace(
            Hx=Hx_all,
            Hy=Hy_all,
            wavelength=sample_optic.primary_wavelength,
            num_rays=num_rays_grid_size,
            distribution="uniform",
        )

tests\test_rays.py:913: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:616: in trace
    rays = ray_generator.generate_rays(
optiland\rays\ray_generator.py:41: in generate_rays
    x0, y0, z0 = self.optic.field_definition.get_ray_origins(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.fields.field_types.AngleField object at 0x000001479F3FA750&gt;
optic = &lt;optiland.samples.objectives.TessarLens object at 0x000001479A7C9ED0&gt;
Hx = array([0., 0.]), Hy = array([0.7, 1. ])
Px = array([-0.36842105, -0.26315789, -0.15789474, -0.05263158,  0.05263158,
        0.15789474,  0.26315789,  0.36842105, ... -0.36842105, -0.26315789,
       -0.15789474, -0.05263158,  0.05263158,  0.15789474,  0.26315789,
        0.36842105])
Py = array([-0.89473684, -0.89473684, -0.89473684, -0.89473684, -0.89473684,
       -0.89473684, -0.89473684, -0.89473684, ...  0.89473684,  0.89473684,
        0.89473684,  0.89473684,  0.89473684,  0.89473684,  0.89473684,
        0.89473684])
vx = array([1., 1.]), vy = array([1., 1.])

    def get_ray_origins(self, optic, Hx, Hy, Px, Py, vx, vy):
        """Calculate the initial positions for rays originating at the object.
    
        Args:
            Hx (float): Normalized x field coordinate.
            Hy (float): Normalized y field coordinate.
            Px (float or be.ndarray): x-coordinate of the pupil point.
            Py (float or be.ndarray): y-coordinate of the pupil point.
            vx (float): Vignetting factor in the x-direction.
            vy (float): Vignetting factor in the y-direction.
    
        Returns:
            tuple: A tuple containing the x, y, and z coordinates of the
                object position.
    
        """
        obj = optic.object_surface
        EPL = optic.paraxial.EPL()
        max_field = optic.fields.max_field
        field_x = max_field * Hx
        field_y = max_field * Hy
    
        if obj.is_infinite:
            EPD = optic.paraxial.EPD()
            offset = self._get_starting_z_offset(optic)
            x = -be.tan(be.radians(field_x)) * (offset + EPL)
            y = -be.tan(be.radians(field_y)) * (offset + EPL)
            z = optic.surface_group.positions[1] - offset
&gt;           x0 = Px * EPD / 2 * vx + x
                 ^^^^^^^^^^^^^^^^^
E           ValueError: operands could not be broadcast together with shapes (276,) (2,)

optiland\fields\field_types.py:162: ValueError</failure></testcase><testcase classname="tests.test_rays.TestOpticTrace" name="test_trace_multiple_fields_array_input[backend=torch]" time="0.059"><failure message="RuntimeError: The size of tensor a (276) must match the size of tensor b (2) at non-singleton dimension 0">self = &lt;tests.test_rays.TestOpticTrace object at 0x000001478F49EDD0&gt;
sample_optic = &lt;optiland.samples.objectives.TessarLens object at 0x000001479501DF50&gt;

    def test_trace_multiple_fields_array_input(self, sample_optic):
        """Tests .trace() with multiple field points using array inputs for Hx, Hy."""
        num_rays_grid_size = 20
        num_fields = 2
        Hx_all = be.array([0.0, 0.0])
        Hy_all = be.array([0.7, 1.0])
    
        from optiland.distribution import create_distribution
        dist = create_distribution("uniform")
        dist.generate_points(num_rays_grid_size)
        num_pupil_points = len(dist.x)
    
&gt;       rays = sample_optic.trace(
            Hx=Hx_all,
            Hy=Hy_all,
            wavelength=sample_optic.primary_wavelength,
            num_rays=num_rays_grid_size,
            distribution="uniform",
        )

tests\test_rays.py:913: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:616: in trace
    rays = ray_generator.generate_rays(
optiland\rays\ray_generator.py:41: in generate_rays
    x0, y0, z0 = self.optic.field_definition.get_ray_origins(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.fields.field_types.AngleField object at 0x00000147963BA790&gt;
optic = &lt;optiland.samples.objectives.TessarLens object at 0x000001479501DF50&gt;
Hx = tensor([0., 0.], dtype=torch.float64, requires_grad=True)
Hy = tensor([0.7000, 1.0000], dtype=torch.float64, requires_grad=True)
Px = tensor([-0.3684, -0.2632, -0.1579, -0.0526,  0.0526,  0.1579,  0.2632,  0.3684,
        -0.5789, -0.4737, -0.3684, -0....2, -0.1579, -0.0526,
         0.0526,  0.1579,  0.2632,  0.3684], dtype=torch.float64,
       grad_fn=&lt;IndexBackward0&gt;)
Py = tensor([-0.8947, -0.8947, -0.8947, -0.8947, -0.8947, -0.8947, -0.8947, -0.8947,
        -0.7895, -0.7895, -0.7895, -0....7,  0.8947,  0.8947,
         0.8947,  0.8947,  0.8947,  0.8947], dtype=torch.float64,
       grad_fn=&lt;IndexBackward0&gt;)
vx = tensor([1., 1.], dtype=torch.float64, grad_fn=&lt;RsubBackward1&gt;)
vy = tensor([1., 1.], dtype=torch.float64, grad_fn=&lt;RsubBackward1&gt;)

    def get_ray_origins(self, optic, Hx, Hy, Px, Py, vx, vy):
        """Calculate the initial positions for rays originating at the object.
    
        Args:
            Hx (float): Normalized x field coordinate.
            Hy (float): Normalized y field coordinate.
            Px (float or be.ndarray): x-coordinate of the pupil point.
            Py (float or be.ndarray): y-coordinate of the pupil point.
            vx (float): Vignetting factor in the x-direction.
            vy (float): Vignetting factor in the y-direction.
    
        Returns:
            tuple: A tuple containing the x, y, and z coordinates of the
                object position.
    
        """
        obj = optic.object_surface
        EPL = optic.paraxial.EPL()
        max_field = optic.fields.max_field
        field_x = max_field * Hx
        field_y = max_field * Hy
    
        if obj.is_infinite:
            EPD = optic.paraxial.EPD()
            offset = self._get_starting_z_offset(optic)
            x = -be.tan(be.radians(field_x)) * (offset + EPL)
            y = -be.tan(be.radians(field_y)) * (offset + EPL)
            z = optic.surface_group.positions[1] - offset
&gt;           x0 = Px * EPD / 2 * vx + x
                 ^^^^^^^^^^^^^^^^^
E           RuntimeError: The size of tensor a (276) must match the size of tensor b (2) at non-singleton dimension 0

optiland\fields\field_types.py:162: RuntimeError</failure></testcase><testcase classname="tests.test_rays.TestOpticTrace" name="test_trace_generic_single_ray[backend=numpy]" time="0.044" /><testcase classname="tests.test_rays.TestOpticTrace" name="test_trace_generic_single_ray[backend=torch]" time="0.067" /><testcase classname="tests.test_rays.TestOpticTrace" name="test_trace_generic_multiple_rays_mixed_inputs[backend=numpy]" time="0.045" /><testcase classname="tests.test_rays.TestOpticTrace" name="test_trace_generic_multiple_rays_mixed_inputs[backend=torch]" time="0.066" /><testcase classname="tests.test_rays.TestOpticTrace" name="test_trace_generic_multiple_fields_and_pupil_points[backend=numpy]" time="0.042" /><testcase classname="tests.test_rays.TestOpticTrace" name="test_trace_generic_multiple_fields_and_pupil_points[backend=torch]" time="0.063" /><testcase classname="tests.test_sampled_mtf.TestSampledMTF" name="test_sampled_mtf_instantiation[backend=numpy]" time="0.033"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_sampled_mtf.TestSampledMTF object at 0x000001478F4A6E50&gt;
set_test_backend = None

    def test_sampled_mtf_instantiation(self, set_test_backend):
        """Test that SampledMTF can be instantiated without errors."""
        optic = CookeTriplet()
    
        # On-axis field, primary wavelength from optic
        field = (0, 0)
        wavelength = optic.primary_wavelength
    
&gt;       sampled_mtf_instance = SampledMTF(
            optic=optic,
            field=field,
            wavelength=wavelength,
            num_rays=32,
            distribution="uniform",
            zernike_terms=37,
            zernike_type="fringe",
        )

tests\test_sampled_mtf.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_sampled_mtf.TestSampledMTF" name="test_sampled_mtf_instantiation[backend=torch]" time="0.045"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_sampled_mtf.TestSampledMTF object at 0x000001478F4A70D0&gt;
set_test_backend = None

    def test_sampled_mtf_instantiation(self, set_test_backend):
        """Test that SampledMTF can be instantiated without errors."""
        optic = CookeTriplet()
    
        # On-axis field, primary wavelength from optic
        field = (0, 0)
        wavelength = optic.primary_wavelength
    
&gt;       sampled_mtf_instance = SampledMTF(
            optic=optic,
            field=field,
            wavelength=wavelength,
            num_rays=32,
            distribution="uniform",
            zernike_terms=37,
            zernike_type="fringe",
        )

tests\test_sampled_mtf.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_sampled_mtf.TestSampledMTF" name="test_mtf_at_zero_frequency[backend=numpy]" time="0.032"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_sampled_mtf.TestSampledMTF object at 0x000001478F4A7310&gt;
set_test_backend = None

    def test_mtf_at_zero_frequency(self, set_test_backend):
        """Test that MTF at zero frequency is 1.0."""
        optic = CookeTriplet()
        field = optic.fields.get_field_coords()[0]
    
&gt;       sampled_mtf_instance = SampledMTF(
            optic=optic,
            field=field,
            wavelength=0.55,
        )

tests\test_sampled_mtf.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_sampled_mtf.TestSampledMTF" name="test_mtf_at_zero_frequency[backend=torch]" time="0.045"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_sampled_mtf.TestSampledMTF object at 0x000001478F4A7450&gt;
set_test_backend = None

    def test_mtf_at_zero_frequency(self, set_test_backend):
        """Test that MTF at zero frequency is 1.0."""
        optic = CookeTriplet()
        field = optic.fields.get_field_coords()[0]
    
&gt;       sampled_mtf_instance = SampledMTF(
            optic=optic,
            field=field,
            wavelength=0.55,
        )

tests\test_sampled_mtf.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_sampled_mtf.TestSampledMTF" name="test_triplet_system_behavior[backend=numpy]" time="0.038"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_sampled_mtf.TestSampledMTF object at 0x000001478F4A7B90&gt;
set_test_backend = None

    def test_triplet_system_behavior(self, set_test_backend):
        """Test MTF properties for a well-behaved system."""
        optic = CookeTriplet()
        field = (0, 0)
    
&gt;       sampled_mtf_instance = SampledMTF(
            optic=optic, field=field, wavelength=0.55, num_rays=32, zernike_terms=37
        )

tests\test_sampled_mtf.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_sampled_mtf.TestSampledMTF" name="test_triplet_system_behavior[backend=torch]" time="0.044"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_sampled_mtf.TestSampledMTF object at 0x000001478F4A7CD0&gt;
set_test_backend = None

    def test_triplet_system_behavior(self, set_test_backend):
        """Test MTF properties for a well-behaved system."""
        optic = CookeTriplet()
        field = (0, 0)
    
&gt;       sampled_mtf_instance = SampledMTF(
            optic=optic, field=field, wavelength=0.55, num_rays=32, zernike_terms=37
        )

tests\test_sampled_mtf.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_sampled_mtf.TestSampledMTF" name="test_defocused_system_behavior[backend=numpy]" time="0.034"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_sampled_mtf.TestSampledMTF object at 0x000001478F4B0410&gt;
set_test_backend = None

    def test_defocused_system_behavior(self, set_test_backend):
        """Test that defocus lowers the MTF compared to a focused system."""
        optic = CookeTriplet()
        field = (0, 1)
    
        # Defocus
        optic.image_surface.geometry.cs.z = optic.image_surface.geometry.cs.z + 0.5
    
&gt;       sampled_mtf_focused = SampledMTF(
            optic=optic,
            field=field,
            wavelength=0.6,
            num_rays=32,
        )

tests\test_sampled_mtf.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_sampled_mtf.TestSampledMTF" name="test_defocused_system_behavior[backend=torch]" time="0.049"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_sampled_mtf.TestSampledMTF object at 0x000001478F4B0550&gt;
set_test_backend = None

    def test_defocused_system_behavior(self, set_test_backend):
        """Test that defocus lowers the MTF compared to a focused system."""
        optic = CookeTriplet()
        field = (0, 1)
    
        # Defocus
        optic.image_surface.geometry.cs.z = optic.image_surface.geometry.cs.z + 0.5
    
&gt;       sampled_mtf_focused = SampledMTF(
            optic=optic,
            field=field,
            wavelength=0.6,
            num_rays=32,
        )

tests\test_sampled_mtf.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_sampled_mtf.TestSampledMTF" name="test_calculate_mtf_multiple_calls[backend=numpy]" time="0.033"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_sampled_mtf.TestSampledMTF object at 0x000001478F4B0CD0&gt;
set_test_backend = None

    def test_calculate_mtf_multiple_calls(self, set_test_backend):
        """Test consistency of calculate_mtf with multiple calls."""
        optic = CookeTriplet()
        field = (0.5, 0.5)
    
&gt;       sampled_mtf_instance = SampledMTF(
            optic=optic,
            field=field,
            wavelength=0.6,
        )

tests\test_sampled_mtf.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_sampled_mtf.TestSampledMTF" name="test_calculate_mtf_multiple_calls[backend=torch]" time="0.049"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_sampled_mtf.TestSampledMTF object at 0x000001478F4B0F50&gt;
set_test_backend = None

    def test_calculate_mtf_multiple_calls(self, set_test_backend):
        """Test consistency of calculate_mtf with multiple calls."""
        optic = CookeTriplet()
        field = (0.5, 0.5)
    
&gt;       sampled_mtf_instance = SampledMTF(
            optic=optic,
            field=field,
            wavelength=0.6,
        )

tests\test_sampled_mtf.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_sampled_mtf.TestSampledMTF" name="test_zero_xpd_handling[backend=numpy]" time="0.031"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_sampled_mtf.TestSampledMTF object at 0x000001478F4B1990&gt;
set_test_backend = None

    def test_zero_xpd_handling(self, set_test_backend):
        """Test MTF calculation when Exit Pupil Diameter (XPD) is zero."""
        optic = CookeTriplet()
        field = (0, 0)
    
&gt;       sampled_mtf_instance = SampledMTF(
            optic=optic,
            field=field,
            wavelength=0.56,
        )

tests\test_sampled_mtf.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_sampled_mtf.TestSampledMTF" name="test_zero_xpd_handling[backend=torch]" time="0.046"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_sampled_mtf.TestSampledMTF object at 0x000001478F4B1C10&gt;
set_test_backend = None

    def test_zero_xpd_handling(self, set_test_backend):
        """Test MTF calculation when Exit Pupil Diameter (XPD) is zero."""
        optic = CookeTriplet()
        field = (0, 0)
    
&gt;       sampled_mtf_instance = SampledMTF(
            optic=optic,
            field=field,
            wavelength=0.56,
        )

tests\test_sampled_mtf.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_scatter.TestGetPointLambertian" name="test_point_within_unit_disk" time="0.869" /><testcase classname="tests.test_scatter.TestGetPointLambertian" name="test_randomness" time="0.001" /><testcase classname="tests.test_scatter.TestGetPointLambertian" name="test_output_type" time="0.000" /><testcase classname="tests.test_scatter.TestGetPointGaussian" name="test_output_type" time="0.406" /><testcase classname="tests.test_scatter.TestGetPointGaussian" name="test_randomness" time="0.001" /><testcase classname="tests.test_scatter.TestScatter" name="test_output_type" time="1.724" /><testcase classname="tests.test_scatter.TestScatter" name="test_randomness" time="0.010" /><testcase classname="tests.test_scatter.TestScatter" name="test_large_L" time="0.001" /><testcase classname="tests.test_scatter.TestScatter" name="test_output_unit_vector" time="0.057" /><testcase classname="tests.test_scatter.TestFuncWrapper" name="test_output_type" time="0.001" /><testcase classname="tests.test_scatter.TestFuncWrapper" name="test_output" time="0.141" /><testcase classname="tests.test_scatter.TestScatterParallel" name="test_output_type" time="4.607" /><testcase classname="tests.test_scatter.TestScatterParallel" name="test_randomness" time="0.004" /><testcase classname="tests.test_scatter.TestScatterParallel" name="test_output_unit_vector" time="0.002" /><testcase classname="tests.test_scatter.TestLamberianBSDF" name="test_output_type" time="0.004" /><testcase classname="tests.test_scatter.TestLamberianBSDF" name="test_output_unit_vector" time="0.002" /><testcase classname="tests.test_scatter.TestGaussianBSDF" name="test_output" time="2.762" /><testcase classname="tests.test_sensitivity_analysis" name="test_sensitivity_analysis_initialization" time="0.111" /><testcase classname="tests.test_sensitivity_analysis" name="test_sensitivity_analysis_run" time="0.411" /><testcase classname="tests.test_sensitivity_analysis" name="test_sensitivity_analysis_get_results" time="0.393" /><testcase classname="tests.test_sensitivity_analysis" name="test_sensitivity_analysis_validation_no_operands" time="0.070" /><testcase classname="tests.test_sensitivity_analysis" name="test_sensitivity_analysis_validation_no_perturbations" time="0.069" /><testcase classname="tests.test_sensitivity_analysis" name="test_sensitivity_analysis_validation_too_many_operands" time="0.067" /><testcase classname="tests.test_sensitivity_analysis" name="test_sensitivity_analysis_validation_too_many_perturbations" time="0.067" /><testcase classname="tests.test_sensitivity_analysis" name="test_sensitivity_analysis_view" time="0.419" /><testcase classname="tests.test_sensitivity_analysis" name="test_invalid_sampler" time="0.363" /><testcase classname="tests.test_solves.TestMarginalRayHeightSolve" name="test_marginal_ray_height_solve_constructor[backend=numpy]" time="0.032" /><testcase classname="tests.test_solves.TestMarginalRayHeightSolve" name="test_marginal_ray_height_solve_constructor[backend=torch]" time="0.036" /><testcase classname="tests.test_solves.TestMarginalRayHeightSolve" name="test_marginal_ray_height_solve_apply[backend=numpy]" time="0.033" /><testcase classname="tests.test_solves.TestMarginalRayHeightSolve" name="test_marginal_ray_height_solve_apply[backend=torch]" time="0.039" /><testcase classname="tests.test_solves.TestMarginalRayHeightSolve" name="test_to_dict[backend=numpy]" time="0.031" /><testcase classname="tests.test_solves.TestMarginalRayHeightSolve" name="test_to_dict[backend=torch]" time="0.033" /><testcase classname="tests.test_solves.TestMarginalRayHeightSolve" name="test_from_dict[backend=numpy]" time="0.040" /><testcase classname="tests.test_solves.TestMarginalRayHeightSolve" name="test_from_dict[backend=torch]" time="0.035" /><testcase classname="tests.test_solves.TestMarginalRayHeightSolve" name="test_from_dict_invalid_type[backend=numpy]" time="0.043" /><testcase classname="tests.test_solves.TestMarginalRayHeightSolve" name="test_from_dict_invalid_type[backend=torch]" time="0.044" /><testcase classname="tests.test_solves.TestChiefRayHeightSolve" name="test_chief_ray_height_solve_constructor[backend=numpy]" time="0.037" /><testcase classname="tests.test_solves.TestChiefRayHeightSolve" name="test_chief_ray_height_solve_constructor[backend=torch]" time="0.037" /><testcase classname="tests.test_solves.TestChiefRayHeightSolve" name="test_invalid_surface_idx[backend=numpy]" time="0.035" /><testcase classname="tests.test_solves.TestChiefRayHeightSolve" name="test_invalid_surface_idx[backend=torch]" time="0.038" /><testcase classname="tests.test_solves.TestChiefRayHeightSolve" name="test_chief_ray_height_solve_apply[backend=numpy]" time="0.042" /><testcase classname="tests.test_solves.TestChiefRayHeightSolve" name="test_chief_ray_height_solve_apply[backend=torch]" time="0.061" /><testcase classname="tests.test_solves.TestChiefRayHeightSolve" name="test_to_dict[backend=numpy]" time="0.034" /><testcase classname="tests.test_solves.TestChiefRayHeightSolve" name="test_to_dict[backend=torch]" time="0.035" /><testcase classname="tests.test_solves.TestChiefRayHeightSolve" name="test_from_dict[backend=numpy]" time="0.033" /><testcase classname="tests.test_solves.TestChiefRayHeightSolve" name="test_from_dict[backend=torch]" time="0.034" /><testcase classname="tests.test_solves.TestQuickfocusSolve" name="test_quick_focus_solve_constructor[backend=numpy]" time="0.033" /><testcase classname="tests.test_solves.TestQuickfocusSolve" name="test_quick_focus_solve_constructor[backend=torch]" time="0.036" /><testcase classname="tests.test_solves.TestQuickfocusSolve" name="test_quick_focus_solve_apply[backend=numpy]" time="0.052" /><testcase classname="tests.test_solves.TestQuickfocusSolve" name="test_quick_focus_solve_apply[backend=torch]" time="0.078" /><testcase classname="tests.test_solves.TestSolveFactory" name="test_create_solve[backend=numpy]" time="0.037" /><testcase classname="tests.test_solves.TestSolveFactory" name="test_create_solve[backend=torch]" time="0.037" /><testcase classname="tests.test_solves.TestSolveFactory" name="test_create_solve_invalid_solve_type[backend=numpy]" time="0.034" /><testcase classname="tests.test_solves.TestSolveFactory" name="test_create_solve_invalid_solve_type[backend=torch]" time="0.036" /><testcase classname="tests.test_solves.TestSolveManager" name="test_solve_manager_constructor[backend=numpy]" time="0.035" /><testcase classname="tests.test_solves.TestSolveManager" name="test_solve_manager_constructor[backend=torch]" time="0.039" /><testcase classname="tests.test_solves.TestSolveManager" name="test_add_solve[backend=numpy]" time="0.034" /><testcase classname="tests.test_solves.TestSolveManager" name="test_add_solve[backend=torch]" time="0.040" /><testcase classname="tests.test_solves.TestSolveManager" name="test_apply_solves[backend=numpy]" time="0.038" /><testcase classname="tests.test_solves.TestSolveManager" name="test_apply_solves[backend=torch]" time="0.046" /><testcase classname="tests.test_solves.TestSolveManager" name="test_clear_solves[backend=numpy]" time="0.035" /><testcase classname="tests.test_solves.TestSolveManager" name="test_clear_solves[backend=torch]" time="0.039" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_trace_paraxial_rays[backend=numpy]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_trace_paraxial_rays[backend=torch]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_trace_real_rays[backend=numpy]" time="0.002" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_trace_real_rays[backend=torch]" time="0.002" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_set_semi_aperture[backend=numpy]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_set_semi_aperture[backend=torch]" time="0.002" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_reset[backend=numpy]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_reset[backend=torch]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_set_fresnel_coating[backend=numpy]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_set_fresnel_coating[backend=torch]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_is_rotationally_symmetric[backend=numpy]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_is_rotationally_symmetric[backend=torch]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_is_rotationally_symmetric_false[backend=numpy]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_is_rotationally_symmetric_false[backend=torch]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_to_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_to_dict[backend=torch]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_from_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_from_dict[backend=torch]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_from_dict_missing_type[backend=numpy]" time="0.001" /><testcase classname="tests.test_standard_surface.TestSurface" name="test_from_dict_missing_type[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_standard[backend=numpy]" time="0.050" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_standard[backend=torch]" time="0.048" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_even_asphere[backend=numpy]" time="0.046" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_even_asphere[backend=torch]" time="0.045" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_odd_asphere[backend=numpy]" time="0.044" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_odd_asphere[backend=torch]" time="0.045" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_polynomial[backend=numpy]" time="0.044" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_polynomial[backend=torch]" time="0.043" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_chebyshev[backend=numpy]" time="0.053" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_chebyshev[backend=torch]" time="0.050" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_object[backend=numpy]" time="0.044" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_object[backend=torch]" time="0.047" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_invalid_surface_type[backend=numpy]" time="0.045" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_invalid_surface_type[backend=torch]" time="0.043" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_invalid_surface_index[backend=numpy]" time="0.043" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_invalid_surface_index[backend=torch]" time="0.043" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_with_coating[backend=numpy]" time="0.045" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_with_coating[backend=torch]" time="0.062" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_with_fresnel[backend=numpy]" time="0.048" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_surface_with_fresnel[backend=torch]" time="0.046" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_invalid_z_with_thickness[backend=numpy]" time="0.047" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_invalid_z_with_thickness[backend=torch]" time="0.045" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_absolute_coordinates[backend=numpy]" time="0.046" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_absolute_coordinates[backend=torch]" time="0.048" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_invalid_thickness_for_abs_cs[backend=numpy]" time="0.046" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_invalid_thickness_for_abs_cs[backend=torch]" time="0.044" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_paraxial_standard[backend=numpy]" time="0.044" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_paraxial_standard[backend=torch]" time="0.047" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_grating_surface[backend=numpy]" time="0.044" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_create_grating_surface[backend=torch]" time="0.048" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_invalid_paraxial_surface[backend=numpy]" time="0.051" /><testcase classname="tests.test_surface_factory.TestSurfaceFactory" name="test_invalid_paraxial_surface[backend=torch]" time="0.046" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_append_empty[backend=numpy-True]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_append_empty[backend=numpy-False]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_append_empty[backend=torch-True]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_append_empty[backend=torch-False]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_append_non_empty_abs_cs[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_append_non_empty_abs_cs[backend=torch]" time="0.003" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_append_non_empty_rel_cs_no_update[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_append_non_empty_rel_cs_no_update[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_insert_middle_rel_cs_triggers_update[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_insert_middle_rel_cs_triggers_update[backend=torch]" time="0.002" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_is_stop_propagation[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_is_stop_propagation[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_by_creation_rel_cs[backend=numpy]" time="0.013" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_by_creation_rel_cs[backend=torch]" time="0.014" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_by_creation_error_no_index[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_by_creation_error_no_index[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_remove_surface_middle_rel_cs_triggers_update[backend=numpy]" time="0.002" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_remove_surface_middle_rel_cs_triggers_update[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_remove_surface_last_rel_cs_no_update_triggered[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_remove_surface_last_rel_cs_no_update_triggered[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_remove_surface_abs_cs_no_update[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_remove_surface_abs_cs_no_update[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_remove_surface_error_remove_object[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_remove_surface_error_remove_object[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_error_negative_index[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_error_negative_index[backend=torch]" time="0.002" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_error_index_out_of_bounds[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_new_object_error_index_out_of_bounds[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_by_creation_error_negative_index[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_by_creation_error_negative_index[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_by_creation_error_index_out_of_bounds[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_add_surface_by_creation_error_index_out_of_bounds[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_remove_surface_error_index_out_of_bounds_negative[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_remove_surface_error_index_out_of_bounds_negative[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_remove_surface_error_index_out_of_bounds_too_large[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_remove_surface_error_index_out_of_bounds_too_large[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_update_coordinate_systems_infinite_thickness_error[backend=numpy]" time="0.002" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_update_coordinate_systems_infinite_thickness_error[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_update_coordinate_systems_thickness_is_be_array[backend=numpy]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_update_coordinate_systems_thickness_is_be_array[backend=torch]" time="0.001" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_insert_all_at_index_1[backend=numpy]" time="0.038" /><testcase classname="tests.test_surface_group.TestSurfaceGroupUpdatesRealObjects" name="test_insert_all_at_index_1[backend=torch]" time="0.049" /><testcase classname="tests.test_thin_lens_interaction_model.TestThinLensInteractionModel" name="test_init[backend=numpy]" time="0.001" /><testcase classname="tests.test_thin_lens_interaction_model.TestThinLensInteractionModel" name="test_init[backend=torch]" time="0.001" /><testcase classname="tests.test_thin_lens_interaction_model.TestThinLensInteractionModel" name="test_trace_paraxial_rays[backend=numpy]" time="0.001" /><testcase classname="tests.test_thin_lens_interaction_model.TestThinLensInteractionModel" name="test_trace_paraxial_rays[backend=torch]" time="0.001" /><testcase classname="tests.test_thin_lens_interaction_model.TestThinLensInteractionModel" name="test_trace_real_rays[backend=numpy]" time="0.001" /><testcase classname="tests.test_thin_lens_interaction_model.TestThinLensInteractionModel" name="test_trace_real_rays[backend=torch]" time="0.002" /><testcase classname="tests.test_thin_lens_interaction_model.TestThinLensInteractionModel" name="test_paraxial_surface_perfect_imaging[backend=numpy]" time="0.004" /><testcase classname="tests.test_thin_lens_interaction_model.TestThinLensInteractionModel" name="test_paraxial_surface_perfect_imaging[backend=torch]" time="0.007" /><testcase classname="tests.test_thin_lens_interaction_model.TestThinLensInteractionModel" name="test_flip[backend=numpy]" time="0.001" /><testcase classname="tests.test_thin_lens_interaction_model.TestThinLensInteractionModel" name="test_flip[backend=torch]" time="0.001" /><testcase classname="tests.test_thin_lens_interaction_model.TestThinLensInteractionModel" name="test_to_dict[backend=numpy]" time="0.001" /><testcase classname="tests.test_thin_lens_interaction_model.TestThinLensInteractionModel" name="test_to_dict[backend=torch]" time="0.001" /><testcase classname="tests.test_thin_lens_interaction_model.TestThinLensInteractionModel" name="test_refractive_paraxial_ray_trace[backend=numpy]" time="0.022" /><testcase classname="tests.test_thin_lens_interaction_model.TestThinLensInteractionModel" name="test_refractive_paraxial_ray_trace[backend=torch]" time="0.018" /><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_init_defaults[backend=numpy]" time="0.046"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F565550&gt;
set_test_backend = None

    def test_init_defaults(self, set_test_backend):
        """Test initialization with default parameters."""
        optic = CookeTriplet()
&gt;       tfm = ThroughFocusMTF(optic, spatial_frequency=10.0)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_through_focus_mtf.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_init_defaults[backend=torch]" time="0.056"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F5657D0&gt;
set_test_backend = None

    def test_init_defaults(self, set_test_backend):
        """Test initialization with default parameters."""
        optic = CookeTriplet()
&gt;       tfm = ThroughFocusMTF(optic, spatial_frequency=10.0)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_through_focus_mtf.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_init_custom_params[backend=numpy]" time="0.038"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F5663D0&gt;
set_test_backend = None

    def test_init_custom_params(self, set_test_backend):
        """Test initialization with custom parameters."""
        optic = CookeTriplet()
        custom_fields = [(0.0, 0.0), (0.1, 0.7)]
        custom_wl = 0.550
&gt;       tfm = ThroughFocusMTF(
            optic=optic,
            spatial_frequency=25.0,
            delta_focus=0.05,
            num_steps=3,
            fields=custom_fields,
            wavelength=custom_wl,
            num_rays=23,
        )

tests\test_through_focus_mtf.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_init_custom_params[backend=torch]" time="0.054"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F566650&gt;
set_test_backend = None

    def test_init_custom_params(self, set_test_backend):
        """Test initialization with custom parameters."""
        optic = CookeTriplet()
        custom_fields = [(0.0, 0.0), (0.1, 0.7)]
        custom_wl = 0.550
&gt;       tfm = ThroughFocusMTF(
            optic=optic,
            spatial_frequency=25.0,
            delta_focus=0.05,
            num_steps=3,
            fields=custom_fields,
            wavelength=custom_wl,
            num_rays=23,
        )

tests\test_through_focus_mtf.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_init_wavelength_direct_float[backend=numpy]" time="0.041"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F567210&gt;
set_test_backend = None

    def test_init_wavelength_direct_float(self, set_test_backend):
        """Test initialization with a specific float wavelength."""
        optic = CookeTriplet()
        wavelength_val = 0.6328
&gt;       tfm = ThroughFocusMTF(
            optic,
            spatial_frequency=5.0,
            wavelength=wavelength_val,
            num_rays=23,
            num_steps=3,
        )

tests\test_through_focus_mtf.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_init_wavelength_direct_float[backend=torch]" time="0.057"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F567490&gt;
set_test_backend = None

    def test_init_wavelength_direct_float(self, set_test_backend):
        """Test initialization with a specific float wavelength."""
        optic = CookeTriplet()
        wavelength_val = 0.6328
&gt;       tfm = ThroughFocusMTF(
            optic,
            spatial_frequency=5.0,
            wavelength=wavelength_val,
            num_rays=23,
            num_steps=3,
        )

tests\test_through_focus_mtf.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_init_invalid_num_steps[backend=numpy]" time="0.033" /><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_init_invalid_num_steps[backend=torch]" time="0.034" /><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_analysis_results_structure_and_values[backend=numpy]" time="0.040"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F56C1D0&gt;
set_test_backend = None

    def test_analysis_results_structure_and_values(self, set_test_backend):
        """Test the structure and basic validity of the analysis results."""
        optic = CookeTriplet()
&gt;       tfm = ThroughFocusMTF(
            optic=optic,
            spatial_frequency=25.0,
            delta_focus=0.05,
            num_steps=1,
            num_rays=23,
        )

tests\test_through_focus_mtf.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_analysis_results_structure_and_values[backend=torch]" time="0.054"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F56C310&gt;
set_test_backend = None

    def test_analysis_results_structure_and_values(self, set_test_backend):
        """Test the structure and basic validity of the analysis results."""
        optic = CookeTriplet()
&gt;       tfm = ThroughFocusMTF(
            optic=optic,
            spatial_frequency=25.0,
            delta_focus=0.05,
            num_steps=1,
            num_rays=23,
        )

tests\test_through_focus_mtf.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_view_min_steps[backend=numpy]" time="0.038"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F56C9D0&gt;
set_test_backend = None

    def test_view_min_steps(self, set_test_backend):
        """Test view method with num_steps=1 (k=0 spline order)."""
        optic = CookeTriplet()
&gt;       tfm = ThroughFocusMTF(optic, spatial_frequency=10.0, num_steps=1)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_through_focus_mtf.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_view_min_steps[backend=torch]" time="0.052"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F56CB10&gt;
set_test_backend = None

    def test_view_min_steps(self, set_test_backend):
        """Test view method with num_steps=1 (k=0 spline order)."""
        optic = CookeTriplet()
&gt;       tfm = ThroughFocusMTF(optic, spatial_frequency=10.0, num_steps=1)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_through_focus_mtf.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_view_few_steps[backend=numpy]" time="0.038"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F56D3D0&gt;
set_test_backend = None

    def test_view_few_steps(self, set_test_backend):
        """Test view method with num_steps=3 (k=1 spline order)."""
        optic = CookeTriplet()
&gt;       tfm = ThroughFocusMTF(optic, spatial_frequency=10.0, num_steps=3)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_through_focus_mtf.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_view_few_steps[backend=torch]" time="0.055"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F56D650&gt;
set_test_backend = None

    def test_view_few_steps(self, set_test_backend):
        """Test view method with num_steps=3 (k=1 spline order)."""
        optic = CookeTriplet()
&gt;       tfm = ThroughFocusMTF(optic, spatial_frequency=10.0, num_steps=3)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_through_focus_mtf.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_view_default_steps[backend=numpy]" time="0.037"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F56E190&gt;
set_test_backend = None

    def test_view_default_steps(self, set_test_backend):
        """Test view method with default num_steps=5 (k=3 spline order)."""
        optic = CookeTriplet()
&gt;       tfm = ThroughFocusMTF(optic, spatial_frequency=152.0, num_rays=53)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_through_focus_mtf.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_view_default_steps[backend=torch]" time="0.052"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F56E410&gt;
set_test_backend = None

    def test_view_default_steps(self, set_test_backend):
        """Test view method with default num_steps=5 (k=3 spline order)."""
        optic = CookeTriplet()
&gt;       tfm = ThroughFocusMTF(optic, spatial_frequency=152.0, num_rays=53)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_through_focus_mtf.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_view_single_field[backend=numpy]" time="0.036"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F56EF90&gt;
set_test_backend = None

    def test_view_single_field(self, set_test_backend):
        """Test view method with a single specified field."""
        optic = CookeTriplet()
&gt;       tfm = ThroughFocusMTF(
            optic,
            spatial_frequency=10.0,
            num_steps=5,
            num_rays=23,
            fields=[(0.0, 0.0)],  # Single field
        )

tests\test_through_focus_mtf.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_through_focus_mtf.TestThroughFocusMTF" name="test_view_single_field[backend=torch]" time="0.053"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_through_focus_mtf.TestThroughFocusMTF object at 0x000001478F56F210&gt;
set_test_backend = None

    def test_view_single_field(self, set_test_backend):
        """Test view method with a single specified field."""
        optic = CookeTriplet()
&gt;       tfm = ThroughFocusMTF(
            optic,
            spatial_frequency=10.0,
            num_steps=5,
            num_rays=23,
            fields=[(0.0, 0.0)],  # Single field
        )

tests\test_through_focus_mtf.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\analysis\through_focus_mtf.py:75: in __init__
    super().__init__(
optiland\analysis\through_focus.py:67: in __init__
    self._calculate_through_focus()
optiland\analysis\through_focus.py:145: in _calculate_through_focus
    result = self._perform_analysis_at_focus()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\analysis\through_focus_mtf.py:100: in _perform_analysis_at_focus
    sampled_mtf = SampledMTF(
optiland\mtf\sampled.py:80: in __init__
    wf = Wavefront(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_tolerancing" name="test_init[backend=numpy]" time="0.011" /><testcase classname="tests.test_tolerancing" name="test_init[backend=torch]" time="0.011" /><testcase classname="tests.test_tolerancing" name="test_add_operand[backend=numpy]" time="0.014" /><testcase classname="tests.test_tolerancing" name="test_add_operand[backend=torch]" time="0.016" /><testcase classname="tests.test_tolerancing" name="test_add_operand_no_target[backend=numpy]" time="0.013" /><testcase classname="tests.test_tolerancing" name="test_add_operand_no_target[backend=torch]" time="0.019" /><testcase classname="tests.test_tolerancing" name="test_add_perturbation[backend=numpy]" time="0.011" /><testcase classname="tests.test_tolerancing" name="test_add_perturbation[backend=torch]" time="0.012" /><testcase classname="tests.test_tolerancing" name="test_add_compensator[backend=numpy]" time="0.011" /><testcase classname="tests.test_tolerancing" name="test_add_compensator[backend=torch]" time="0.011" /><testcase classname="tests.test_tolerancing" name="test_apply_compensators[backend=numpy]" time="0.025" /><testcase classname="tests.test_tolerancing" name="test_apply_compensators[backend=torch]" time="0.070" /><testcase classname="tests.test_tolerancing" name="test_evaluate[backend=numpy]" time="0.012" /><testcase classname="tests.test_tolerancing" name="test_evaluate[backend=torch]" time="0.022" /><testcase classname="tests.test_tolerancing" name="test_reset[backend=numpy]" time="0.011" /><testcase classname="tests.test_tolerancing" name="test_reset[backend=torch]" time="0.012" /><testcase classname="tests.test_torch_backend" name="test_set_and_get_device_cpu" time="0.001" /><testcase classname="tests.test_torch_backend" name="test_set_and_get_device_cuda" time="0.001" /><testcase classname="tests.test_torch_backend" name="test_set_device_invalid" time="0.001" /><testcase classname="tests.test_torch_backend" name="test_set_and_get_precision_float32" time="0.001" /><testcase classname="tests.test_torch_backend" name="test_set_and_get_precision_float64" time="0.001" /><testcase classname="tests.test_torch_backend" name="test_set_precision_invalid" time="0.000" /><testcase classname="tests.test_torch_backend" name="test_grad_mode_enable_disable" time="0.000" /><testcase classname="tests.test_torch_backend" name="test_grad_mode_temporary_enable" time="0.001" /><testcase classname="tests.test_torch_optimization.TestTorchBaseOptimizerSetup" name="test_init_raises_error_if_backend_not_torch" time="0.035" /><testcase classname="tests.test_torch_optimization.TestTorchBaseOptimizerSetup" name="test_init_enables_gradient_tracking_with_warning" time="0.036" /><testcase classname="tests.test_torch_optimization.TestTorchOptimizers" name="test_optimize_successfully_reduces_loss[TorchAdamOptimizer]" time="0.224" /><testcase classname="tests.test_torch_optimization.TestTorchOptimizers" name="test_optimize_successfully_reduces_loss[TorchSGDOptimizer]" time="0.253" /><testcase classname="tests.test_torch_optimization.TestTorchOptimizers" name="test_optimize_no_operands_returns_zero_loss[TorchAdamOptimizer]" time="0.047" /><testcase classname="tests.test_torch_optimization.TestTorchOptimizers" name="test_optimize_no_operands_returns_zero_loss[TorchSGDOptimizer]" time="0.045" /><testcase classname="tests.test_torch_optimization.TestTorchOptimizers" name="test_optimize_no_variables_raises_error[TorchAdamOptimizer]" time="0.043" /><testcase classname="tests.test_torch_optimization.TestTorchOptimizers" name="test_optimize_no_variables_raises_error[TorchSGDOptimizer]" time="0.040" /><testcase classname="tests.test_torch_optimization.TestTorchOptimizers" name="test_optimize_with_zero_steps_makes_no_change[TorchAdamOptimizer]" time="0.047" /><testcase classname="tests.test_torch_optimization.TestTorchOptimizers" name="test_optimize_with_zero_steps_makes_no_change[TorchSGDOptimizer]" time="0.045" /><testcase classname="tests.test_torch_optimization.TestTorchOptimizers" name="test_callback_is_invoked_at_each_step[TorchAdamOptimizer]" time="0.076" /><testcase classname="tests.test_torch_optimization.TestTorchOptimizers" name="test_callback_is_invoked_at_each_step[TorchSGDOptimizer]" time="0.075" /><testcase classname="tests.test_torch_optimization.TestTorchOptimizers" name="test_display_output_controlled_by_disp_flag[True-True-TorchAdamOptimizer]" time="0.042" /><testcase classname="tests.test_torch_optimization.TestTorchOptimizers" name="test_display_output_controlled_by_disp_flag[True-True-TorchSGDOptimizer]" time="0.046" /><testcase classname="tests.test_torch_optimization.TestTorchOptimizers" name="test_display_output_controlled_by_disp_flag[False-False-TorchAdamOptimizer]" time="0.043" /><testcase classname="tests.test_torch_optimization.TestTorchOptimizers" name="test_display_output_controlled_by_disp_flag[False-False-TorchSGDOptimizer]" time="0.042" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[radius]" time="0.003" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[conic]" time="0.003" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[grating_order]" time="0.002" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[grating_period]" time="0.002" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[groove_orientation_angle]" time="0.002" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[coefficients]" time="0.002" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[tol]" time="0.003" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[max_iter]" time="0.002" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[norm_x]" time="0.002" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[norm_y]" time="0.002" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[norm_radius]" time="0.002" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[radius_x]" time="0.002" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[radius_y]" time="0.003" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[conic_x]" time="0.003" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[conic_y]" time="0.002" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[toroidal_coeffs_poly_y]" time="0.002" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[zernike_type]" time="0.002" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[radial_terms]" time="0.002" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_geometry_config_field_in_surface_parameters[freeform_coeffs]" time="0.002" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[radius]" time="0.005" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[conic]" time="0.006" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[grating_order]" time="0.005" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[grating_period]" time="0.006" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[groove_orientation_angle]" time="0.006" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[coefficients]" time="0.005" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[tol]" time="0.007" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[max_iter]" time="0.005" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[norm_x]" time="0.007" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[norm_y]" time="0.006" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[norm_radius]" time="0.006" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[radius_x]" time="0.005" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[radius_y]" time="0.004" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[conic_x]" time="0.006" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[conic_y]" time="0.005" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[toroidal_coeffs_poly_y]" time="0.004" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[zernike_type]" time="0.006" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[radial_terms]" time="0.006" /><testcase classname="tests.test_types.TestSurfaceParameters" name="test_equal_geometry_field_types[freeform_coeffs]" time="0.009" /><testcase classname="tests.test_utils" name="test_resolve_wavelengths_all" time="0.001" /><testcase classname="tests.test_utils" name="test_resolve_wavelengths_primary" time="0.001" /><testcase classname="tests.test_utils" name="test_resolve_wavelengths_list" time="0.001" /><testcase classname="tests.test_utils" name="test_resolve_wavelengths_invalid_string" time="0.001" /><testcase classname="tests.test_utils" name="test_resolve_wavelengths_invalid_type" time="0.001" /><testcase classname="tests.test_utils" name="test_resolve_fields_all" time="0.001" /><testcase classname="tests.test_utils" name="test_resolve_fields_list" time="0.001" /><testcase classname="tests.test_utils" name="test_resolve_fields_invalid_string" time="0.001" /><testcase classname="tests.test_utils" name="test_resolve_fields_invalid_type" time="0.001" /><testcase classname="tests.test_utils" name="test_resolve_wavelength_primary" time="0.001" /><testcase classname="tests.test_utils" name="test_resolve_wavelength_float" time="0.001" /><testcase classname="tests.test_utils" name="test_resolve_wavelength_int" time="0.001" /><testcase classname="tests.test_utils" name="test_resolve_wavelength_invalid_string" time="0.001" /><testcase classname="tests.test_utils" name="test_resolve_wavelength_invalid_type" time="0.001" /><testcase classname="tests.test_variable.TestRadiusVariable" name="test_get_value[backend=numpy]" time="0.112" /><testcase classname="tests.test_variable.TestRadiusVariable" name="test_get_value[backend=torch]" time="0.103" /><testcase classname="tests.test_variable.TestRadiusVariable" name="test_update_value[backend=numpy]" time="0.103" /><testcase classname="tests.test_variable.TestRadiusVariable" name="test_update_value[backend=torch]" time="0.098" /><testcase classname="tests.test_variable.TestReciprocalRadiusVariable" name="test_get_value[backend=numpy]" time="0.014" /><testcase classname="tests.test_variable.TestReciprocalRadiusVariable" name="test_get_value[backend=torch]" time="0.012" /><testcase classname="tests.test_variable.TestReciprocalRadiusVariable" name="test_update_value[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestReciprocalRadiusVariable" name="test_update_value[backend=torch]" time="0.013" /><testcase classname="tests.test_variable.TestReciprocalRadiusVariable" name="test_get_value_infinity[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestReciprocalRadiusVariable" name="test_get_value_infinity[backend=torch]" time="0.012" /><testcase classname="tests.test_variable.TestReciprocalRadiusVariable" name="test_update_value_zero[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestReciprocalRadiusVariable" name="test_update_value_zero[backend=torch]" time="0.012" /><testcase classname="tests.test_variable.TestReciprocalRadiusVariable" name="test_optimization" time="0.015"><failure message="IndexError: index 3 is out of bounds for axis 0 with size 3">self = &lt;tests.test_variable.TestReciprocalRadiusVariable object at 0x000001478F5F9D50&gt;

    def test_optimization(self):
        self.problem.add_variable(self.optic, "reciprocal_radius", surface_number=1)
&gt;       optimizer = OptimizerGeneric(self.problem)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_variable.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optimization\optimizer\scipy\base.py:54: in __init__
    self.problem.initial_value = self.problem.sum_squared()
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optimization\problem.py:109: in sum_squared
    return be.sum(self.fun_array())
                  ^^^^^^^^^^^^^^^^
optiland\optimization\problem.py:102: in fun_array
    terms = [op.fun() for op in self.operands]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optimization\problem.py:102: in &lt;listcomp&gt;
    terms = [op.fun() for op in self.operands]
             ^^^^^^^^
optiland\optimization\operand\operand.py:236: in fun
    return self.weight * self.delta()
                         ^^^^^^^^^^^^
optiland\optimization\operand\operand.py:229: in delta
    return self.delta_target()
           ^^^^^^^^^^^^^^^^^^^
optiland\optimization\operand\operand.py:213: in delta_target
    return self.value - self.target
           ^^^^^^^^^^
optiland\optimization\operand\operand.py:208: in value
    return metric_function(**self.input_data)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

optic = &lt;optiland.samples.simple.Edmund_49_847 object at 0x0000014796B3E610&gt;
surface_number = 3, Hx = 0.0, Hy = 0.0, num_rays = 5, wavelength = 0.5875618
distribution = 'hexapolar'

    @staticmethod
    def rms_spot_size(
        optic,
        surface_number,
        Hx,
        Hy,
        num_rays,
        wavelength,
        distribution="hexapolar",
    ):
        """Calculates the root mean square (RMS) spot size on a specific surface.
    
        Args:
            optic: The optic object.
            surface_number: The number of the surface.
            Hx: The normalized x field coordinate.
            Hy: The normalized y field coordinate.
            num_rays: The number of rays to trace.
            wavelength: The wavelength of the rays.
            distribution: The distribution of the rays. Default is 'hexapolar'.
    
        Returns:
            The RMS spot size on the specified surface.
    
        """
        if wavelength == "all":
            x = []
            y = []
            for wave in optic.wavelengths.get_wavelengths():
                optic.trace(Hx, Hy, wave, num_rays, distribution)
                x.append(optic.surface_group.x[surface_number, :].flatten())
                y.append(optic.surface_group.y[surface_number, :].flatten())
            wave_idx = optic.wavelengths.primary_index
            mean_x = be.mean(x[wave_idx])
            mean_y = be.mean(y[wave_idx])
            r2 = [(x[i] - mean_x) ** 2 + (y[i] - mean_y) ** 2 for i in range(len(x))]
            return be.sqrt(be.mean(be.concatenate(r2)))
        optic.trace(Hx, Hy, wavelength, num_rays, distribution)
&gt;       x = optic.surface_group.x[surface_number, :].flatten()
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       IndexError: index 3 is out of bounds for axis 0 with size 3

optiland\optimization\operand\ray.py:330: IndexError</failure></testcase><testcase classname="tests.test_variable.TestReciprocalRadiusVariable" name="test_optimization_with_flat_surface" time="0.014"><failure message="IndexError: index 3 is out of bounds for axis 0 with size 3">self = &lt;tests.test_variable.TestReciprocalRadiusVariable object at 0x000001478F5FA390&gt;

    def test_optimization_with_flat_surface(self):
        self.problem.add_variable(self.optic, "reciprocal_radius", surface_number=1)
        self.optic.set_radius(-be.inf, 1)
&gt;       optimizer = OptimizerGeneric(self.problem)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_variable.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optimization\optimizer\scipy\base.py:54: in __init__
    self.problem.initial_value = self.problem.sum_squared()
                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optimization\problem.py:109: in sum_squared
    return be.sum(self.fun_array())
                  ^^^^^^^^^^^^^^^^
optiland\optimization\problem.py:102: in fun_array
    terms = [op.fun() for op in self.operands]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optimization\problem.py:102: in &lt;listcomp&gt;
    terms = [op.fun() for op in self.operands]
             ^^^^^^^^
optiland\optimization\operand\operand.py:236: in fun
    return self.weight * self.delta()
                         ^^^^^^^^^^^^
optiland\optimization\operand\operand.py:229: in delta
    return self.delta_target()
           ^^^^^^^^^^^^^^^^^^^
optiland\optimization\operand\operand.py:213: in delta_target
    return self.value - self.target
           ^^^^^^^^^^
optiland\optimization\operand\operand.py:208: in value
    return metric_function(**self.input_data)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

optic = &lt;optiland.samples.simple.Edmund_49_847 object at 0x0000014796801110&gt;
surface_number = 3, Hx = 0.0, Hy = 0.0, num_rays = 5, wavelength = 0.5875618
distribution = 'hexapolar'

    @staticmethod
    def rms_spot_size(
        optic,
        surface_number,
        Hx,
        Hy,
        num_rays,
        wavelength,
        distribution="hexapolar",
    ):
        """Calculates the root mean square (RMS) spot size on a specific surface.
    
        Args:
            optic: The optic object.
            surface_number: The number of the surface.
            Hx: The normalized x field coordinate.
            Hy: The normalized y field coordinate.
            num_rays: The number of rays to trace.
            wavelength: The wavelength of the rays.
            distribution: The distribution of the rays. Default is 'hexapolar'.
    
        Returns:
            The RMS spot size on the specified surface.
    
        """
        if wavelength == "all":
            x = []
            y = []
            for wave in optic.wavelengths.get_wavelengths():
                optic.trace(Hx, Hy, wave, num_rays, distribution)
                x.append(optic.surface_group.x[surface_number, :].flatten())
                y.append(optic.surface_group.y[surface_number, :].flatten())
            wave_idx = optic.wavelengths.primary_index
            mean_x = be.mean(x[wave_idx])
            mean_y = be.mean(y[wave_idx])
            r2 = [(x[i] - mean_x) ** 2 + (y[i] - mean_y) ** 2 for i in range(len(x))]
            return be.sqrt(be.mean(be.concatenate(r2)))
        optic.trace(Hx, Hy, wavelength, num_rays, distribution)
&gt;       x = optic.surface_group.x[surface_number, :].flatten()
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       IndexError: index 3 is out of bounds for axis 0 with size 3

optiland\optimization\operand\ray.py:330: IndexError</failure></testcase><testcase classname="tests.test_variable.TestConicVariable" name="test_get_value[backend=numpy]" time="0.015" /><testcase classname="tests.test_variable.TestConicVariable" name="test_get_value[backend=torch]" time="0.016" /><testcase classname="tests.test_variable.TestConicVariable" name="test_update_value[backend=numpy]" time="0.015" /><testcase classname="tests.test_variable.TestConicVariable" name="test_update_value[backend=torch]" time="0.015" /><testcase classname="tests.test_variable.TestConicVariable" name="test_string_representation[backend=numpy]" time="0.015" /><testcase classname="tests.test_variable.TestConicVariable" name="test_string_representation[backend=torch]" time="0.015" /><testcase classname="tests.test_variable.TestThicknessVariable" name="test_get_value[backend=numpy]" time="0.098" /><testcase classname="tests.test_variable.TestThicknessVariable" name="test_get_value[backend=torch]" time="0.099" /><testcase classname="tests.test_variable.TestThicknessVariable" name="test_update_value[backend=numpy]" time="0.114" /><testcase classname="tests.test_variable.TestThicknessVariable" name="test_update_value[backend=torch]" time="0.110" /><testcase classname="tests.test_variable.TestThicknessVariable" name="test_get_value_no_scaling[backend=numpy]" time="0.193" /><testcase classname="tests.test_variable.TestThicknessVariable" name="test_get_value_no_scaling[backend=torch]" time="0.196" /><testcase classname="tests.test_variable.TestIndexVariable" name="test_get_value[backend=numpy]" time="0.096" /><testcase classname="tests.test_variable.TestIndexVariable" name="test_get_value[backend=torch]" time="0.099" /><testcase classname="tests.test_variable.TestIndexVariable" name="test_update_value[backend=numpy]" time="0.092" /><testcase classname="tests.test_variable.TestIndexVariable" name="test_update_value[backend=torch]" time="0.093" /><testcase classname="tests.test_variable.TestIndexVariable" name="test_get_value_no_scaling[backend=numpy]" time="0.203" /><testcase classname="tests.test_variable.TestIndexVariable" name="test_get_value_no_scaling[backend=torch]" time="0.203" /><testcase classname="tests.test_variable.TestIndexVariable" name="test_string_representation[backend=numpy]" time="0.099" /><testcase classname="tests.test_variable.TestIndexVariable" name="test_string_representation[backend=torch]" time="0.095" /><testcase classname="tests.test_variable.TestMaterialVariable" name="test_get_value[backend=numpy]" time="0.096" /><testcase classname="tests.test_variable.TestMaterialVariable" name="test_get_value[backend=torch]" time="0.096" /><testcase classname="tests.test_variable.TestMaterialVariable" name="test_update_value[backend=numpy]" time="0.107" /><testcase classname="tests.test_variable.TestMaterialVariable" name="test_update_value[backend=torch]" time="0.104" /><testcase classname="tests.test_variable.TestMaterialVariable" name="test_string_representation[backend=numpy]" time="0.110" /><testcase classname="tests.test_variable.TestMaterialVariable" name="test_string_representation[backend=torch]" time="0.102" /><testcase classname="tests.test_variable.TestMaterialVariable" name="test_init_with_abbe_material" time="0.130" /><testcase classname="tests.test_variable.TestAsphereCoeffVariable" name="test_get_value[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestAsphereCoeffVariable" name="test_get_value[backend=torch]" time="0.012" /><testcase classname="tests.test_variable.TestAsphereCoeffVariable" name="test_update_value[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestAsphereCoeffVariable" name="test_update_value[backend=torch]" time="0.011" /><testcase classname="tests.test_variable.TestAsphereCoeffVariable" name="test_get_value_no_scaling[backend=numpy]" time="0.025" /><testcase classname="tests.test_variable.TestAsphereCoeffVariable" name="test_get_value_no_scaling[backend=torch]" time="0.022" /><testcase classname="tests.test_variable.TestAsphereCoeffVariable" name="test_string_representation[backend=numpy]" time="0.011" /><testcase classname="tests.test_variable.TestAsphereCoeffVariable" name="test_string_representation[backend=torch]" time="0.012" /><testcase classname="tests.test_variable.TestPolynomialCoeffVariable" name="test_get_value[backend=numpy]" time="0.013" /><testcase classname="tests.test_variable.TestPolynomialCoeffVariable" name="test_get_value[backend=torch]" time="0.012" /><testcase classname="tests.test_variable.TestPolynomialCoeffVariable" name="test_update_value[backend=numpy]" time="0.013" /><testcase classname="tests.test_variable.TestPolynomialCoeffVariable" name="test_update_value[backend=torch]" time="0.012" /><testcase classname="tests.test_variable.TestPolynomialCoeffVariable" name="test_get_value_index_error[backend=numpy]" time="0.021" /><testcase classname="tests.test_variable.TestPolynomialCoeffVariable" name="test_get_value_index_error[backend=torch]" time="0.026" /><testcase classname="tests.test_variable.TestPolynomialCoeffVariable" name="test_update_value_index_error[backend=numpy]" time="0.022" /><testcase classname="tests.test_variable.TestPolynomialCoeffVariable" name="test_update_value_index_error[backend=torch]" time="0.024" /><testcase classname="tests.test_variable.TestPolynomialCoeffVariable" name="test_string_representation[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestPolynomialCoeffVariable" name="test_string_representation[backend=torch]" time="0.010" /><testcase classname="tests.test_variable.TestPolynomialCoeffVariable" name="test_get_value_no_scaling[backend=numpy]" time="0.023" /><testcase classname="tests.test_variable.TestPolynomialCoeffVariable" name="test_get_value_no_scaling[backend=torch]" time="0.023" /><testcase classname="tests.test_variable.TestChebyshevCoeffVariable" name="test_get_value[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestChebyshevCoeffVariable" name="test_get_value[backend=torch]" time="0.012" /><testcase classname="tests.test_variable.TestChebyshevCoeffVariable" name="test_update_value[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestChebyshevCoeffVariable" name="test_update_value[backend=torch]" time="0.012" /><testcase classname="tests.test_variable.TestChebyshevCoeffVariable" name="test_get_value_index_error[backend=numpy]" time="0.024" /><testcase classname="tests.test_variable.TestChebyshevCoeffVariable" name="test_get_value_index_error[backend=torch]" time="0.023" /><testcase classname="tests.test_variable.TestChebyshevCoeffVariable" name="test_update_value_index_error[backend=numpy]" time="0.023" /><testcase classname="tests.test_variable.TestChebyshevCoeffVariable" name="test_update_value_index_error[backend=torch]" time="0.022" /><testcase classname="tests.test_variable.TestChebyshevCoeffVariable" name="test_string_representation[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestChebyshevCoeffVariable" name="test_string_representation[backend=torch]" time="0.011" /><testcase classname="tests.test_variable.TestZernikeCoeffVariable" name="test_get_value[backend=numpy]" time="0.011" /><testcase classname="tests.test_variable.TestZernikeCoeffVariable" name="test_get_value[backend=torch]" time="0.011" /><testcase classname="tests.test_variable.TestZernikeCoeffVariable" name="test_update_value[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestZernikeCoeffVariable" name="test_update_value[backend=torch]" time="0.011" /><testcase classname="tests.test_variable.TestZernikeCoeffVariable" name="test_get_value_index_error[backend=numpy]" time="0.021" /><testcase classname="tests.test_variable.TestZernikeCoeffVariable" name="test_get_value_index_error[backend=torch]" time="0.023" /><testcase classname="tests.test_variable.TestZernikeCoeffVariable" name="test_update_value_index_error[backend=numpy]" time="0.022" /><testcase classname="tests.test_variable.TestZernikeCoeffVariable" name="test_update_value_index_error[backend=torch]" time="0.026" /><testcase classname="tests.test_variable.TestZernikeCoeffVariable" name="test_string_representation[backend=numpy]" time="0.011" /><testcase classname="tests.test_variable.TestZernikeCoeffVariable" name="test_string_representation[backend=torch]" time="0.018" /><testcase classname="tests.test_variable.TestVariable" name="test_get_value[backend=numpy]" time="0.102" /><testcase classname="tests.test_variable.TestVariable" name="test_get_value[backend=torch]" time="0.106" /><testcase classname="tests.test_variable.TestVariable" name="test_unrecognized_attribute" time="0.095" /><testcase classname="tests.test_variable.TestVariable" name="test_invalid_type[backend=numpy]" time="0.097" /><testcase classname="tests.test_variable.TestVariable" name="test_invalid_type[backend=torch]" time="0.097" /><testcase classname="tests.test_variable.TestTiltVariable" name="test_get_value_x[backend=numpy]" time="0.095" /><testcase classname="tests.test_variable.TestTiltVariable" name="test_get_value_x[backend=torch]" time="0.101" /><testcase classname="tests.test_variable.TestTiltVariable" name="test_get_value_y[backend=numpy]" time="0.134" /><testcase classname="tests.test_variable.TestTiltVariable" name="test_get_value_y[backend=torch]" time="0.115" /><testcase classname="tests.test_variable.TestTiltVariable" name="test_update_value_x[backend=numpy]" time="0.132" /><testcase classname="tests.test_variable.TestTiltVariable" name="test_update_value_x[backend=torch]" time="0.126" /><testcase classname="tests.test_variable.TestTiltVariable" name="test_update_value_y[backend=numpy]" time="0.161" /><testcase classname="tests.test_variable.TestTiltVariable" name="test_update_value_y[backend=torch]" time="0.132" /><testcase classname="tests.test_variable.TestTiltVariable" name="test_invalid_axis[backend=numpy]" time="0.162" /><testcase classname="tests.test_variable.TestTiltVariable" name="test_invalid_axis[backend=torch]" time="0.131" /><testcase classname="tests.test_variable.TestTiltVariable" name="test_str[backend=numpy]" time="0.119" /><testcase classname="tests.test_variable.TestTiltVariable" name="test_str[backend=torch]" time="0.126" /><testcase classname="tests.test_variable.TestTiltVariable" name="test_get_value_no_scaling[backend=numpy]" time="0.242" /><testcase classname="tests.test_variable.TestTiltVariable" name="test_get_value_no_scaling[backend=torch]" time="0.228" /><testcase classname="tests.test_variable.TestDecenterVariable" name="test_get_value_x[backend=numpy]" time="0.109" /><testcase classname="tests.test_variable.TestDecenterVariable" name="test_get_value_x[backend=torch]" time="0.108" /><testcase classname="tests.test_variable.TestDecenterVariable" name="test_get_value_y[backend=numpy]" time="0.103" /><testcase classname="tests.test_variable.TestDecenterVariable" name="test_get_value_y[backend=torch]" time="0.105" /><testcase classname="tests.test_variable.TestDecenterVariable" name="test_update_value_x[backend=numpy]" time="0.111" /><testcase classname="tests.test_variable.TestDecenterVariable" name="test_update_value_x[backend=torch]" time="0.117" /><testcase classname="tests.test_variable.TestDecenterVariable" name="test_update_value_y[backend=numpy]" time="0.108" /><testcase classname="tests.test_variable.TestDecenterVariable" name="test_update_value_y[backend=torch]" time="0.108" /><testcase classname="tests.test_variable.TestDecenterVariable" name="test_invalid_axis[backend=numpy]" time="0.107" /><testcase classname="tests.test_variable.TestDecenterVariable" name="test_invalid_axis[backend=torch]" time="0.110" /><testcase classname="tests.test_variable.TestDecenterVariable" name="test_str[backend=numpy]" time="0.106" /><testcase classname="tests.test_variable.TestDecenterVariable" name="test_str[backend=torch]" time="0.106" /><testcase classname="tests.test_variable.TestDecenterVariable" name="test_get_value_no_scaling[backend=numpy]" time="0.208" /><testcase classname="tests.test_variable.TestDecenterVariable" name="test_get_value_no_scaling[backend=torch]" time="0.219" /><testcase classname="tests.test_variable.TestNormalizationRadiusVariable" name="test_get_value[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestNormalizationRadiusVariable" name="test_get_value[backend=torch]" time="0.014" /><testcase classname="tests.test_variable.TestNormalizationRadiusVariable" name="test_update_value[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestNormalizationRadiusVariable" name="test_update_value[backend=torch]" time="0.013" /><testcase classname="tests.test_variable.TestNormalizationRadiusVariable" name="test_string_representation[backend=numpy]" time="0.013" /><testcase classname="tests.test_variable.TestNormalizationRadiusVariable" name="test_string_representation[backend=torch]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQbfsCoeffVariable" name="test_get_value[backend=numpy]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQbfsCoeffVariable" name="test_get_value[backend=torch]" time="0.015" /><testcase classname="tests.test_variable.TestForbesQbfsCoeffVariable" name="test_update_value[backend=numpy]" time="0.014" /><testcase classname="tests.test_variable.TestForbesQbfsCoeffVariable" name="test_update_value[backend=torch]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQbfsCoeffVariable" name="test_update_value_out_of_bounds[backend=numpy]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQbfsCoeffVariable" name="test_update_value_out_of_bounds[backend=torch]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQbfsCoeffVariable" name="test_string_representation[backend=numpy]" time="0.015" /><testcase classname="tests.test_variable.TestForbesQbfsCoeffVariable" name="test_string_representation[backend=torch]" time="0.014" /><testcase classname="tests.test_variable.TestForbesQbfsCoeffVariable" name="test_get_value_nonexistent[backend=numpy]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQbfsCoeffVariable" name="test_get_value_nonexistent[backend=torch]" time="0.014" /><testcase classname="tests.test_variable.TestForbesQbfsCoeffVariable" name="test_scaling[backend=numpy]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQbfsCoeffVariable" name="test_scaling[backend=torch]" time="0.012" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_get_value[backend=numpy]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_get_value[backend=torch]" time="0.014" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_get_value_nonexistent[backend=numpy]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_get_value_nonexistent[backend=torch]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_update_value_existing[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_update_value_existing[backend=torch]" time="0.014" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_update_value__new[backend=numpy]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_update_value__new[backend=torch]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_string_representation[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_string_representation[backend=torch]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_invalid_coeff_tuple[backend=numpy]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_invalid_coeff_tuple[backend=torch]" time="0.013" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_get_and_update_sine_term[backend=numpy]" time="0.014" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_get_and_update_sine_term[backend=torch]" time="0.015" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_string_representation_sine[backend=numpy]" time="0.012" /><testcase classname="tests.test_variable.TestForbesQ2dCoeffVariable" name="test_string_representation_sine[backend=torch]" time="0.012" /><testcase classname="tests.test_variable.TestVariableManager" name="test_add[backend=numpy]" time="0.103" /><testcase classname="tests.test_variable.TestVariableManager" name="test_add[backend=torch]" time="0.105" /><testcase classname="tests.test_variable.TestVariableManager" name="test_clear[backend=numpy]" time="0.107" /><testcase classname="tests.test_variable.TestVariableManager" name="test_clear[backend=torch]" time="0.105" /><testcase classname="tests.test_variable.TestVariableManager" name="test_iter[backend=numpy]" time="0.108" /><testcase classname="tests.test_variable.TestVariableManager" name="test_iter[backend=torch]" time="0.108" /><testcase classname="tests.test_variable.TestVariableManager" name="test_getitem[backend=numpy]" time="0.107" /><testcase classname="tests.test_variable.TestVariableManager" name="test_getitem[backend=torch]" time="0.108" /><testcase classname="tests.test_variable.TestVariableManager" name="test_setitem[backend=numpy]" time="0.100" /><testcase classname="tests.test_variable.TestVariableManager" name="test_setitem[backend=torch]" time="0.107" /><testcase classname="tests.test_variable.TestVariableManager" name="test_len[backend=numpy]" time="0.097" /><testcase classname="tests.test_variable.TestVariableManager" name="test_len[backend=torch]" time="0.116" /><testcase classname="tests.test_variable.TestVariableManager" name="test_getitem_index_error[backend=numpy]" time="0.001" /><testcase classname="tests.test_variable.TestVariableManager" name="test_getitem_index_error[backend=torch]" time="0.001" /><testcase classname="tests.test_variable.TestVariableManager" name="test_setitem_index_error[backend=numpy]" time="0.109" /><testcase classname="tests.test_variable.TestVariableManager" name="test_setitem_index_error[backend=torch]" time="0.118" /><testcase classname="tests.test_variable.TestVariableManager" name="test_setitem_invalid_type[backend=numpy]" time="0.108" /><testcase classname="tests.test_variable.TestVariableManager" name="test_setitem_invalid_type[backend=torch]" time="0.114" /><testcase classname="tests.test_variable.TestVariableManager" name="test_iterable[backend=numpy]" time="0.108" /><testcase classname="tests.test_variable.TestVariableManager" name="test_iterable[backend=torch]" time="0.119" /><testcase classname="tests.test_variable.TestVariableManager" name="test_delitem[backend=numpy]" time="0.114" /><testcase classname="tests.test_variable.TestVariableManager" name="test_delitem[backend=torch]" time="0.113" /><testcase classname="tests.test_visualization.TestBaseViewer" name="test_instantiating_subclass_without_view_raises_error[backend=numpy]" time="0.001" /><testcase classname="tests.test_visualization.TestBaseViewer" name="test_instantiating_subclass_without_view_raises_error[backend=torch]" time="0.001" /><testcase classname="tests.test_visualization.TestOpticViewer" name="test_init" time="0.057" /><testcase classname="tests.test_visualization.TestOpticViewer" name="test_view[backend=numpy]" time="0.096"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F69F250&gt;
set_test_backend = None

    def test_view(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer(lens)
&gt;       fig, ax = viewer.view()
                  ^^^^^^^^^^^^^

tests\test_visualization.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x00000147977DEE90&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_view[backend=torch]" time="0.134"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F69F4D0&gt;
set_test_backend = None

    def test_view(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer(lens)
&gt;       fig, ax = viewer.view()
                  ^^^^^^^^^^^^^

tests\test_visualization.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014798FFB890&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_view_from_optic[backend=numpy]" time="0.094"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6A0110&gt;
set_test_backend = None

    def test_view_from_optic(self, set_test_backend):
        lens = ReverseTelephoto()
&gt;       fig, ax = lens.draw()
                  ^^^^^^^^^^^

tests\test_visualization.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014799048110&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_view_from_optic[backend=torch]" time="0.123"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6A0390&gt;
set_test_backend = None

    def test_view_from_optic(self, set_test_backend):
        lens = ReverseTelephoto()
&gt;       fig, ax = lens.draw()
                  ^^^^^^^^^^^

tests\test_visualization.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014795F15A10&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_view_bonded_lens[backend=numpy]" time="0.070"><failure message="IndexError: index 9 is out of bounds for axis 0 with size 9">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6A0F10&gt;
set_test_backend = None

    def test_view_bonded_lens(self, set_test_backend):
        lens = TessarLens()
&gt;       fig, ax = lens.draw()
                  ^^^^^^^^^^^

tests\test_visualization.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014797510B90&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 9 is out of bounds for axis 0 with size 9

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_view_bonded_lens[backend=torch]" time="0.098"><failure message="IndexError: index 9 is out of bounds for dimension 0 with size 9">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6A1190&gt;
set_test_backend = None

    def test_view_bonded_lens(self, set_test_backend):
        lens = TessarLens()
&gt;       fig, ax = lens.draw()
                  ^^^^^^^^^^^

tests\test_visualization.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014798D1BAD0&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 9 is out of bounds for dimension 0 with size 9

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_view_reflective_lens[backend=numpy]" time="0.012"><failure message="IndexError: index 4 is out of bounds for axis 0 with size 4">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6A1D10&gt;
set_test_backend = None

    def test_view_reflective_lens(self, set_test_backend):
        lens = HubbleTelescope()
&gt;       fig, ax = lens.draw()
                  ^^^^^^^^^^^

tests\test_visualization.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x000001479EC2F910&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 4 is out of bounds for axis 0 with size 4

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_view_reflective_lens[backend=torch]" time="0.021"><failure message="IndexError: index 4 is out of bounds for dimension 0 with size 4">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6A1F90&gt;
set_test_backend = None

    def test_view_reflective_lens(self, set_test_backend):
        lens = HubbleTelescope()
&gt;       fig, ax = lens.draw()
                  ^^^^^^^^^^^

tests\test_visualization.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x00000147975BC910&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 4 is out of bounds for dimension 0 with size 4

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_view_single_field[backend=numpy]" time="0.095"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6A2AD0&gt;
set_test_backend = None

    def test_view_single_field(self, set_test_backend):
        lens = ReverseTelephoto()
        lens.fields = fields.FieldGroup()
        lens.set_field_type(field_type="angle")
        lens.add_field(y=0)
&gt;       fig, ax = lens.draw()
                  ^^^^^^^^^^^

tests\test_visualization.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014798D541D0&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_view_single_field[backend=torch]" time="0.125"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6A2D50&gt;
set_test_backend = None

    def test_view_single_field(self, set_test_backend):
        lens = ReverseTelephoto()
        lens.fields = fields.FieldGroup()
        lens.set_field_type(field_type="angle")
        lens.add_field(y=0)
&gt;       fig, ax = lens.draw()
                  ^^^^^^^^^^^

tests\test_visualization.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014798D45F50&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_reference_chief_and_bundle[backend=numpy]" time="0.360"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6A38D0&gt;
set_test_backend = None

    def test_reference_chief_and_bundle(self, set_test_backend):
        lens = ReverseTelephoto()
&gt;       fig, ax = lens.draw(reference="chief")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_visualization.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014795E46950&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_reference_chief_and_bundle[backend=torch]" time="0.123"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6A3B50&gt;
set_test_backend = None

    def test_reference_chief_and_bundle(self, set_test_backend):
        lens = ReverseTelephoto()
&gt;       fig, ax = lens.draw(reference="chief")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_visualization.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014795E1D050&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_reference_marginal_and_bundle[backend=numpy]" time="0.088"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6AC710&gt;
set_test_backend = None

    def test_reference_marginal_and_bundle(self, set_test_backend):
        lens = ReverseTelephoto()
&gt;       fig, ax = lens.draw(reference="marginal")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_visualization.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x00000147977DDC10&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_reference_marginal_and_bundle[backend=torch]" time="0.121"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6AC990&gt;
set_test_backend = None

    def test_reference_marginal_and_bundle(self, set_test_backend):
        lens = ReverseTelephoto()
&gt;       fig, ax = lens.draw(reference="marginal")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_visualization.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014798CAD390&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_invalid_reference[backend=numpy]" time="0.093"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6AD510&gt;
set_test_backend = None

    def test_invalid_reference(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer(lens)
        with pytest.raises(ValueError):
&gt;           viewer.view(reference="invalid")

tests\test_visualization.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014796FBCCD0&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_invalid_reference[backend=torch]" time="0.132"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6AD790&gt;
set_test_backend = None

    def test_invalid_reference(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer(lens)
        with pytest.raises(ValueError):
&gt;           viewer.view(reference="invalid")

tests\test_visualization.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x000001479F0DC790&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_reference_chief_only[backend=numpy]" time="0.093"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6AE310&gt;
set_test_backend = None

    def test_reference_chief_only(self, set_test_backend):
        lens = ReverseTelephoto()
&gt;       fig, ax = lens.draw(reference="chief", distribution=None)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_visualization.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:83: in plot
    self._trace(field, wavelength, num_rays, "line_y")
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014795E4A390&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_reference_chief_only[backend=torch]" time="0.129"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6A0690&gt;
set_test_backend = None

    def test_reference_chief_only(self, set_test_backend):
        lens = ReverseTelephoto()
&gt;       fig, ax = lens.draw(reference="chief", distribution=None)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_visualization.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:83: in plot
    self._trace(field, wavelength, num_rays, "line_y")
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x000001479A7D7A90&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_reference_marginal_only[backend=numpy]" time="0.099"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6AE650&gt;
set_test_backend = None

    def test_reference_marginal_only(self, set_test_backend):
        lens = ReverseTelephoto()
&gt;       fig, ax = lens.draw(reference="marginal", distribution=None)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_visualization.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:83: in plot
    self._trace(field, wavelength, num_rays, "line_y")
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014798D68510&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_reference_marginal_only[backend=torch]" time="0.155"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6AE790&gt;
set_test_backend = None

    def test_reference_marginal_only(self, set_test_backend):
        lens = ReverseTelephoto()
&gt;       fig, ax = lens.draw(reference="marginal", distribution=None)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_visualization.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:83: in plot
    self._trace(field, wavelength, num_rays, "line_y")
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014794D7A2D0&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_plot_content_is_generated[backend=numpy]" time="0.164"><failure message="IndexError: index 9 is out of bounds for axis 0 with size 9">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6AEE90&gt;
set_test_backend = None

    def test_plot_content_is_generated(self, set_test_backend):
        """Verify that rays and lens polygons are actually added to the plot."""
        lens = TessarLens()
&gt;       fig, ax = lens.draw(num_rays=5)
                  ^^^^^^^^^^^^^^^^^^^^^

tests\test_visualization.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014795ED7190&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 9 is out of bounds for axis 0 with size 9

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_plot_content_is_generated[backend=torch]" time="0.139"><failure message="IndexError: index 9 is out of bounds for dimension 0 with size 9">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6AEFD0&gt;
set_test_backend = None

    def test_plot_content_is_generated(self, set_test_backend):
        """Verify that rays and lens polygons are actually added to the plot."""
        lens = TessarLens()
&gt;       fig, ax = lens.draw(num_rays=5)
                  ^^^^^^^^^^^^^^^^^^^^^

tests\test_visualization.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\optic\optic.py:491: in draw
    fig, ax = viewer.view(
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014795E24090&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 9 is out of bounds for dimension 0 with size 9

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_view_with_custom_plot_parameters[backend=numpy]" time="0.063"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6AF710&gt;
set_test_backend = None

    def test_view_with_custom_plot_parameters(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer(lens)
        custom_title = "Custom Test Title"
        custom_xlim = (-10, 100)
        custom_ylim = (-25, 25)
    
&gt;       fig, ax = viewer.view(title=custom_title, xlim=custom_xlim, ylim=custom_ylim)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_visualization.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x00000147974F2050&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_view_with_custom_plot_parameters[backend=torch]" time="0.073"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6AF910&gt;
set_test_backend = None

    def test_view_with_custom_plot_parameters(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer(lens)
        custom_title = "Custom Test Title"
        custom_xlim = (-10, 100)
        custom_ylim = (-25, 25)
    
&gt;       fig, ax = viewer.view(title=custom_title, xlim=custom_xlim, ylim=custom_ylim)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_visualization.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014796FEBD10&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_view_all_wavelengths[backend=numpy]" time="0.053"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6B0310&gt;
set_test_backend = None

    def test_view_all_wavelengths(self, set_test_backend):
        lens = ReverseTelephoto()
        # Add a second wavelength to test "all"
        lens.add_wavelength(value=0.65)
        viewer = OpticViewer(lens)
&gt;       fig, ax = viewer.view(wavelengths="all")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_visualization.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014798C22B90&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer" name="test_view_all_wavelengths[backend=torch]" time="0.075"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer object at 0x000001478F6B0590&gt;
set_test_backend = None

    def test_view_all_wavelengths(self, set_test_backend):
        lens = ReverseTelephoto()
        # Add a second wavelength to test "all"
        lens.add_wavelength(value=0.65)
        viewer = OpticViewer(lens)
&gt;       fig, ax = viewer.view(wavelengths="all")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_visualization.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer.py:79: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays2D object at 0x0000014795FE2810&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_init[backend=numpy]" time="0.174" /><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_init[backend=torch]" time="0.072" /><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view[backend=numpy]" time="0.093"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6B1FD0&gt;
set_test_backend = None

    def test_view(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view()

tests\test_visualization.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x0000014798BE0950&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view[backend=torch]" time="0.110"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6B2250&gt;
set_test_backend = None

    def test_view(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view()

tests\test_visualization.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x0000014794DBE110&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_asymmetric[backend=numpy]" time="0.089"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6B2E10&gt;
set_test_backend = None

    def test_view_asymmetric(self, set_test_backend):
        lens = ReverseTelephoto()
        lens.surface_group.surfaces[1].geometry.is_symmetric = False
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view()

tests\test_visualization.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x00000147970B0490&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_asymmetric[backend=torch]" time="0.117"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6B3090&gt;
set_test_backend = None

    def test_view_asymmetric(self, set_test_backend):
        lens = ReverseTelephoto()
        lens.surface_group.surfaces[1].geometry.is_symmetric = False
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view()

tests\test_visualization.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x00000147990F3CD0&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_bonded_lens[backend=numpy]" time="0.082"><failure message="IndexError: index 9 is out of bounds for axis 0 with size 9">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6B3C10&gt;
set_test_backend = None

    def test_view_bonded_lens(self, set_test_backend):
        lens = TessarLens()
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view()

tests\test_visualization.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x0000014795E8A9D0&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 9 is out of bounds for axis 0 with size 9

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_bonded_lens[backend=torch]" time="0.156"><failure message="IndexError: index 9 is out of bounds for dimension 0 with size 9">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6B3E90&gt;
set_test_backend = None

    def test_view_bonded_lens(self, set_test_backend):
        lens = TessarLens()
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view()

tests\test_visualization.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x000001479A9B4990&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 9 is out of bounds for dimension 0 with size 9

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_reflective_lens[backend=numpy]" time="0.060"><failure message="IndexError: index 4 is out of bounds for axis 0 with size 4">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6B8A50&gt;
set_test_backend = None

    def test_view_reflective_lens(self, set_test_backend):
        lens = HubbleTelescope()
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view()

tests\test_visualization.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x000001479EC8DB10&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 4 is out of bounds for axis 0 with size 4

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_reflective_lens[backend=torch]" time="0.057"><failure message="IndexError: index 4 is out of bounds for dimension 0 with size 4">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6B8CD0&gt;
set_test_backend = None

    def test_view_reflective_lens(self, set_test_backend):
        lens = HubbleTelescope()
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view()

tests\test_visualization.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x0000014798D33310&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 4 is out of bounds for dimension 0 with size 4

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_single_field[backend=numpy]" time="0.094"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6B9810&gt;
set_test_backend = None

    def test_view_single_field(self, set_test_backend):
        lens = ReverseTelephoto()
        lens.fields = fields.FieldGroup()
        lens.set_field_type(field_type="angle")
        lens.add_field(y=0)
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view()

tests\test_visualization.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x0000014795E06F10&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_single_field[backend=torch]" time="0.118"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6B9A90&gt;
set_test_backend = None

    def test_view_single_field(self, set_test_backend):
        lens = ReverseTelephoto()
        lens.fields = fields.FieldGroup()
        lens.set_field_type(field_type="angle")
        lens.add_field(y=0)
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view()

tests\test_visualization.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x000001479769B7D0&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_non_symmetric[backend=numpy]" time="0.076" /><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_non_symmetric[backend=torch]" time="0.084" /><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_toroidal[backend=numpy]" time="0.051"><failure message="IndexError: index 3 is out of bounds for axis 0 with size 3">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6BB410&gt;
set_test_backend = None

    def test_view_toroidal(self, set_test_backend):
        cylindrical_lens = Optic()
        cylindrical_lens.add_surface(index=0, radius=be.inf, thickness=be.inf)
        cylindrical_lens.add_surface(
            index=1,
            thickness=7,
            radius_x=20,  # &lt;- radius: x radius of rotation.
            radius_y=25,
            is_stop=True,
            material="N-BK7",
            surface_type="toroidal",
            conic=0.0,
            coefficients=[],
        )
        cylindrical_lens.add_surface(index=2, thickness=65)
        cylindrical_lens.add_surface(index=3)
        cylindrical_lens.set_aperture(aperture_type="EPD", value=20.0)
        cylindrical_lens.set_field_type(field_type="angle")
        cylindrical_lens.add_field(y=0)
        cylindrical_lens.add_wavelength(value=0.587, is_primary=True)
    
        viewer = OpticViewer3D(cylindrical_lens)
    
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view()

tests\test_visualization.py:302: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x0000014798D89910&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 3 is out of bounds for axis 0 with size 3

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_toroidal[backend=torch]" time="0.260"><failure message="IndexError: index 3 is out of bounds for dimension 0 with size 3">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6B0810&gt;
set_test_backend = None

    def test_view_toroidal(self, set_test_backend):
        cylindrical_lens = Optic()
        cylindrical_lens.add_surface(index=0, radius=be.inf, thickness=be.inf)
        cylindrical_lens.add_surface(
            index=1,
            thickness=7,
            radius_x=20,  # &lt;- radius: x radius of rotation.
            radius_y=25,
            is_stop=True,
            material="N-BK7",
            surface_type="toroidal",
            conic=0.0,
            coefficients=[],
        )
        cylindrical_lens.add_surface(index=2, thickness=65)
        cylindrical_lens.add_surface(index=3)
        cylindrical_lens.set_aperture(aperture_type="EPD", value=20.0)
        cylindrical_lens.set_field_type(field_type="angle")
        cylindrical_lens.add_field(y=0)
        cylindrical_lens.add_wavelength(value=0.587, is_primary=True)
    
        viewer = OpticViewer3D(cylindrical_lens)
    
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view()

tests\test_visualization.py:302: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x00000147971ED010&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 3 is out of bounds for dimension 0 with size 3

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_non_symmetric[backend=numpy]" time="0.075"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6BB6D0&gt;
set_test_backend = None

    def test_view_non_symmetric(self, set_test_backend):
        lens = ReverseTelephoto()
        lens.surface_group.surfaces[1].geometry.is_symmetric = False
        viewer = OpticViewer3D(lens)
        viewer.system._identify_components()
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view(reference="chief")

tests\test_visualization.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x0000014798C92DD0&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_non_symmetric[backend=torch]" time="0.101"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6BB810&gt;
set_test_backend = None

    def test_view_non_symmetric(self, set_test_backend):
        lens = ReverseTelephoto()
        lens.surface_group.surfaces[1].geometry.is_symmetric = False
        viewer = OpticViewer3D(lens)
        viewer.system._identify_components()
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view(reference="chief")

tests\test_visualization.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x000001479A9C15D0&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_reference_chief_and_bundle[backend=numpy]" time="0.087"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6BBF10&gt;
set_test_backend = None

    def test_reference_chief_and_bundle(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view(reference="chief")

tests\test_visualization.py:326: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x000001479A8CEE90&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_reference_chief_and_bundle[backend=torch]" time="0.102"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6BC090&gt;
set_test_backend = None

    def test_reference_chief_and_bundle(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view(reference="chief")

tests\test_visualization.py:326: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x00000147975FD190&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_reference_marginal_and_bundle[backend=numpy]" time="0.085"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6BC790&gt;
set_test_backend = None

    def test_reference_marginal_and_bundle(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view(reference="marginal")

tests\test_visualization.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x000001479EC68190&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_reference_marginal_and_bundle[backend=torch]" time="0.102"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6BC8D0&gt;
set_test_backend = None

    def test_reference_marginal_and_bundle(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view(reference="marginal")

tests\test_visualization.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x00000147972995D0&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_invalid_reference[backend=numpy]" time="0.089"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6BD210&gt;
set_test_backend = None

    def test_invalid_reference(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer3D(lens)
        with pytest.raises(ValueError):
&gt;           viewer.view(reference="invalid")

tests\test_visualization.py:345: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x000001479606E450&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_invalid_reference[backend=torch]" time="0.097"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6BD4D0&gt;
set_test_backend = None

    def test_invalid_reference(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer3D(lens)
        with pytest.raises(ValueError):
&gt;           viewer.view(reference="invalid")

tests\test_visualization.py:345: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x0000014796BFCCD0&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_reference_chief_only[backend=numpy]" time="0.103"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6BDF10&gt;
set_test_backend = None

    def test_reference_chief_only(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view(reference="chief", distribution=None)

tests\test_visualization.py:354: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:83: in plot
    self._trace(field, wavelength, num_rays, "line_y")
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x000001479606F0D0&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_reference_chief_only[backend=torch]" time="0.099"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6BE190&gt;
set_test_backend = None

    def test_reference_chief_only(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view(reference="chief", distribution=None)

tests\test_visualization.py:354: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:83: in plot
    self._trace(field, wavelength, num_rays, "line_y")
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x00000147970AE1D0&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_reference_marginal_only[backend=numpy]" time="0.089"><failure message="IndexError: index 14 is out of bounds for axis 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6BED10&gt;
set_test_backend = None

    def test_reference_marginal_only(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view(reference="marginal", distribution=None)

tests\test_visualization.py:365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:83: in plot
    self._trace(field, wavelength, num_rays, "line_y")
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x0000014796234510&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for axis 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_reference_marginal_only[backend=torch]" time="0.117"><failure message="IndexError: index 14 is out of bounds for dimension 0 with size 14">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6BEF90&gt;
set_test_backend = None

    def test_reference_marginal_only(self, set_test_backend):
        lens = ReverseTelephoto()
        viewer = OpticViewer3D(lens)
        with (
            patch.object(viewer.iren, "Start") as mock_start,
            patch.object(viewer.ren_win, "Render") as mock_render,
        ):
&gt;           viewer.view(reference="marginal", distribution=None)

tests\test_visualization.py:365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:83: in plot
    self._trace(field, wavelength, num_rays, "line_y")
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x0000014798DDFBD0&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 14 is out of bounds for dimension 0 with size 14

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_sets_background_color_for_theme[backend=numpy-True-bg10-bg20]" time="0.039"><failure message="IndexError: index 9 is out of bounds for axis 0 with size 9">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6CC2D0&gt;
mock_vtk = &lt;MagicMock name='vtk' id='1406973818512'&gt;, dark_mode = True
bg1 = (0.13, 0.15, 0.19), bg2 = (0.195, 0.21, 0.24), set_test_backend = None

    @pytest.mark.parametrize(
        "dark_mode, bg1, bg2",
        [
            (True, (0.13, 0.15, 0.19), (0.195, 0.21, 0.24)),
            (False, (0.8, 0.9, 1.0), (0.4, 0.5, 0.6)),
        ],
    )
    @patch("optiland.visualization.system.optic_viewer_3d.vtk")
    def test_view_sets_background_color_for_theme(
        self, mock_vtk, dark_mode, bg1, bg2, set_test_backend
    ):
        """Test that view() correctly sets the background for both themes."""
        lens = TessarLens()
        viewer = OpticViewer3D(lens)
    
        mock_renderer_instance = mock_vtk.vtkRenderer.return_value
&gt;       viewer.view(dark_mode=dark_mode)

tests\test_visualization.py:385: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x000001479A2A9B50&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 9 is out of bounds for axis 0 with size 9

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_sets_background_color_for_theme[backend=numpy-False-bg11-bg21]" time="0.054"><failure message="IndexError: index 9 is out of bounds for axis 0 with size 9">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6CC550&gt;
mock_vtk = &lt;MagicMock name='vtk' id='1407121924176'&gt;, dark_mode = False
bg1 = (0.8, 0.9, 1.0), bg2 = (0.4, 0.5, 0.6), set_test_backend = None

    @pytest.mark.parametrize(
        "dark_mode, bg1, bg2",
        [
            (True, (0.13, 0.15, 0.19), (0.195, 0.21, 0.24)),
            (False, (0.8, 0.9, 1.0), (0.4, 0.5, 0.6)),
        ],
    )
    @patch("optiland.visualization.system.optic_viewer_3d.vtk")
    def test_view_sets_background_color_for_theme(
        self, mock_vtk, dark_mode, bg1, bg2, set_test_backend
    ):
        """Test that view() correctly sets the background for both themes."""
        lens = TessarLens()
        viewer = OpticViewer3D(lens)
    
        mock_renderer_instance = mock_vtk.vtkRenderer.return_value
&gt;       viewer.view(dark_mode=dark_mode)

tests\test_visualization.py:385: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x0000014797280390&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 9 is out of bounds for axis 0 with size 9

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_sets_background_color_for_theme[backend=torch-True-bg10-bg20]" time="0.085"><failure message="IndexError: index 9 is out of bounds for dimension 0 with size 9">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6CC7D0&gt;
mock_vtk = &lt;MagicMock name='vtk' id='1407018888016'&gt;, dark_mode = True
bg1 = (0.13, 0.15, 0.19), bg2 = (0.195, 0.21, 0.24), set_test_backend = None

    @pytest.mark.parametrize(
        "dark_mode, bg1, bg2",
        [
            (True, (0.13, 0.15, 0.19), (0.195, 0.21, 0.24)),
            (False, (0.8, 0.9, 1.0), (0.4, 0.5, 0.6)),
        ],
    )
    @patch("optiland.visualization.system.optic_viewer_3d.vtk")
    def test_view_sets_background_color_for_theme(
        self, mock_vtk, dark_mode, bg1, bg2, set_test_backend
    ):
        """Test that view() correctly sets the background for both themes."""
        lens = TessarLens()
        viewer = OpticViewer3D(lens)
    
        mock_renderer_instance = mock_vtk.vtkRenderer.return_value
&gt;       viewer.view(dark_mode=dark_mode)

tests\test_visualization.py:385: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x000001479A90D490&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 9 is out of bounds for dimension 0 with size 9

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestOpticViewer3D" name="test_view_sets_background_color_for_theme[backend=torch-False-bg11-bg21]" time="0.058"><failure message="IndexError: index 9 is out of bounds for dimension 0 with size 9">self = &lt;tests.test_visualization.TestOpticViewer3D object at 0x000001478F6CCA50&gt;
mock_vtk = &lt;MagicMock name='vtk' id='1406992591248'&gt;, dark_mode = False
bg1 = (0.8, 0.9, 1.0), bg2 = (0.4, 0.5, 0.6), set_test_backend = None

    @pytest.mark.parametrize(
        "dark_mode, bg1, bg2",
        [
            (True, (0.13, 0.15, 0.19), (0.195, 0.21, 0.24)),
            (False, (0.8, 0.9, 1.0), (0.4, 0.5, 0.6)),
        ],
    )
    @patch("optiland.visualization.system.optic_viewer_3d.vtk")
    def test_view_sets_background_color_for_theme(
        self, mock_vtk, dark_mode, bg1, bg2, set_test_backend
    ):
        """Test that view() correctly sets the background for both themes."""
        lens = TessarLens()
        viewer = OpticViewer3D(lens)
    
        mock_renderer_instance = mock_vtk.vtkRenderer.return_value
&gt;       viewer.view(dark_mode=dark_mode)

tests\test_visualization.py:385: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\visualization\system\optic_viewer_3d.py:88: in view
    self.rays.plot(
optiland\visualization\system\rays.py:86: in plot
    self._trace(field, wavelength, num_rays, distribution)
optiland\visualization\system\rays.py:118: in _trace
    self._process_traced_rays()
optiland\visualization\system\rays.py:102: in _process_traced_rays
    self._update_surface_extents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.visualization.system.rays.Rays3D object at 0x0000014798CAC790&gt;

    def _update_surface_extents(self):
        """Updates the extents of the surfaces in the optic's surface group."""
        r_extent_new = be.copy(be.zeros_like(self.r_extent))
        for i, surf in enumerate(self.optic.surface_group.surfaces):
            # convert to local coordinate system
&gt;           x, y, _ = transform(self.x[i], self.y[i], self.z[i], surf, is_global=True)
                                ^^^^^^^^^
E           IndexError: index 9 is out of bounds for dimension 0 with size 9

optiland\visualization\system\rays.py:146: IndexError</failure></testcase><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_standard[backend=numpy]" time="0.040" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_standard[backend=torch]" time="0.056" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_from_optic[backend=numpy]" time="0.039" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_from_optic[backend=torch]" time="0.055" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_plano_convex[backend=numpy]" time="0.011" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_plano_convex[backend=torch]" time="0.017" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_invalid_geometry[backend=numpy]" time="0.046" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_invalid_geometry[backend=torch]" time="0.057" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_reflective_lens[backend=numpy]" time="0.005" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_reflective_lens[backend=torch]" time="0.016" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_asphere[backend=numpy]" time="0.052" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_asphere[backend=torch]" time="0.071" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_material_file[backend=numpy]" time="0.059" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_material_file[backend=torch]" time="0.085" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_ideal_material[backend=numpy]" time="0.078" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_ideal_material[backend=torch]" time="0.087" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_invalid_material[backend=numpy]" time="0.057" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_invalid_material[backend=torch]" time="0.068" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_abbe_material[backend=numpy]" time="0.054" /><testcase classname="tests.test_visualization.TestLensInfoViewer" name="test_view_abbe_material[backend=torch]" time="0.076" /><testcase classname="tests.test_visualization.TestSurfaceSagViewer" name="test_view_with_cylindrical_lens[backend=numpy]" time="0.132" /><testcase classname="tests.test_visualization.TestSurfaceSagViewer" name="test_view_with_cylindrical_lens[backend=torch]" time="0.125" /><testcase classname="tests.test_visualization.TestSurfaceSagViewer" name="test_view_with_custom_cross_section[backend=numpy]" time="0.104" /><testcase classname="tests.test_visualization.TestSurfaceSagViewer" name="test_view_with_custom_cross_section[backend=torch]" time="0.100" /><testcase classname="tests.test_visualization" name="test_mangin_mirror_visualization[backend=numpy-2d-Lens2D]" time="0.017" /><testcase classname="tests.test_visualization" name="test_mangin_mirror_visualization[backend=numpy-3d-Lens3D]" time="0.016" /><testcase classname="tests.test_visualization" name="test_mangin_mirror_visualization[backend=torch-2d-Lens2D]" time="0.018" /><testcase classname="tests.test_visualization" name="test_mangin_mirror_visualization[backend=torch-3d-Lens3D]" time="0.016" /><testcase classname="tests.test_wavefront.TestWavefront" name="test_wavefront_initialization[backend=numpy-CookeTriplet]" time="0.031"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestWavefront object at 0x000001478F6DB3D0&gt;
OpticClass = &lt;class 'optiland.samples.objectives.CookeTriplet'&gt;
set_test_backend = None

    @pytest.mark.parametrize("OpticClass", [CookeTriplet, DoubleGauss, EyepieceErfle])
    def test_wavefront_initialization(self, OpticClass, set_test_backend):
        optic = OpticClass()
&gt;       w = Wavefront(optic)
            ^^^^^^^^^^^^^^^^

tests\test_wavefront.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x00000147976E7F50&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestWavefront" name="test_wavefront_initialization[backend=numpy-DoubleGauss]" time="0.052"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestWavefront object at 0x000001478F6DB510&gt;
OpticClass = &lt;class 'optiland.samples.objectives.DoubleGauss'&gt;
set_test_backend = None

    @pytest.mark.parametrize("OpticClass", [CookeTriplet, DoubleGauss, EyepieceErfle])
    def test_wavefront_initialization(self, OpticClass, set_test_backend):
        optic = OpticClass()
&gt;       w = Wavefront(optic)
            ^^^^^^^^^^^^^^^^

tests\test_wavefront.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479EB267D0&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestWavefront" name="test_wavefront_initialization[backend=numpy-EyepieceErfle]" time="0.040"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestWavefront object at 0x000001478F6DB650&gt;
OpticClass = &lt;class 'optiland.samples.eyepieces.EyepieceErfle'&gt;
set_test_backend = None

    @pytest.mark.parametrize("OpticClass", [CookeTriplet, DoubleGauss, EyepieceErfle])
    def test_wavefront_initialization(self, OpticClass, set_test_backend):
        optic = OpticClass()
&gt;       w = Wavefront(optic)
            ^^^^^^^^^^^^^^^^

tests\test_wavefront.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479ED55090&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestWavefront" name="test_wavefront_initialization[backend=torch-CookeTriplet]" time="0.053"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestWavefront object at 0x000001478F6DB790&gt;
OpticClass = &lt;class 'optiland.samples.objectives.CookeTriplet'&gt;
set_test_backend = None

    @pytest.mark.parametrize("OpticClass", [CookeTriplet, DoubleGauss, EyepieceErfle])
    def test_wavefront_initialization(self, OpticClass, set_test_backend):
        optic = OpticClass()
&gt;       w = Wavefront(optic)
            ^^^^^^^^^^^^^^^^

tests\test_wavefront.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479BFBA4D0&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestWavefront" name="test_wavefront_initialization[backend=torch-DoubleGauss]" time="0.082"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestWavefront object at 0x000001478F6DB8D0&gt;
OpticClass = &lt;class 'optiland.samples.objectives.DoubleGauss'&gt;
set_test_backend = None

    @pytest.mark.parametrize("OpticClass", [CookeTriplet, DoubleGauss, EyepieceErfle])
    def test_wavefront_initialization(self, OpticClass, set_test_backend):
        optic = OpticClass()
&gt;       w = Wavefront(optic)
            ^^^^^^^^^^^^^^^^

tests\test_wavefront.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479EAD1590&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestWavefront" name="test_wavefront_initialization[backend=torch-EyepieceErfle]" time="0.053"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestWavefront object at 0x000001478F6DBA10&gt;
OpticClass = &lt;class 'optiland.samples.eyepieces.EyepieceErfle'&gt;
set_test_backend = None

    @pytest.mark.parametrize("OpticClass", [CookeTriplet, DoubleGauss, EyepieceErfle])
    def test_wavefront_initialization(self, OpticClass, set_test_backend):
        optic = OpticClass()
&gt;       w = Wavefront(optic)
            ^^^^^^^^^^^^^^^^

tests\test_wavefront.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479EC87D10&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestWavefront" name="test_wavefront_init_custom[backend=numpy]" time="0.078" /><testcase classname="tests.test_wavefront.TestWavefront" name="test_wavefront_init_custom[backend=torch]" time="0.207" /><testcase classname="tests.test_wavefront.TestWavefront" name="test_generate_data[backend=numpy]" time="0.038"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestWavefront object at 0x000001478F6F1250&gt;
set_test_backend = None

    def test_generate_data(self, set_test_backend):
        optic = EyepieceErfle()
&gt;       w = Wavefront(optic)
            ^^^^^^^^^^^^^^^^

tests\test_wavefront.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x00000147990C4CD0&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestWavefront" name="test_generate_data[backend=torch]" time="0.051"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestWavefront object at 0x000001478F6F14D0&gt;
set_test_backend = None

    def test_generate_data(self, set_test_backend):
        optic = EyepieceErfle()
&gt;       w = Wavefront(optic)
            ^^^^^^^^^^^^^^^^

tests\test_wavefront.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479BEF2950&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPDFan" name="test_opd_fan_initialization[backend=numpy]" time="0.050"><failure message="TypeError: Use () not None as shape arguments">self = &lt;tests.test_wavefront.TestOPDFan object at 0x000001478F6F2150&gt;
set_test_backend = None

    def test_opd_fan_initialization(self, set_test_backend):
        optic = DoubleGauss()
&gt;       opd_fan = OPDFan(optic)
                  ^^^^^^^^^^^^^

tests\test_wavefront.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd_fan.py:67: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.CrossDistribution object at 0x0000014796FB8590&gt;
num_points = None

    def generate_points(self, num_points: int):
        """Generate points in the shape of a cross.
    
        Args:
            num_points (int): The number of points to generate in each axis.
    
        """
        # Generate points for the y-axis (vertical line)
&gt;       y_line_x = be.zeros(num_points)
                   ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Use () not None as shape arguments

optiland\distribution.py:235: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPDFan" name="test_opd_fan_initialization[backend=torch]" time="0.086"><failure message="TypeError: zeros() received an invalid combination of arguments - got (NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (tuple of ints size, *, tuple of names names, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (tuple of ints size, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_wavefront.TestOPDFan object at 0x000001478F6F23D0&gt;
set_test_backend = None

    def test_opd_fan_initialization(self, set_test_backend):
        optic = DoubleGauss()
&gt;       opd_fan = OPDFan(optic)
                  ^^^^^^^^^^^^^

tests\test_wavefront.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd_fan.py:67: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:235: in generate_points
    y_line_x = be.zeros(num_points)
               ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

shape = None

    def zeros(shape: Sequence[int]) -&gt; Tensor:
&gt;       return torch.zeros(
            shape,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: zeros() received an invalid combination of arguments - got (NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (tuple of ints size, *, tuple of names names, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (tuple of ints size, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:141: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPDFan" name="test_opd_fan_view[backend=numpy]" time="0.055"><failure message="TypeError: Use () not None as shape arguments">self = &lt;tests.test_wavefront.TestOPDFan object at 0x000001478F6F2F50&gt;
moch_show = &lt;MagicMock name='show' id='1406989780112'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_opd_fan_view(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       opd_fan = OPDFan(optic)
                  ^^^^^^^^^^^^^

tests\test_wavefront.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd_fan.py:67: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.CrossDistribution object at 0x00000147972921D0&gt;
num_points = None

    def generate_points(self, num_points: int):
        """Generate points in the shape of a cross.
    
        Args:
            num_points (int): The number of points to generate in each axis.
    
        """
        # Generate points for the y-axis (vertical line)
&gt;       y_line_x = be.zeros(num_points)
                   ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Use () not None as shape arguments

optiland\distribution.py:235: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPDFan" name="test_opd_fan_view[backend=torch]" time="0.082"><failure message="TypeError: zeros() received an invalid combination of arguments - got (NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (tuple of ints size, *, tuple of names names, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (tuple of ints size, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_wavefront.TestOPDFan object at 0x000001478F6F31D0&gt;
moch_show = &lt;MagicMock name='show' id='1406988751312'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_opd_fan_view(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       opd_fan = OPDFan(optic)
                  ^^^^^^^^^^^^^

tests\test_wavefront.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd_fan.py:67: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:235: in generate_points
    y_line_x = be.zeros(num_points)
               ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

shape = None

    def zeros(shape: Sequence[int]) -&gt; Tensor:
&gt;       return torch.zeros(
            shape,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: zeros() received an invalid combination of arguments - got (NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (tuple of ints size, *, tuple of names names, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (tuple of ints size, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:141: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPDFan" name="test_opd_fan_view_large[backend=numpy]" time="0.055"><failure message="TypeError: Use () not None as shape arguments">self = &lt;tests.test_wavefront.TestOPDFan object at 0x000001478F6F3D10&gt;
moch_show = &lt;MagicMock name='show' id='1407018402576'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_opd_fan_view_large(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       opd_fan = OPDFan(optic)
                  ^^^^^^^^^^^^^

tests\test_wavefront.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd_fan.py:67: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.CrossDistribution object at 0x00000147975C74D0&gt;
num_points = None

    def generate_points(self, num_points: int):
        """Generate points in the shape of a cross.
    
        Args:
            num_points (int): The number of points to generate in each axis.
    
        """
        # Generate points for the y-axis (vertical line)
&gt;       y_line_x = be.zeros(num_points)
                   ^^^^^^^^^^^^^^^^^^^^
E       TypeError: Use () not None as shape arguments

optiland\distribution.py:235: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPDFan" name="test_opd_fan_view_large[backend=torch]" time="0.083"><failure message="TypeError: zeros() received an invalid combination of arguments - got (NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (tuple of ints size, *, tuple of names names, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (tuple of ints size, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_wavefront.TestOPDFan object at 0x000001478F6F3F90&gt;
moch_show = &lt;MagicMock name='show' id='1406976204688'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_opd_fan_view_large(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       opd_fan = OPDFan(optic)
                  ^^^^^^^^^^^^^

tests\test_wavefront.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd_fan.py:67: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:235: in generate_points
    y_line_x = be.zeros(num_points)
               ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

shape = None

    def zeros(shape: Sequence[int]) -&gt; Tensor:
&gt;       return torch.zeros(
            shape,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: zeros() received an invalid combination of arguments - got (NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (tuple of ints size, *, tuple of names names, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (tuple of ints size, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:141: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPD" name="test_opd_initialization[backend=numpy]" time="0.042"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestOPD object at 0x000001478F6F4B90&gt;
set_test_backend = None

    def test_opd_initialization(self, set_test_backend):
        optic = EyepieceErfle()
&gt;       opd = OPD(optic, (0, 1), 0.55)
              ^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479A423150&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPD" name="test_opd_initialization[backend=torch]" time="0.064"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestOPD object at 0x000001478F6F4E10&gt;
set_test_backend = None

    def test_opd_initialization(self, set_test_backend):
        optic = EyepieceErfle()
&gt;       opd = OPD(optic, (0, 1), 0.55)
              ^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479EAC05D0&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPD" name="test_opd_view[backend=numpy]" time="0.066"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestOPD object at 0x000001478F6F5990&gt;
moch_show = &lt;MagicMock name='show' id='1407018242128'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_opd_view(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       opd = OPD(optic, (0, 1), 0.55)
              ^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479EC08C90&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPD" name="test_opd_view[backend=torch]" time="0.092"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestOPD object at 0x000001478F6F5C10&gt;
moch_show = &lt;MagicMock name='show' id='1407041912336'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_opd_view(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       opd = OPD(optic, (0, 1), 0.55)
              ^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014795E47E90&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPD" name="test_opd_view_large[backend=numpy]" time="0.062"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestOPD object at 0x000001478F6F6750&gt;
moch_show = &lt;MagicMock name='show' id='1406993718608'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_opd_view_large(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       opd = OPD(optic, (0, 1), 0.55)
              ^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479787A010&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPD" name="test_opd_view_large[backend=torch]" time="0.092"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestOPD object at 0x000001478F6F69D0&gt;
moch_show = &lt;MagicMock name='show' id='1406969639824'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_opd_view_large(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       opd = OPD(optic, (0, 1), 0.55)
              ^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014797279590&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPD" name="test_opd_view_3d[backend=numpy]" time="0.114"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestOPD object at 0x000001478F6F74D0&gt;
moch_show = &lt;MagicMock name='show' id='1407018998416'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_opd_view_3d(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       opd = OPD(optic, (0, 1), 0.55)
              ^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014796C11FD0&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPD" name="test_opd_view_3d[backend=torch]" time="0.133"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestOPD object at 0x000001478F6F7750&gt;
moch_show = &lt;MagicMock name='show' id='1407020581136'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_opd_view_3d(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       opd = OPD(optic, (0, 1), 0.55)
              ^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479BF74C90&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPD" name="test_old_invalid_projection[backend=numpy]" time="0.042"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestOPD object at 0x000001478F6FC310&gt;
set_test_backend = None

    def test_old_invalid_projection(self, set_test_backend):
        optic = EyepieceErfle()
&gt;       opd = OPD(optic, (0, 1), 0.55)
              ^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479BF70B90&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPD" name="test_old_invalid_projection[backend=torch]" time="0.056"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestOPD object at 0x000001478F6FC590&gt;
set_test_backend = None

    def test_old_invalid_projection(self, set_test_backend):
        optic = EyepieceErfle()
&gt;       opd = OPD(optic, (0, 1), 0.55)
              ^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014795E1BF50&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPD" name="test_opd_rms[backend=numpy]" time="0.026"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestOPD object at 0x000001478F6FC810&gt;
set_test_backend = None

    def test_opd_rms(self, set_test_backend):
        optic = CookeTriplet()
&gt;       opd = OPD(optic, (0, 1), 0.55)
              ^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479A9FE390&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestOPD" name="test_opd_rms[backend=torch]" time="0.037"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestOPD object at 0x000001478F6FC950&gt;
set_test_backend = None

    def test_opd_rms(self, set_test_backend):
        optic = CookeTriplet()
&gt;       opd = OPD(optic, (0, 1), 0.55)
              ^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479A2F9C90&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_opd_initialization[backend=numpy]" time="0.053"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F6FD190&gt;
set_test_backend = None

    def test_zernike_opd_initialization(self, set_test_backend):
        optic = DoubleGauss()
&gt;       zernike_opd = ZernikeOPD(optic, (0, 1), 0.55)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014798C63650&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_opd_initialization[backend=torch]" time="0.076"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F6FD2D0&gt;
set_test_backend = None

    def test_zernike_opd_initialization(self, set_test_backend):
        optic = DoubleGauss()
&gt;       zernike_opd = ZernikeOPD(optic, (0, 1), 0.55)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479A505410&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_opd_view[backend=numpy]" time="0.069"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F6FDA10&gt;
moch_show = &lt;MagicMock name='show' id='1407017589328'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_zernike_opd_view(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       zernike_opd = ZernikeOPD(optic, (0, 1), 0.55)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014797183650&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_opd_view[backend=torch]" time="0.116"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F6FDB50&gt;
moch_show = &lt;MagicMock name='show' id='1406975332048'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_zernike_opd_view(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       zernike_opd = ZernikeOPD(optic, (0, 1), 0.55)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014798D76250&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_opd_view_large[backend=numpy]" time="0.064"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F6FE390&gt;
moch_show = &lt;MagicMock name='show' id='1406983483984'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_zernike_opd_view_large(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       zernike_opd = ZernikeOPD(optic, (0, 1), 0.55)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014798D766D0&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_opd_view_large[backend=torch]" time="0.085"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F6FE610&gt;
moch_show = &lt;MagicMock name='show' id='1406987618320'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_zernike_opd_view_large(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       zernike_opd = ZernikeOPD(optic, (0, 1), 0.55)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x00000147975AE1D0&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_opd_view_3d[backend=numpy]" time="0.055"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F6FEF90&gt;
moch_show = &lt;MagicMock name='show' id='1406993615312'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_zernike_opd_view_3d(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       zernike_opd = ZernikeOPD(optic, (0, 1), 0.55)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479EC80990&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_opd_view_3d[backend=torch]" time="0.090"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F6FF210&gt;
moch_show = &lt;MagicMock name='show' id='1407019029264'&gt;, set_test_backend = None

    @patch("matplotlib.pyplot.show")
    def test_zernike_opd_view_3d(self, moch_show, set_test_backend):
        optic = DoubleGauss()
&gt;       zernike_opd = ZernikeOPD(optic, (0, 1), 0.55)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014798C0EB90&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_opd_rms[backend=numpy]" time="0.028"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F6FFD90&gt;
set_test_backend = None

    def test_zernike_opd_rms(self, set_test_backend):
        optic = CookeTriplet()
&gt;       zernike_opd = ZernikeOPD(optic, (0, 1), 0.55)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479A3B0290&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_opd_rms[backend=torch]" time="0.042"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F704050&gt;
set_test_backend = None

    def test_zernike_opd_rms(self, set_test_backend):
        optic = CookeTriplet()
&gt;       zernike_opd = ZernikeOPD(optic, (0, 1), 0.55)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479C046A10&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_opd_fit[backend=numpy]" time="0.028"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F704B90&gt;
set_test_backend = None

    def test_zernike_opd_fit(self, set_test_backend):
        optic = CookeTriplet()
&gt;       zernike_opd = ZernikeOPD(optic, (0, 1), 0.55)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479C0466D0&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_opd_fit[backend=torch]" time="0.044"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F704E10&gt;
set_test_backend = None

    def test_zernike_opd_fit(self, set_test_backend):
        optic = CookeTriplet()
&gt;       zernike_opd = ZernikeOPD(optic, (0, 1), 0.55)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479BFE4FD0&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_xy_symmetry[backend=numpy]" time="0.027"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F705990&gt;
set_test_backend = None

    def test_zernike_xy_symmetry(self, set_test_backend):
        optic = CookeTriplet()
&gt;       zernike_opd0 = ZernikeOPD(optic, (0, 1), 0.55)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014798C81310&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_xy_symmetry[backend=torch]" time="0.040"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F705C10&gt;
set_test_backend = None

    def test_zernike_xy_symmetry(self, set_test_backend):
        optic = CookeTriplet()
&gt;       zernike_opd0 = ZernikeOPD(optic, (0, 1), 0.55)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x00000147977D5C10&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_xy_axis_swap[backend=numpy]" time="0.028"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F706790&gt;
set_test_backend = None

    def test_zernike_xy_axis_swap(self, set_test_backend):
        optic = CookeTriplet()
&gt;       zernike_opd0 = ZernikeOPD(optic, (0, 1), 0.55)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x0000014795E93490&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront.TestZernikeOPD" name="test_zernike_xy_axis_swap[backend=torch]" time="0.037"><failure message="TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'">self = &lt;tests.test_wavefront.TestZernikeOPD object at 0x000001478F706A10&gt;
set_test_backend = None

    def test_zernike_xy_axis_swap(self, set_test_backend):
        optic = CookeTriplet()
&gt;       zernike_opd0 = ZernikeOPD(optic, (0, 1), 0.55)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\zernike_opd.py:59: in __init__
    OPD.__init__(
optiland\wavefront\opd.py:83: in __init__
    super().__init__(
optiland\wavefront\wavefront.py:81: in __init__
    self._generate_data()
optiland\wavefront\wavefront.py:161: in _generate_data
    data = self.strategy.compute_wavefront_data(field, wl)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;optiland.distribution.HexagonalDistribution object at 0x000001479A3B25D0&gt;
num_rings = None

    def generate_points(self, num_rings: int = 6):
        """Generate points in a hexagonal distribution.
    
        Args:
            num_rings (int): Number of rings in the hexagonal distribution.
                Defaults to 6.
    
        """
        x = be.zeros(1)
        y = be.zeros(1)
&gt;       r = be.linspace(0, 1, num_rings + 1)
                              ^^^^^^^^^^^^^
E       TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'

optiland\distribution.py:198: TypeError</failure></testcase><testcase classname="tests.test_wavefront_strategy.TestReferenceStrategy" name="test_init" time="0.048" /><testcase classname="tests.test_wavefront_strategy.TestReferenceStrategy" name="test_opd_image_to_xp[backend=numpy]" time="0.056" /><testcase classname="tests.test_wavefront_strategy.TestReferenceStrategy" name="test_opd_image_to_xp[backend=torch]" time="0.049" /><testcase classname="tests.test_wavefront_strategy.TestReferenceStrategy" name="test_opd_image_to_xp_negative_t[backend=numpy]" time="0.049" /><testcase classname="tests.test_wavefront_strategy.TestReferenceStrategy" name="test_opd_image_to_xp_negative_t[backend=torch]" time="0.050" /><testcase classname="tests.test_wavefront_strategy.TestReferenceStrategy" name="test_correct_tilt_angle_field[backend=numpy]" time="0.051" /><testcase classname="tests.test_wavefront_strategy.TestReferenceStrategy" name="test_correct_tilt_angle_field[backend=torch]" time="0.059" /><testcase classname="tests.test_wavefront_strategy.TestReferenceStrategy" name="test_correct_tilt_object_height_field[backend=numpy]" time="0.051" /><testcase classname="tests.test_wavefront_strategy.TestReferenceStrategy" name="test_correct_tilt_object_height_field[backend=torch]" time="0.050" /><testcase classname="tests.test_wavefront_strategy.TestReferenceStrategy" name="test_correct_tilt_with_custom_coords[backend=numpy]" time="0.051" /><testcase classname="tests.test_wavefront_strategy.TestReferenceStrategy" name="test_correct_tilt_with_custom_coords[backend=torch]" time="0.063" /><testcase classname="tests.test_wavefront_strategy.TestChiefRayStrategy" name="test_calculate_sphere_from_chief_ray[backend=numpy]" time="0.049" /><testcase classname="tests.test_wavefront_strategy.TestChiefRayStrategy" name="test_calculate_sphere_from_chief_ray[backend=torch]" time="0.059" /><testcase classname="tests.test_wavefront_strategy.TestChiefRayStrategy" name="test_calculate_sphere_from_chief_ray_error[backend=numpy]" time="0.053" /><testcase classname="tests.test_wavefront_strategy.TestChiefRayStrategy" name="test_calculate_sphere_from_chief_ray_error[backend=torch]" time="0.052" /><testcase classname="tests.test_wavefront_strategy.TestChiefRayStrategy" name="test_compute_wavefront_data[backend=numpy]" time="0.056"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_wavefront_strategy.TestChiefRayStrategy object at 0x000001478F71F950&gt;
set_test_backend = None

    def test_compute_wavefront_data(self, set_test_backend):
        """Test the full wavefront data computation for ChiefRayStrategy."""
        optic = DoubleGauss()
        dist = create_distribution("uniform")
        dist.generate_points(18)
        strategy = ChiefRayStrategy(optic, dist)
    
        field = (0.0, 0.1)
        wavelength = 0.55
    
        # Use the real optic and distribution for an integration test
&gt;       wavefront_data = strategy.compute_wavefront_data(field, wavelength)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront_strategy.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_wavefront_strategy.TestChiefRayStrategy" name="test_compute_wavefront_data[backend=torch]" time="0.099"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_wavefront_strategy.TestChiefRayStrategy object at 0x000001478F71FBD0&gt;
set_test_backend = None

    def test_compute_wavefront_data(self, set_test_backend):
        """Test the full wavefront data computation for ChiefRayStrategy."""
        optic = DoubleGauss()
        dist = create_distribution("uniform")
        dist.generate_points(18)
        strategy = ChiefRayStrategy(optic, dist)
    
        field = (0.0, 0.1)
        wavelength = 0.55
    
        # Use the real optic and distribution for an integration test
&gt;       wavefront_data = strategy.compute_wavefront_data(field, wavelength)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront_strategy.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\strategy.py:207: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy" name="test_points_from_rays[backend=numpy]" time="0.063" /><testcase classname="tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy" name="test_points_from_rays[backend=torch]" time="0.091" /><testcase classname="tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy" name="test_points_from_rays_with_invalid[backend=numpy]" time="0.070" /><testcase classname="tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy" name="test_points_from_rays_with_invalid[backend=torch]" time="0.063" /><testcase classname="tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy" name="test_points_from_rays_no_valid[backend=numpy]" time="0.060" /><testcase classname="tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy" name="test_points_from_rays_no_valid[backend=torch]" time="0.070" /><testcase classname="tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy" name="test_calculate_reference_sphere[backend=numpy]" time="0.161"><failure message="AssertionError">self = &lt;tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy object at 0x000001478F726090&gt;
set_test_backend = None

    def test_calculate_reference_sphere(self, set_test_backend):
        """Test the reference sphere calculation."""
        optic = DoubleGauss()
        dist = create_distribution("uniform")
        dist.generate_points(18)
        strategy = CentroidReferenceSphereStrategy(optic, dist)
    
        rays = optic.trace(Hx=0.2, Hy=0.56, distribution=dist, wavelength=0.55)
    
        cx, cy, cz, r = strategy._calculate_reference_sphere(rays)
        assert isinstance(cx, float)
        assert isinstance(cy, float)
        assert isinstance(cz, float)
        assert isinstance(r, float)
        assert_allclose(cx, 4.87516947)
        assert_allclose(cy, 13.72537562)
        assert_allclose(cz, 139.454938)
&gt;       assert_allclose(r, 190.10010539)

tests\test_wavefront_strategy.py:288: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([31.71985693]), b = array([190.10010539]), rtol = 1e-05, atol = 1e-07

    def assert_allclose(a, b, rtol=1.0e-5, atol=1.0e-7):
        """Assert that two arrays or tensors are element-wise equal within
        tolerance.
        """
        a = be.to_numpy(a)
        b = be.to_numpy(b)
&gt;       assert np.allclose(a, b, rtol=rtol, atol=atol)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError

tests\utils.py:12: AssertionError</failure></testcase><testcase classname="tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy" name="test_calculate_reference_sphere[backend=torch]" time="0.189"><failure message="AssertionError">self = &lt;tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy object at 0x000001478F7261D0&gt;
set_test_backend = None

    def test_calculate_reference_sphere(self, set_test_backend):
        """Test the reference sphere calculation."""
        optic = DoubleGauss()
        dist = create_distribution("uniform")
        dist.generate_points(18)
        strategy = CentroidReferenceSphereStrategy(optic, dist)
    
        rays = optic.trace(Hx=0.2, Hy=0.56, distribution=dist, wavelength=0.55)
    
        cx, cy, cz, r = strategy._calculate_reference_sphere(rays)
        assert isinstance(cx, float)
        assert isinstance(cy, float)
        assert isinstance(cz, float)
        assert isinstance(r, float)
        assert_allclose(cx, 4.87516947)
        assert_allclose(cy, 13.72537562)
        assert_allclose(cz, 139.454938)
&gt;       assert_allclose(r, 190.10010539)

tests\test_wavefront_strategy.py:288: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([31.71985693]), b = array([190.10010539]), rtol = 1e-05, atol = 1e-07

    def assert_allclose(a, b, rtol=1.0e-5, atol=1.0e-7):
        """Assert that two arrays or tensors are element-wise equal within
        tolerance.
        """
        a = be.to_numpy(a)
        b = be.to_numpy(b)
&gt;       assert np.allclose(a, b, rtol=rtol, atol=atol)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AssertionError

tests\utils.py:12: AssertionError</failure></testcase><testcase classname="tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy" name="test_calculate_reference_sphere_no_trim[backend=numpy]" time="0.101" /><testcase classname="tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy" name="test_calculate_reference_sphere_no_trim[backend=torch]" time="0.155" /><testcase classname="tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy" name="test_compute_wavefront_data[backend=numpy]" time="0.054"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy object at 0x000001478F727610&gt;
set_test_backend = None

    def test_compute_wavefront_data(self, set_test_backend):
        """Test full wavefront data computation for CentroidReferenceSphereStrategy."""
        optic = DoubleGauss()
        dist = create_distribution("uniform")
        dist.generate_points(18)
        strategy = CentroidReferenceSphereStrategy(optic, dist)
        field = (0.0, 0.1)
        wavelength = 0.55
    
        # Integration test with real optic
&gt;       wavefront_data = strategy.compute_wavefront_data(field, wavelength)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront_strategy.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\strategy.py:286: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy" name="test_compute_wavefront_data[backend=torch]" time="0.051"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_wavefront_strategy.TestCentroidReferenceSphereStrategy object at 0x000001478F727890&gt;
set_test_backend = None

    def test_compute_wavefront_data(self, set_test_backend):
        """Test full wavefront data computation for CentroidReferenceSphereStrategy."""
        optic = DoubleGauss()
        dist = create_distribution("uniform")
        dist.generate_points(18)
        strategy = CentroidReferenceSphereStrategy(optic, dist)
        field = (0.0, 0.1)
        wavelength = 0.55
    
        # Integration test with real optic
&gt;       wavefront_data = strategy.compute_wavefront_data(field, wavelength)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront_strategy.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\strategy.py:286: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_wavefront_strategy" name="test_create_strategy[backend=numpy]" time="0.049" /><testcase classname="tests.test_wavefront_strategy" name="test_create_strategy[backend=torch]" time="0.055" /><testcase classname="tests.test_wavefront_strategy.TestBestFitSphereStrategy" name="test_strategy_compare_at_best_focus[backend=numpy]" time="0.049"><failure message="TypeError: 'NoneType' object cannot be interpreted as an integer">self = &lt;tests.test_wavefront_strategy.TestBestFitSphereStrategy object at 0x000001478F730550&gt;
set_test_backend = None

    def test_strategy_compare_at_best_focus(self, set_test_backend):
        """
        When the image surface is at best focus, BFS and centroid
        strategies should match.
        """
        optic = DoubleGauss()
        # Put image surface at known best focus position for field/wavelength
        optic.image_surface.geometry.cs.z = be.array([139.36352573])
        dist = create_distribution("uniform")
        dist.generate_points(32)
        strategy_centroid = CentroidReferenceSphereStrategy(optic, dist)
&gt;       data_centroid = strategy_centroid.compute_wavefront_data((0, 0), 0.5876)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront_strategy.py:367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\strategy.py:286: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None, endpoint = True, retstep = False
dtype = None, axis = 0

    @array_function_dispatch(_linspace_dispatcher)
    def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
                 axis=0, *, device=None):
        """
        Return evenly spaced numbers over a specified interval.
    
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop`].
    
        The endpoint of the interval can optionally be excluded.
    
        .. versionchanged:: 1.20.0
            Values are rounded towards ``-inf`` instead of ``0`` when an
            integer ``dtype`` is specified. The old behavior can
            still be obtained with ``np.linspace(start, stop, num).astype(int)``
    
        Parameters
        ----------
        start : array_like
            The starting value of the sequence.
        stop : array_like
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50. Must be non-negative.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        dtype : dtype, optional
            The type of the output array.  If `dtype` is not given, the data type
            is inferred from `start` and `stop`. The inferred dtype will never be
            an integer; `float` is chosen even if the arguments would produce an
            array of integers.
        axis : int, optional
            The axis in the result to store the samples.  Relevant only if start
            or stop are array-like.  By default (0), the samples will be along a
            new axis inserted at the beginning. Use -1 to get an axis at the end.
        device : str, optional
            The device on which to place the created array. Default: None.
            For Array-API interoperability only, so must be ``"cpu"`` if passed.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float, optional
            Only returned if `retstep` is True
    
            Size of spacing between samples.
    
    
        See Also
        --------
        arange : Similar to `linspace`, but uses a step size (instead of the
                 number of samples).
        geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
                    scale (a geometric progression).
        logspace : Similar to `geomspace`, but with the end points specified as
                   logarithms.
        :ref:`how-to-partition`
    
        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)
        array([2.  , 2.25, 2.5 , 2.75, 3.  ])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)
        array([2. ,  2.2,  2.4,  2.6,  2.8])
        &gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)
        (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
    
        Graphical illustration:
    
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; N = 8
        &gt;&gt;&gt; y = np.zeros(N)
        &gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)
        &gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)
        &gt;&gt;&gt; plt.plot(x1, y, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')
        [&lt;matplotlib.lines.Line2D object at 0x...&gt;]
        &gt;&gt;&gt; plt.ylim([-0.5, 1])
        (-0.5, 1)
        &gt;&gt;&gt; plt.show()
    
        """
&gt;       num = operator.index(num)
              ^^^^^^^^^^^^^^^^^^^
E       TypeError: 'NoneType' object cannot be interpreted as an integer

..\..\miniconda3\envs\optiland\Lib\site-packages\numpy\_core\function_base.py:122: TypeError</failure></testcase><testcase classname="tests.test_wavefront_strategy.TestBestFitSphereStrategy" name="test_strategy_compare_at_best_focus[backend=torch]" time="0.054"><failure message="TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:&#10; * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)&#10; * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)">self = &lt;tests.test_wavefront_strategy.TestBestFitSphereStrategy object at 0x000001478F7307D0&gt;
set_test_backend = None

    def test_strategy_compare_at_best_focus(self, set_test_backend):
        """
        When the image surface is at best focus, BFS and centroid
        strategies should match.
        """
        optic = DoubleGauss()
        # Put image surface at known best focus position for field/wavelength
        optic.image_surface.geometry.cs.z = be.array([139.36352573])
        dist = create_distribution("uniform")
        dist.generate_points(32)
        strategy_centroid = CentroidReferenceSphereStrategy(optic, dist)
&gt;       data_centroid = strategy_centroid.compute_wavefront_data((0, 0), 0.5876)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_wavefront_strategy.py:367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
optiland\wavefront\strategy.py:286: in compute_wavefront_data
    rays = self.optic.trace(*field, wavelength, None, self.distribution)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\optic\optic.py:612: in trace
    dist_obj.generate_points(num_rays)
optiland\distribution.py:169: in generate_points
    x = be.linspace(-1, 1, num_points)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

start = -1, stop = 1, num = None

    def linspace(start: float, stop: float, num: int = 50) -&gt; Tensor:
&gt;       return torch.linspace(
            start,
            stop,
            num,
            device=get_device(),
            dtype=get_precision(),
            requires_grad=grad_mode.requires_grad,
        )
E       TypeError: linspace() received an invalid combination of arguments - got (int, int, NoneType, dtype=torch.dtype, device=str, requires_grad=bool), but expected one of:
E        * (Tensor start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Tensor end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Tensor start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (Number start, Number end, int steps, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

optiland\backend\torch_backend.py:169: TypeError</failure></testcase><testcase classname="tests.test_wavelength.TestWavelengths" name="test_wavelength_initialization[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_wavelength_initialization[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_wavelength_conversion[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_wavelength_conversion[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_invalid_unit[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_invalid_unit[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_unit_setter[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_unit_setter[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_to_dict[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_to_dict[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_from_dict[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_from_dict[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_from_dict_default_weight[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_from_dict_default_weight[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_is_primary[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_is_primary[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_is_not_primary[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_is_not_primary[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_is_primary_default[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_is_primary_default[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_wavelength_initialization_with_weight[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_wavelength_initialization_with_weight[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_wavelength_default_weight[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengths" name="test_wavelength_default_weight[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_add_wavelength[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_add_wavelength[backend=torch]" time="0.001" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_primary_wavelength[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_primary_wavelength[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_multiple_wavelengths[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_multiple_wavelengths[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_get_wavelengths[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_get_wavelengths[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_to_dict[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_to_dict[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_from_dict[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_from_dict[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_from_dict_invalid_key[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_from_dict_invalid_key[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_wavelengthgroup_weights_property[backend=numpy]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_wavelengthgroup_weights_property[backend=torch]" time="0.000" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_add_wavelengths[backend=numpy]" time="0.001" /><testcase classname="tests.test_wavelength.TestWavelengthGroups" name="test_add_wavelengths[backend=torch]" time="0.008" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_get_term[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_get_term[backend=torch]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_terms[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_terms[backend=torch]" time="0.002" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_poly[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_poly[backend=torch]" time="0.002" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_radial_term[backend=numpy]" time="0.000" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_radial_term[backend=torch]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_azimuthal_term[backend=numpy]" time="0.000" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_azimuthal_term[backend=torch]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_norm_constant[backend=numpy]" time="0.000" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_norm_constant[backend=torch]" time="0.000" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_generate_indices[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_generate_indices[backend=torch]" time="0.000" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_index_to_number[backend=numpy]" time="0.000" /><testcase classname="tests.test_zernike.TestZernikeStandard" name="test_index_to_number[backend=torch]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_get_term[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_get_term[backend=torch]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_terms[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_terms[backend=torch]" time="0.002" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_poly[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_poly[backend=torch]" time="0.002" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_radial_term[backend=numpy]" time="0.000" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_radial_term[backend=torch]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_azimuthal_term[backend=numpy]" time="0.000" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_azimuthal_term[backend=torch]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_norm_constant[backend=numpy]" time="0.000" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_norm_constant[backend=torch]" time="0.000" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_generate_indices[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_generate_indices[backend=torch]" time="0.002" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_index_to_number[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeFringe" name="test_index_to_number[backend=torch]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_get_term[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_get_term[backend=torch]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_terms[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_terms[backend=torch]" time="0.002" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_poly[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_poly[backend=torch]" time="0.002" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_radial_term[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_radial_term[backend=torch]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_azimuthal_term[backend=numpy]" time="0.000" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_azimuthal_term[backend=torch]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_norm_constant[backend=numpy]" time="0.000" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_norm_constant[backend=torch]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_generate_indices[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_generate_indices[backend=torch]" time="0.000" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_index_to_number[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeNoll" name="test_index_to_number[backend=torch]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_init[backend=numpy]" time="0.005" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_init[backend=torch]" time="0.031" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_init_standard[backend=numpy]" time="0.005" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_init_standard[backend=torch]" time="0.020" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_init_noll[backend=numpy]" time="0.004" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_init_noll[backend=torch]" time="0.015" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_invalid_zernike_type[backend=numpy]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_invalid_zernike_type[backend=torch]" time="0.001" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_coeffs[backend=numpy]" time="0.003" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_coeffs[backend=torch]" time="0.019" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_coeffs_standard[backend=numpy]" time="0.004" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_coeffs_standard[backend=torch]" time="0.015" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_coeffs_noll[backend=numpy]" time="0.003" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_coeffs_noll[backend=torch]" time="0.016" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_invalid_view_projection[backend=numpy]" time="0.031" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_invalid_view_projection[backend=torch]" time="0.085" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_standard[backend=numpy]" time="0.032" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_standard[backend=torch]" time="0.064" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_standard_3d[backend=numpy]" time="0.158" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_standard_3d[backend=torch]" time="0.200" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_noll[backend=numpy]" time="0.034" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_noll[backend=torch]" time="0.069" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_noll_3d[backend=numpy]" time="0.154" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_noll_3d[backend=torch]" time="0.199" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_residual_standard[backend=numpy]" time="0.268" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_residual_standard[backend=torch]" time="0.043" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_residual_noll[backend=numpy]" time="0.017" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_residual_noll[backend=torch]" time="0.042" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view[backend=numpy]" time="0.035" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view[backend=torch]" time="0.081" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_3d[backend=numpy]" time="0.164" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_3d[backend=torch]" time="0.264" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_residual[backend=numpy]" time="0.020" /><testcase classname="tests.test_zernike.TestZernikeFit" name="test_view_residual[backend=torch]" time="0.055" /></testsuite></testsuites>