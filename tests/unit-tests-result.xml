<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="1" skipped="0" tests="1" time="2.291" timestamp="2025-10-03T15:14:44.640240-07:00" hostname="glaptop-16"><testcase classname="tests.test_gradient_propagation" name="test_propagate_through_radial_grin_lens" time="0.006"><failure message="AttributeError: The 'numpy' backend (module optiland.backend.numpy_backend) has no attribute 'Tensor'.">def test_propagate_through_radial_grin_lens():
        """Test that a ray is focused by a simple radial GRIN lens."""
        # 1. Define a focusing radial GRIN material (n decreases with r)
        grin_material = GradientMaterial(n0=1.5, nr2=-0.01)
    
        # 2. Define entry and exit surfaces (a GRIN slab of 10mm thickness)
        entry_surface = GradientBoundarySurface(thickness=10.0)
        exit_surface = GradientBoundarySurface(thickness=0.0) # Exit surface is at z=10 relative to entry
        exit_surface.z = 10.0
    
        # 3. Create a single ray parallel to the z-axis, offset in y
        initial_y = 1.0
        rays_in = RealRays(
            x=be.array([0.0]),
            y=be.array([initial_y]),
            z=be.array([0.0]),
            L=be.array([0.0]),
            M=be.array([0.0]),
            N=be.array([1.0]),
            intensity=be.array([1.0]),
            wavelength=be.array([0.55])
        )
    
        # 4. Call the propagation function
&gt;       rays_out = propagate_through_gradient(
            rays_in=rays_in,
            grin_material=grin_material,
            exit_surface=exit_surface,
            step_size=0.1,
            max_steps=1000
        )

tests\test_gradient_propagation.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
..\..\miniconda3\envs\optiland\Lib\site-packages\icontract\_checkers.py:833: in wrapper
    result = func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^
optiland\interactions\gradient_propagation.py:69: in propagate_through_gradient
    n_current = grin_material.get_index(r_active[:, 0], r_active[:, 1], r_active[:, 2])
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\miniconda3\envs\optiland\Lib\site-packages\icontract\_checkers.py:1148: in wrapper
    result = func(*args, **kwargs)
             ^^^^^^^^^^^^^^^^^^^^^
..\..\miniconda3\envs\optiland\Lib\site-packages\icontract\_checkers.py:816: in wrapper
    violation_error = _assert_preconditions(
..\..\miniconda3\envs\optiland\Lib\site-packages\icontract\_checkers.py:361: in _assert_preconditions
    check = contract.condition(**condition_kwargs)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\materials\gradient_material.py:62: in &lt;lambda&gt;
    @icontract.require(lambda x, y, z: all(isinstance(v, (int, float, np.ndarray, be.Tensor)) for v in [x, y, z]))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
optiland\materials\gradient_material.py:62: in &lt;genexpr&gt;
    @icontract.require(lambda x, y, z: all(isinstance(v, (int, float, np.ndarray, be.Tensor)) for v in [x, y, z]))
                                                                                  ^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'Tensor'

    def __getattr__(name):
        """Dynamically retrieve attributes (functions/constants) from the current backend.
    
        When a user accesses an attribute (e.g., be.sin or be.pi), this function
        tries to retrieve the attribute from the current backend module. If not found,
        it attempts to retrieve the attribute from an optional `_lib` attribute of the
        backend module (allowing for a two-level backend organization).
    
        Raises:
            AttributeError: If the attribute is not found in the current backend.
        """
        if name in globals():
            return globals()[name]
    
        backend = _backends[_current_backend]
    
        # Direct attribute lookup in the backend module.
        try:
            return getattr(backend, name)
        except AttributeError:
            pass
    
        # Fallback: check the _lib submodule if it exists.
        lib = getattr(backend, "_lib", None)
        if lib:
            try:
                return getattr(lib, name)
            except AttributeError:
                pass
    
&gt;       raise AttributeError(
            f"The '{_current_backend}' backend (module {backend.__name__}) "
            f"has no attribute '{name}'."
        )
E       AttributeError: The 'numpy' backend (module optiland.backend.numpy_backend) has no attribute 'Tensor'.

optiland\backend\__init__.py:152: AttributeError</failure></testcase></testsuite></testsuites>