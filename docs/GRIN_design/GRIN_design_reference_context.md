

# Optilan GRIN Lens Support: Engineering Reference and Implementation Guide

## Introduction

This document provides a comprehensive engineering reference and implementation guide for integrating Gradient Refractive Index (GRIN) lens support into the Optiland optical design platform. The primary goal is to enable the accurate modeling of advanced optical systems, particularly biological models like the human eye, by implementing a `gradient3`-like surface type. This guide is based on the design and implementation plan [[1](https://github.com/HarrisonKramer/optiland)] and a subsequent deep evaluation report, both generated by an AI assistant. It aims to consolidate the architectural decisions, module definitions, key technical considerations, and the necessary context from the existing Optiland repository to facilitate a smooth and efficient development process. The successful implementation of GRIN lenses will significantly enhance Optiland's capabilities, making it a more versatile tool for researchers and engineers in ophthalmology, vision science, and other fields requiring advanced optical modeling.

The core of this implementation plan revolves around an axiomatic design approach, decomposing the GRIN lens problem into three independent functional requirements (FRs) and their corresponding design parameters (DPs): FR1 (Geometry) handled by a `GradientBoundarySurface` class, FR2 (Physical Properties) managed by a `GradientMaterial` class, and FR3 (Behavior) implemented via a `GradientPropagation` module. This decoupled design ensures modularity, testability, and extensibility, aligning with best practices in software engineering. This guide will delve into the specifics of each module, their interactions, and how they fit within Optiland's existing architecture, which primarily uses Python, NumPy for CPU-bound tasks, and PyTorch for GPU acceleration and autograd-enabled workflows [[0](https://github.com/HarrisonKramer/optiland)]. The focus will be on providing clear, actionable steps and highlighting critical integration points and potential challenges based on the analysis of available Optiland documentation and source code snippets.

## Understanding the Optiland Ecosystem

Before delving into the specifics of GRIN implementation, it's crucial to understand the existing Optiland ecosystem. Optiland is a Python-based, open-source framework designed for optical design, analysis, and optimization [[1](https://github.com/HarrisonKramer/optiland)]. Its architecture emphasizes a clean, Pythonic API, making it accessible for building, tracing, and analyzing complex lens and mirror systems [[1](https://github.com/HarrisonKramer/optiland)]. Under the hood, it leverages NumPy for efficient CPU calculations and PyTorch for GPU acceleration and automatic differentiation, offering flexibility for different computational needs [[0](https://github.com/HarrisonKramer/optiland)]. The system is built around several core concepts: Optics, Surfaces, Materials, Geometries, and Rays. An `Optic` object represents a complete optical system, which is essentially a collection of sequential `Surface` objects. Each `Surface` defines an optical boundary, characterized by its `Geometry` (shape), `Material` before and after the surface, and other properties like apertures and coatings. `Material` objects define the optical properties of a medium, primarily its refractive index. `Ray` objects encapsulate the properties of light rays as they propagate through the system. Understanding these core components and their interactions is paramount for integrating the new GRIN functionality seamlessly. The modularity of Optiland, as evidenced by its API for custom surface types [[12](https://optiland.readthedocs.io/en/latest/examples/Tutorial_10a_Custom_Surface_Types.html)] and its material system [[21](https://optiland.readthedocs.io/en/latest/api/api_materials.html)], provides a good foundation for extending its capabilities.

The `Surface` class is a central element in Optiland's ray tracing engine. As defined in `optiland/surfaces/standard_surface.py`, a `Surface` object is responsible for tracing rays through an optical interface, accounting for refraction, reflection, and absorption based on its geometry and the materials it separates [[14](https://optiland.readthedocs.io/en/stable/_modules/surfaces/standard_surface.html)]. It takes a `BaseGeometry` object to define its shape and two `BaseMaterial` objects for the media before and after the surface. The `trace` method within the `Surface` class, particularly `_trace_real` for real rays, handles the transformation of ray coordinates, propagation to the surface, interaction (refraction/reflection), and recording of ray data. This is a key integration point for GRIN functionality, as the standard tracing logic needs to be augmented or bypassed when entering a GRIN medium. The `Material` class hierarchy, with `BaseMaterial` as its root (though direct access to its definition in `optiland/materials/base.py` was problematic during the search phase, its existence and role are implied by the structure in `optiland/materials/material.py` [[34](https://optiland.readthedocs.io/en/stable/_modules/materials/material.html)] and tutorials like [[12](https://optiland.readthedocs.io/en/latest/examples/Tutorial_10a_Custom_Surface_Types.html)]), defines how optical properties are handled. Concrete material classes like `Material` (which queries a database) and `IdealMaterial` provide specific implementations for calculating refractive index `n(wavelength)`. The new `GradientMaterial` will extend this system to provide spatially varying refractive indices. Finally, the `Optic` class (likely in `optiland/optic.py`, though not directly accessed, its role is central to `Tutorial_2a_Tracing_%26_Analyzing_Rays.html` [[71](https://optiland.readthedocs.io/en/latest/examples/Tutorial_2a_Tracing_%26_Analyzing_Rays.html)]) orchestrates the overall ray tracing process by managing a sequence of surfaces and directing rays through them. Modifications to this orchestration or to the surface tracing logic will be necessary to identify and handle GRIN regions.

## Deep Dive into the GRIN Implementation Architecture

The proposed architecture for GRIN lens support, based on axiomatic design principles, is robust and well-considered. It breaks down the complex problem of GRIN lens modeling into three distinct, decoupled modules: `GradientBoundarySurface` for geometry, `GradientMaterial` for physical properties, and `GradientPropagation` for ray behavior. This approach aligns with software engineering best practices, promoting modularity, testability, and maintainability. Each module addresses a specific aspect of GRIN lens functionality, and their interaction will be managed by a modified ray tracing engine within Optiland. This section will explore each module in detail, referencing the provided design and evaluation documents, and integrating insights from the Optiland ecosystem.

**DP1: `GradientBoundarySurface` (Geometric Domain)**
The `GradientBoundarySurface` is intended to mark the entry point into a GRIN medium. It's proposed to inherit from `StandardSurface` [[1](https://github.com/HarrisonKramer/optilan)], effectively reusing all its geometric definition capabilities. The primary purpose of this class is to act as a "marker" interface. When the Optiland ray tracer encounters an instance of `GradientBoundarySurface`, it should recognize that the subsequent medium is a GRIN material and initiate the specialized GRIN tracing logic instead of the standard refraction/reflection calculations. The design `class GradientBoundarySurface(StandardSurface): pass` [[1](https://github.com/HarrisonKramer/optiland)] implies that no new methods are added; its distinct type is sufficient for the ray tracer to alter its behavior. The `material_post` attribute of this surface would typically be an instance of the `GradientMaterial` class (DP2). The critical aspect here is how the main ray tracing loop in Optiland (likely within the `Optic` class or a `SurfaceGroup` class) will identify this surface type. This will necessitate a check, probably using `isinstance(surface, GradientBoundarySurface)`. If true, the tracer should gather the `GradientMaterial` instance and the `exit_surface` (which could be the next surface in the optical system sequence or a specifically defined one) and then call the `propagate_through_gradient` function from DP3. The geometry of this surface, inherited from `StandardSurface`, defines the initial boundary where rays enter the GRIN medium. The `thickness` attribute associated with surfaces in Optiland might be used to define the extent of the GRIN medium along the optical axis if the exit surface is implicitly defined as a parallel surface at that thickness, or if the GRIN region is considered to span until the next distinct surface in the lens definition. The design document suggests `propagate_through_gradient(ray_in, grin_material, exit_surface)` [[1](https://github.com/HarrisonKramer/optiland)], which implies the `exit_surface` is explicitly passed. This suggests that the GRIN region is bounded by an entry surface (`GradientBoundarySurface`) and an exit surface (which could be any `Surface` type, likely another `GradientBoundarySurface` or a standard `Surface`).

**DP2: `GradientMaterial` (Physical Property Domain)**
The `GradientMaterial` class is responsible for encapsulating the physical properties of a GRIN medium, specifically the coefficients of a polynomial that defines the refractive index distribution `n(x, y, z)` and its gradient `∇n(x, y, z)` [[1](https://github.com/HarrisonKramer/optiland)]. It is proposed to inherit from `BaseMaterial`, aligning with Optiland's material hierarchy. The core of this class will be methods to calculate the refractive index and its gradient at any given spatial coordinate `(x, y, z)`. The design document mentions coefficients like `n0, nr2, nr4, nr6, nz1, nz2, nz3` [[1](https://github.com/HarrisonKramer/optiland)], suggesting a polynomial form such as `n(r, z) = n0 + nr2*r² + nr4*r⁴ + nr6*r⁶ + nz1*z + nz2*z² + nz3*z³` where `r² = x² + y²`. The `get_index_and_gradient(self, x, y, z)` method will be central, providing both `n` and `∇n` efficiently, as both are required by the RK4 solver in DP3. An important consideration is wavelength dependence. Standard Optiland materials have an `n(wavelength)` method. For GRIN materials, the coefficients themselves (e.g., `n0`, `nr2`) could be functions of wavelength to model dispersion. The initial design does not explicitly show wavelength as a parameter to `get_index_and_gradient`, but for full integration, this should be considered. The `BaseMaterial` class in Optiland, as suggested by its usage in `StandardSurface` [[14](https://optiland.readthedocs.io/en/stable/_modules/surfaces/standard_surface.html)] and the material tutorial [[12](https://optiland.readthedocs.io/en/latest/examples/Tutorial_10a_Custom_Surface_Types.html)], defines the interface for materials. The `GradientMaterial` must adhere to this interface where applicable, or provide new interfaces for its spatially dependent nature. For instance, the standard `n(wavelength)` method of a material might be ambiguous for a GRIN material. It could return the base refractive index `n0` at a given wavelength, or it might be more appropriate to rely on the new `get_index(x, y, z, wavelength)` method exclusively within the GRIN propagation logic. The immutability suggested for the GRIN coefficients in the evaluation report (using `@dataclass(frozen=True)`) is a good practice for preventing accidental modification and promoting a functional style, which can simplify reasoning and testing.

**DP3: `GradientPropagation` (Behavioral Domain)**
The `GradientPropagation` module houses the core algorithm for tracing rays through a GRIN medium. This involves numerically solving the ray equations, which describe the path of light in a medium with a continuously varying refractive index. The design document specifies the use of the Runge-Kutta 4th order (RK4) method for this numerical integration [[1](https://github.com/HarrisonKramer/optiland)]. The primary function will be `propagate_through_gradient(ray_in, grin_material, exit_surface)` [[1](https://github.com/HarrisonKramer/optiland)]. This function will take the initial ray state (position and direction) as it enters the GRIN medium, the `GradientMaterial` instance describing the medium, and the `exit_surface` marking the boundary of the GRIN medium. The RK4 algorithm iteratively calculates the ray's path by evaluating the derivatives of position and optical direction cosines (or simply direction vector normalized by refractive index) at intermediate points within each step. These derivatives depend on the local refractive index `n` and its gradient `∇n`, which are obtained by calling methods on the `grin_material` object. The process continues until the ray's path intersects the `exit_surface`. This intersection detection will likely involve using methods from the `exit_surface.geometry` object, such as a distance calculation or ray-surface intersection routine. A critical aspect of this propagation is the accurate accumulation of the Optical Path Difference (OPD), which is the integral of the refractive index along the ray's path (`∫n ds`). This OPD is crucial for subsequent wavefront analysis. The `RealRays` objects in Optiland carry an `opd` attribute [[14](https://optiland.readthedocs.io/en/stable/_modules/surfaces/standard_surface.html)], which must be updated by the `GradientPropagation` module. The evaluation report correctly identifies performance as a major concern for DP3. The RK4 loop, with its multiple calls to `get_index_and_gradient` and intersection checks, can be computationally intensive. Leveraging Optiland's backend system to support vectorized NumPy operations and, ideally, PyTorch for GPU acceleration will be vital for practical use, especially when tracing many rays. The evaluation report also mentions the possibility of adaptive step size control for RK4, which would be a valuable future enhancement for balancing accuracy and efficiency, though a fixed step size might be a starting point for implementation.

## Core Integration Logic and Modifications to Optiland

Integrating the new GRIN modules into Optiland's existing ray tracing framework is a critical step that requires careful consideration of the current control flow and data structures. The primary goal is to ensure that when a ray encounters a `GradientBoundarySurface`, the standard tracing logic is temporarily suspended, and the specialized `GradientPropagation` algorithm takes over until the ray exits the GRIN medium. This involves modifications to the core ray tracing loop, likely within the `Optic` class or a dedicated `SurfaceGroup` class that manages the sequence of surfaces.

The most likely point of integration is within the method responsible for tracing rays through a sequence of surfaces. In Optiland, this appears to be handled by an `Optic` instance which likely iterates through its list of `Surface` objects, calling their respective `trace` methods [[71](https://optiland.readthedocs.io/en/latest/examples/Tutorial_2a_Tracing_%26_Analyzing_Rays.html)] and [[14](https://optiland.readthedocs.io/en/stable/_modules/surfaces/standard_surface.html)]. The `_trace_real` method of the `Surface` class is where individual ray-surface interactions are computed. The modification would involve checking the type of the current surface before its standard `_trace_real` logic is fully executed. If the surface is an instance of `GradientBoundarySurface`, the following sequence of actions should occur:
1.  The ray is propagated to the geometric boundary defined by `GradientBoundarySurface`. This part might reuse existing propagation logic up to the point of intersection.
2.  The `material_post` of the `GradientBoundarySurface` is retrieved. This should be an instance of `GradientMaterial`.
3.  The `exit_surface` for the GRIN region must be determined. The design document's `propagate_through_gradient(ray_in, grin_material, exit_surface)` signature [[1](https://github.com/HarrisonKramer/optiland)] suggests this surface is an input. This could be the next surface in the `Optic`'s surface list, or it could be explicitly defined as part of the GRIN lens specification (e.g., a pair of `GradientBoundarySurface` objects defining the entry and exit). A simple approach might be to assume the GRIN region extends from the current `GradientBoundarySurface` to the *next* surface in the optical system definition, regardless of its type. This next surface would then serve as the `exit_surface`.
4.  The `propagate_through_gradient` function (from the `optiland.interactions.gradient_propagation` module) is called with the ray's state at the entry boundary, the `GradientMaterial` instance, and the determined `exit_surface`.
5.  The `propagate_through_gradient` function then executes the RK4 integration, updating the ray's position, direction, and OPD as it traverses the GRIN medium, until it intersects the `exit_surface`.
6.  Once `propagate_through_gradient` returns, the ray's state is now at the point of intersection with the `exit_surface`, having just left the GRIN medium. The standard ray tracing logic then resumes. This means the ray will now interact with the `exit_surface` according to *its* properties (e.g., refracting into the `material_post` of the `exit_surface` if it's a standard refractive surface). This implies that `propagate_through_gradient` should return the ray state *before* this final interaction with the `exit_surface`'s own material properties.

A key consideration is how the `thickness` parameter of surfaces is handled. In standard Optiland usage, `thickness` defines the distance to the next surface's vertex along the local z-axis. For a GRIN lens bounded by two `GradientBoundarySurface` instances, the `thickness` of the entry `GradientBoundarySurface` could define the axial extent of the GRIN medium, and the exit `GradientBoundarySurface` would be positioned accordingly. Alternatively, if the GRIN region is defined by a single `GradientBoundarySurface` at its entrance and extends until the *next* surface in the sequence (whatever its type), then the `thickness` of the `GradientBoundarySurface` might be used differently or ignored by the GRIN propagation logic, which would instead rely on the actual geometric intersection with the next surface. The design document suggests `GradientBoundarySurface` inherits `StandardSurface` and has `self.thickness = 0.0` in its reset, but also allows `thickness` as an argument in the conceptual initializer. This needs clarification. If `GradientBoundarySurface` is purely a marker for the *start* of a GRIN region defined by its `material_post` being a `GradientMaterial`, and this region persists until the `material_post` of subsequent surfaces is no longer a `GradientMaterial` (or until a paired exit marker surface), then the `thickness` of the marker surface itself might be less relevant to the GRIN propagation's spatial extent, which is determined by the geometry of the entry and exit boundaries.

The interaction between the `GradientBoundarySurface`'s own refractive properties and the GRIN propagation also needs careful handling. When a ray first hits the `GradientBoundarySurface`, there is an interface between the `material_pre` (e.g., air) and the GRIN material. A standard Snell's law refraction should occur at this boundary, using the refractive index of `material_pre` and the refractive index of the GRIN material *at the point of entry on the boundary* (e.g., `n0` if the GRIN polynomial is `n(r,z) = n0 + ...`). This refracted ray then becomes the input for the `propagate_through_gradient` function. The `_interact` method in `StandardSurface` [[14](https://optiland.readthedocs.io/en/stable/_modules/surfaces/standard_surface.html)] handles this initial refraction/reflection based on `material_pre.n` and `material_post.n`. If `material_post` is a `GradientMaterial`, its `n` method (or a specific evaluation at the boundary point) would be used. The `GradientPropagation` module then takes over for the path *within* the GRIN volume. When the ray, as calculated by `GradientPropagation`, reaches the `exit_surface`, it will then interact with that `exit_surface`'s `material_pre` (which would be the GRIN material) and `material_post` (the medium after the GRIN lens). This final interaction would be handled by the standard tracing logic of the `exit_surface`.

## Detailed Engineering Reference

This section provides a more detailed engineering reference for the new components and modifications, outlining suggested file locations, class definitions, method signatures, and key implementation considerations based on the provided documents and analysis of Optiland's structure.

**A. New File: `optiland/surfaces/gradient_surface.py`**
This file will define the `GradientBoundarySurface` class.

```python
# optiland/surfaces/gradient_surface.py
"""
Defines the GradientBoundarySurface class, which marks the entry into a
gradient-index medium.
"""
from __future__ import annotations

from optiland.surfaces.standard_surface import StandardSurface
from optiland.geometries.base_geometry import BaseGeometry # Assuming BaseGeometry path
from optiland.materials.base_material import BaseMaterial # Assuming BaseMaterial path
# from optiland.physical_apertures import BaseAperture # If needed for type hinting
# from optiland.coatings import BaseCoating # If needed for type hinting

class GradientBoundarySurface(StandardSurface):
    """
    A surface that marks the entry into a gradient-index (GRIN) medium.
    Its geometric properties are inherited from StandardSurface, allowing it
    to define any standard shape (sphere, conic, asphere, etc.).
    Its primary role is to signal to the ray tracing engine that the
    subsequent medium (material_post) is a GRIN material and that
    specialized GRIN propagation logic should be initiated.

    The GRIN region is assumed to extend from this surface until the
    next surface in the optical system definition, which acts as the
    exit boundary for the GRIN medium.
    """
    def __init__(
        self,
        geometry: BaseGeometry,
        material_pre: BaseMaterial,
        material_post: BaseMaterial, # Expected to be a GradientMaterial instance
        is_stop: bool = False,
        aperture: float | BaseAperture = None, # BaseAperture might be from optiland.physical_apertures
        coating = None, # BaseCoating type
        bsdf = None, # BaseBSDF type
        is_reflective: bool = False,
        comment: str = "",
        # thickness is implicitly handled by the optic's surface list
        # and the geometry of the exit surface for GRIN propagation.
    ):
        """
        Initializes the GradientBoundarySurface.

        Args:
            geometry (BaseGeometry): The geometry of the GRIN entry boundary.
            material_pre (BaseMaterial): The material before the GRIN entry surface.
            material_post (BaseMaterial): The GRIN material after the entry surface.
            is_stop (bool): True if this surface is the aperture stop.
            aperture: The physical aperture definition.
            coating: The coating applied to the surface.
            bsdf: The Bidirectional Scattering Distribution Function.
            is_reflective (bool): True if the surface is reflective.
            comment (str): A comment for the surface.
        """
        super().__init__(
            geometry=geometry,
            material_pre=material_pre,
            material_post=material_post,
            is_stop=is_stop,
            aperture=aperture,
            coating=coating,
            bsdf=bsdf,
            is_reflective=is_reflective,
            comment=comment,
        )
        # No additional attributes or methods are strictly necessary if this class
        # solely acts as a type marker. The ray tracing engine will use
        # isinstance() checks.

    # The trace() method from StandardSurface will be inherited.
    # The main ray tracing loop will be modified to detect this specific
    # surface type and invoke the GRIN propagation logic.
```

**B. New File: `optiland/materials/gradient_material.py`**
This file will define the `GradientMaterial` class.

```python
# optiland/materials/gradient_material.py
"""
Defines the GradientMaterial class, which represents a material with a
spatially varying refractive index defined by a polynomial.
"""
from __future__ import annotations

import optiland.backend as be # For be.sqrt, be.sum, etc.
from optiland.materials.base_material import BaseMaterial # Assuming BaseMaterial path

class GradientMaterial(BaseMaterial):
    """
    A material with a refractive index defined by a polynomial in r and z,
    where r^2 = x^2 + y^2.

    The refractive index n is given by:
    n(x, y, z, wavelength) = n0(wavelength) +
                              nr2(wavelength)*r^2 + nr4(wavelength)*r^4 + nr6(wavelength)*r^6 +
                              nz1(wavelength)*z   + nz2(wavelength)*z^2   + nz3(wavelength)*z^3

    For initial implementation, coefficients can be wavelength-independent.
    Future extensions could make coefficients functions of wavelength.
    """
    def __init__(
        self,
        n0: float = 1.0,
        nr2: float = 0.0,
        nr4: float = 0.0,
        nr6: float = 0.0,
        nz1: float = 0.0,
        nz2: float = 0.0,
        nz3: float = 0.0,
        name: str = "GRIN Material",
        # Consider adding wavelength dispersion models for coefficients if needed
    ):
        """
        Initializes the GradientMaterial.

        Args:
            n0 (float): The base refractive index (constant term).
            nr2 (float): Coefficient for the r^2 term.
            nr4 (float): Coefficient for the r^4 term.
            nr6 (float): Coefficient for the r^6 term.
            nz1 (float): Coefficient for the z term.
            nz2 (float): Coefficient for the z^2 term.
            nz3 (float): Coefficient for the z^3 term.
            name (str): Name of the GRIN material.
        """
        super().__init__(name=name) # Assuming BaseMaterial takes a name
        self.n0 = n0
        self.nr2 = nr2
        self.nr4 = nr4
        self.nr6 = nr6
        self.nz1 = nz1
        self.nz2 = nz2
        self.nz3 = nz3
        # Store coefficients in a be.array for potential vectorization
        # self.coeffs = be.array([n0, nr2, nr4, nr6, nz1, nz2, nz3])

    def n(self, wavelength: float) -> float:
        """
        Provides the base refractive index n0 for compatibility with
        BaseMaterial interface, if needed by other parts of Optiland that
        expect a simple n(wavelength).
        For GRIN, the spatially varying n is obtained via get_index_and_gradient.
        """
        # This might need adjustment. If BaseMaterial.n is abstract, it must be implemented.
        # If GRIN materials are only used via get_index_and_gradient, this could raise
        # NotImplementedError or return n0.
        return self.n0 # Or a wavelength-dependent n0 if dispersion is modeled for n0

    def k(self, wavelength: float) -> float:
        """
        Extinction coefficient. For ideal GRIN materials, this is often 0.
        """
        # Assuming BaseMaterial requires k(wavelength) to be implemented.
        return 0.0

    def get_index_and_gradient(self, x, y, z, wavelength: float = None):
        """
        Calculates the refractive index n and its gradient (dn/dx, dn/dy, dn/dz)
        at a given point (x, y, z).

        Args:
            x, y, z (float or be.array): Spatial coordinates.
            wavelength (float, optional): Wavelength. Currently not used for
                                         coefficient dispersion but kept for
                                         future extensibility.

        Returns:
            tuple: (n, grad_n)
                n (float or be.array): Refractive index at (x, y, z).
                grad_n (be.array): Gradient of refractive index [dn/dx, dn/dy, dn/dz].
        """
        r2 = x**2 + y**2

        # Calculate refractive index n
        # For simplicity, coefficients are currently wavelength-independent.
        # If dispersion is added, n0, nr2, etc., would be functions of wavelength.
        n_val = (self.n0 +
                 self.nr2 * r2 +
                 self.nr4 * r2**2 +
                 self.nr6 * r2**3 +
                 self.nz1 * z +
                 self.nz2 * z**2 +
                 self.nz3 * z**3)

        # Calculate gradient of refractive index grad_n = [dn/dx, dn/dy, dn/dz]
        # dn/dr2 = nr2 + 2*nr4*r2 + 3*nr6*r2^2
        dn_dr2 = self.nr2 + 2.0 * self.nr4 * r2 + 3.0 * self.nr6 * r2**2
        
        # Handle x=0, y=0 for d/dx and d/dy to avoid division by zero if r=0
        # if r2 is 0, then x and y are 0, so derivatives involving x/r or y/r need care.
        # dn/dx = dn/dr2 * dr2/dx = dn_dr2 * 2x. If x=0, dn/dx = 0.
        # dn/dy = dn/dr2 * dr2/dy = dn_dr2 * 2y. If y=0, dn/dy = 0.
        dn_dx = 2.0 * x * dn_dr2
        dn_dy = 2.0 * y * dn_dr2
        
        dn_dz = (self.nz1 +
                 2.0 * self.nz2 * z +
                 3.0 * self.nz3 * z**2)

        grad_n_val = be.array([dn_dx, dn_dy, dn_dz])
        return n_val, grad_n_val

    def to_dict(self) -> dict:
        """Returns a dictionary representation of the GRIN material."""
        # BaseMaterial.to_dict() might exist. Call it and extend.
        # For now, assuming a simple structure.
        data = super().to_dict() # If BaseMaterial has to_dict
        data.update({
            "type": self.__class__.__name__,
            "n0": self.n0, "nr2": self.nr2, "nr4": self.nr4, "nr6": self.nr6,
            "nz1": self.nz1, "nz2": self.nz2, "nz3": self.nz3,
            "name": self.name
        })
        return data

    @classmethod
    def from_dict(cls, data: dict):
        """Creates a GRIN material from a dictionary representation."""
        # BaseMaterial.from_dict might exist.
        # For now, assuming a simple structure.
        return cls(
            n0=data.get("n0", 1.0), nr2=data.get("nr2", 0.0),
            nr4=data.get("nr4", 0.0), nr6=data.get("nr6", 0.0),
            nz1=data.get("nz1", 0.0), nz2=data.get("nz2", 0.0),
            nz3=data.get("nz3", 0.0),
            name=data.get("name", "GRIN Material")
        )

```

**C. New File: `optiland/interactions/gradient_propagation.py`**
This file will contain the GRIN ray propagation logic.

```python
# optiland/interactions/gradient_propagation.py
"""
Implements the ray tracing algorithm for propagation through a
gradient-index (GRIN) medium using the Runge-Kutta 4th order (RK4) method.
"""
from __future__ import annotations

import optiland.backend as be # For be.array, be.linalg.norm, etc.
# from optiland.rays import RealRays # Assuming RealRays path and structure
# from optiland.materials.gradient_material import GradientMaterial # For type hinting
# from optiland.surfaces.standard_surface import Surface # For type hinting exit_surface

# Define Ray class or structure if not directly importing RealRays for manipulation
# For now, assume rays are represented by position (3-array) and direction (3-array)
# and an OPD value. The actual Optiland RealRays object will be more complex.

class RayState:
    def __init__(self, position, direction, wavelength, opd=0.0):
        self.position = be.array(position, dtype=be.float64)
        self.direction = be.array(direction, dtype=be.float64)
        self.direction = self.direction / be.linalg.norm(self.direction) # Normalize
        self.wavelength = wavelength
        self.opd = opd

def _ray_derivatives(ray_state: RayState, grin_material, current_params):
    """
    Calculates the derivatives of ray position and optical direction cosines (p = n*s).
    The ray equations are:
    d(r)/ds = p / n^2  (where p = n * dr/ds_optical, s_optical is optical path length)
                   or dr/ds_geom = s_unit_vector (s_geom is geometric path length)
    d(p)/ds = grad(n)  (where p = n * dr/ds_geom, s_geom is geometric path length)
    Let's use s as geometric path length. L, M, N are direction cosines.
    d(x,y,z)/ds = (L, M, N)
    d(L,M,N)/ds = (1/n) * (dn/dx - L*(L*dn/dx + M*dn/dy + N*dn/dz)), etc.
                 = (1/n) * (grad_n - (s_vec . grad_n) * s_vec)
    """
    x, y, z = ray_state.position
    L, M, N = ray_state.direction
    
    n, grad_n = grin_material.get_index_and_gradient(x, y, z, ray_state.wavelength)
    dn_dx, dn_dy, dn_dz = grad_n

    if n == 0: # Avoid division by zero
        n = 1e-9 

    # Derivative of position components
    dx_ds = L
    dy_ds = M
    dz_ds = N
    
    # Derivative of direction cosines
    # s_vec . grad_n
    s_dot_grad_n = L * dn_dx + M * dn_dy + N * dn_dz
    
    dL_ds = (1.0 / n) * (dn_dx - L * s_dot_grad_n)
    dM_ds = (1.0 / n) * (dn_dy - M * s_dot_grad_n)
    dN_ds = (1.0 / n) * (dn_dz - N * s_dot_grad_n)
    
    # Return derivatives of [x, y, z, L, M, N]
    return be.array([dx_ds, dy_ds, dz_ds, dL_ds, dM_ds, dN_ds])


def propagate_through_gradient(
    ray_in: RayState, # Or adapt to take/return Optiland's RealRays
    grin_material, # GradientMaterial instance
    exit_surface, # Surface instance (its geometry will be used)
    step_size: float = 1e-4, # Geometric step size for RK4
    max_steps: int = 100000,
    intersection_tolerance: float = 1e-7
) -> RayState:
    """
    Traces a ray through a GRIN medium using the RK4 method.

    Args:
        ray_in (RayState): The initial ray state at the GRIN entry boundary.
        grin_material (GradientMaterial): The GRIN material object.
        exit_surface (Surface): The surface marking the exit of the GRIN medium.
        step_size (float): The step size for the RK4 integration.
        max_steps (int): Maximum number of RK4 steps to prevent infinite loops.
        intersection_tolerance (float): Tolerance for finding intersection with exit_surface.

    Returns:
        RayState: The ray state at the point of intersection with the exit_surface,
                  just before exiting the GRIN medium.
    
    Raises:
        RuntimeError: If max_steps is reached or other numerical issues occur.
    """
    current_ray = RayState(
        position=ray_in.position.copy(),
        direction=ray_in.direction.copy(),
        wavelength=ray_in.wavelength,
        opd=ray_in.opd
    )

    for i in range(max_steps):
        # RK4 integration for y' = f(s, y), where y = [x,y,z,L,M,N]
        # k1 = f(s, y)
        k1 = _ray_derivatives(current_ray, grin_material, None)
        
        # k2 = f(s + h/2, y + k1*h/2)
        ray_k2_pos = current_ray.position + 0.5 * step_size * k1[0:3]
        ray_k2_dir = current_ray.direction + 0.5 * step_size * k1[3:6]
        ray_k2_dir = ray_k2_dir / be.linalg.norm(ray_k2_dir) # Renormalize direction
        ray_state_k2 = RayState(ray_k2_pos, ray_k2_dir, current_ray.wavelength)
        k2 = _ray_derivatives(ray_state_k2, grin_material, None)

        # k3 = f(s + h/2, y + k2*h/2)
        ray_k3_pos = current_ray.position + 0.5 * step_size * k2[0:3]
        ray_k3_dir = current_ray.direction + 0.5 * step_size * k2[3:6]
        ray_k3_dir = ray_k3_dir / be.linalg.norm(ray_k3_dir) # Renormalize direction
        ray_state_k3 = RayState(ray_k3_pos, ray_k3_dir, current_ray.wavelength)
        k3 = _ray_derivatives(ray_state_k3, grin_material, None)

        # k4 = f(s + h, y + k3*h)
        ray_k4_pos = current_ray.position + step_size * k3[0:3]
        ray_k4_dir = current_ray.direction + step_size * k3[3:6]
        ray_k4_dir = ray_k4_dir / be.linalg.norm(ray_k4_dir) # Renormalize direction
        ray_state_k4 = RayState(ray_k4_pos, ray_k4_dir, current_ray.wavelength)
        k4 = _ray_derivatives(ray_state_k4, grin_material, None)

        # y_new = y + (h/6) * (k1 + 2*k2 + 2*k3 + k4)
        new_pos = current_ray.position + (step_size / 6.0) * (k1[0:3] + 2*k2[0:3] + 2*k3[0:3] + k4[0:3])
        new_dir_vec = current_ray.direction + (step_size / 6.0) * (k1[3:6] + 2*k2[3:6] + 2*k3[3:6] + k4[3:6])
        new_dir = new_dir_vec / be.linalg.norm(new_dir_vec) # Renormalize

        # Calculate OPD for this step: integral of n ds
        # Approximate using average n over the step
        n_current, _ = grin_material.get_index_and_gradient(current_ray.position[0], current_ray.position[1], current_ray.position[2], current_ray.wavelength)
        n_new, _ = grin_material.get_index_and_gradient(new_pos[0], new_pos[1], new_pos[2], current_ray.wavelength)
        opd_increment = 0.5 * (n_current + n_new) * step_size
        
        # Check for intersection with exit_surface along the segment from current_ray.position to new_pos
        # This requires a ray-surface intersection method that can take a segment.
        # exit_surface.geometry.distance(ray_starting_at_current_ray.position_towards_new_pos)
        # Let's assume exit_surface.geometry has a method `intersect_segment(ray_origin, ray_end)`
        # which returns distance t if 0 <= t <= 1, or None.
        
        # Placeholder for intersection logic:
        # This part is highly dependent on Optiland's geometry API.
        # A common approach is to create a temporary ray for the segment.
        segment_direction = new_pos - current_ray.position
        segment_length = be.linalg.norm(segment_direction)
        if segment_length > 1e-12: # Avoid zero-length segments
            # Create a temporary ray for intersection testing with the exit surface's geometry
            # This temp_ray needs position and normalized direction.
            temp_ray_dir = segment_direction / segment_length
            # Assuming exit_surface.geometry has an 'intersect' method that takes ray origin and direction
            # and returns the distance to the intersection point.
            # dist_to_exit = exit_surface.geometry.intersect(current_ray.position, temp_ray_dir)
            
            # If dist_to_exit is not None and 0 <= dist_to_exit <= segment_length:
            #    Intersection found within this RK4 step.
            #    actual_intersection_point = current_ray.position + dist_to_exit * temp_ray_dir
            #    # Refine ray state at actual_intersection_point if necessary (e.g., interpolate)
            #    # For now, assume new_pos is close enough or we use the intersection point.
            #    current_ray.position = actual_intersection_point # Or new_pos if intersection is at new_pos
            #    # Direction at exit point needs to be calculated carefully.
            #    # It might be new_dir, or an interpolated direction.
            #    current_ray.direction = new_dir # Or a more accurate direction at intersection
            #    current_ray.opd += opd_increment * (dist_to_exit / segment_length) # Scale OPD
            #    return current_ray # Ray has exited GRIN medium
            # else: # No intersection in this segment, continue RK4
            #    current_ray.position = new_pos
            #    current_ray.direction = new_dir
            #    current_ray.opd += opd_increment
            pass # Placeholder: Actual intersection logic with Optiland's geometry API

        # If no intersection, update ray state for next step
        current_ray.position = new_pos
        current_ray.direction = new_dir
        current_ray.opd += opd_increment

    # If loop finishes, max_steps reached
    raise RuntimeError(f"GRIN propagation did not reach exit surface after {max_steps} steps.")

```

**D. Modifications to Existing Optiland Files**

1.  **`optiland/surfaces/__init__.py`**:
    *   Add `from .gradient_surface import GradientBoundarySurface`.

2.  **`optiland/materials/__init__.py`**:
    *   Add `from .gradient_material import GradientMaterial`.

3.  **`optiland/interactions/__init__.py`** (if it exists, or create it):
    *   Add `from .gradient_propagation import propagate_through_gradient, RayState` (if RayState is defined there).

4.  **Core Ray Tracing Logic (e.g., in `optiland/optic.py` or `optiland/surface_group.py`)**:
    *   Identify the main loop that iterates through surfaces and calls their `trace` methods.
    *   Modify this loop. Before calling `surface.trace(rays)` for a given surface:
        *   Check `if isinstance(surface, GradientBoundarySurface) and isinstance(surface.material_post, GradientMaterial):`
        *   If true:
            1.  Determine the `exit_surface`. A simple strategy: `exit_surface = surfaces[i+1]` if `i` is the current surface index. Ensure `i+1` is valid.
            2.  Propagate rays to the geometric boundary of the current `GradientBoundarySurface` (this might be part of the standard `surface.trace`'s initial propagation).
            3.  For each ray (or batch of rays for vectorization):
                *   Get its state (position, direction, wavelength, current OPD) at the entry point.
                *   Create an initial `RayState` object.
                *   Call `propagated_ray_state = propagate_through_gradient(initial_ray_state, surface.material_post, exit_surface.geometry, ...)`
                *   Update the original ray object's properties (position, direction, OPD) with `propagated_ray_state`.
            4.  After `propagate_through_gradient` completes for all rays, these rays are now at the `exit_surface` boundary, having traversed the GRIN medium.
            5.  The standard ray tracing logic should then proceed to trace these rays through the `exit_surface` itself using `exit_surface.trace(rays)`. This will handle the interaction between the GRIN material (as `exit_surface.material_pre`) and the material after the GRIN lens (`exit_surface.material_post`).
            6.  Skip the original `surface.trace(rays)` call for the `GradientBoundarySurface` if its logic is fully superseded by the GRIN propagation and the subsequent `exit_surface.trace`. Or, ensure `GradientBoundarySurface.trace` only handles the initial entry interface refraction.

    *   This modification requires careful handling of ray data structures. Optiland's `RealRays` likely stores data for many rays simultaneously (e.g., as NumPy/PyTorch arrays). The `propagate_through_gradient` function should ideally be vectorized to handle all rays at once, or loop through them if vectorization across rays is too complex for the RK4 logic.

## Testing Strategy and Performance Considerations

A robust testing strategy and careful attention to performance are crucial for the successful integration of GRIN lens support into Optiland. Given the numerical nature of GRIN ray tracing, thorough testing will ensure accuracy and reliability, while performance optimizations will make the feature practical for complex optical design tasks.

**Testing Strategy:**
1.  **Unit Tests for `GradientMaterial`**:
    *   Verify that `get_index_and_gradient` correctly computes `n` and `∇n` for various known GRIN distributions (e.g., constant index, linear gradient, simple radial gradient).
    *   Test with different coordinate points, including points on the optical axis and off-axis.
    *   If wavelength dispersion is implemented for GRIN coefficients, test the variation of `n` and `∇n` with wavelength.
2.  **Unit Tests for `GradientPropagation`**:
    *   Test the RK4 solver against analytical solutions for simple GRIN profiles where ray paths can be calculated exactly (e.g., linear gradient slabs, specific radial GRIN lenses with known ray equations).
    *   Verify the accuracy of intersection detection with various `exit_surface` geometries (planes, spheres).
    *   Check the correct accumulation of Optical Path Difference (OPD) by comparing with analytical integrals for simple paths and GRIN profiles.
    *   Test edge cases, such as rays that barely graze the GRIN medium or rays that might undergo total internal reflection within the GRIN medium if the gradient permits (though the current polynomial model might not easily support strong gradients leading to TIR within the medium).
    *   Test the behavior when `max_steps` is reached or other numerical instabilities occur.
3.  **Integration Tests**:
    *   Construct simple optical systems containing a GRIN lens (e.g., a GRIN rod between two plane parallel surfaces, or a GRIN singlet).
    *   Trace rays through these systems and compare results (spot diagrams, ray paths, OPD maps) with known analytical solutions or results from established optical design software like Zemax (if available for validation).
    *   Test the interaction of `GradientBoundarySurface` with various other surface types before and after the GRIN medium.
    *   Ensure that the overall `Optic` class correctly manages ray tracing through sequences involving GRIN media.
4.  **Regression Tests**:
    *   Once GRIN functionality is integrated, add specific GRIN test cases to Optiland's existing test suite to prevent future regressions.

**Performance Considerations:**
1.  **Vectorization**:
    *   The `GradientMaterial.get_index_and_gradient` method should be implemented to handle NumPy arrays for `x, y, z` coordinates, allowing simultaneous computation for many rays.
    *   The core RK4 loop within `propagate_through_gradient` is inherently sequential for each step. However, if Optiland's `RealRays` class manages a batch of rays (e.g., as arrays where each column is a ray), the RK4 calculations for *all rays* at each RK4 sub-step (`k1`, `k2`, `k3`, `k4`) should be vectorized. This means operations on arrays of ray positions and directions.
2.  **Backend Integration (NumPy/PyTorch)**:
    *   Ensure all numerical computations in `GradientMaterial` and `GradientPropagation` use `optiland.backend` functions (e.g., `be.sqrt`, `be.sum`, `be.array`). This allows seamless switching between NumPy (CPU) and PyTorch (GPU/autograd) backends as per Optiland's design.
    *   For PyTorch, this means that ray data (positions, directions) and GRIN coefficients should be PyTorch tensors. The RK4 computations will then run on the GPU if a CUDA device is available.
3.  **Algorithmic Optimizations**:
    *   **Adaptive Step Size (RK45)**: The initial implementation uses a fixed RK4 step size. For improved performance and accuracy, especially in regions of high gradient or strong ray curvature, implementing an adaptive step size method like Runge-Kutta-Fehlberg (RKF45) is highly recommended. This method estimates the local truncation error at each step and adjusts the step size accordingly.
    *   **Intersection Optimization**: The check for intersection with the `exit_surface` within the RK4 step can be costly. Optimizing this, perhaps by less frequent checks or efficient spatial data structures if surfaces are complex, might be necessary for very demanding applications.
4.  **Profiling**:
    *   Use Python's profiling tools (e.g., `cProfile`) to identify bottlenecks in the GRIN ray tracing code once implemented. Focus optimization efforts on the most computationally intensive parts, which are likely to be the `get_index_and_gradient` calls within the RK4 loop and the intersection checks.

By adopting a comprehensive testing strategy and proactively addressing performance considerations, the GRIN lens feature can be made both robust and efficient, significantly enhancing Optiland's capabilities for advanced optical modeling. The modular design proposed will aid in testing individual components in isolation before full integration.

## Conclusion and Future Work

The implementation of GRIN lens support, as outlined in this engineering reference guide, represents a significant advancement for the Optiland platform. By adhering to the principles of axiomatic design and carefully integrating the new `GradientBoundarySurface`, `GradientMaterial`, and `GradientPropagation` modules, Optiland will gain the capability to model a wider class of advanced optical systems, particularly those found in biological optics and other cutting-edge applications. The modular approach not only facilitates the current implementation but also provides a solid foundation for future enhancements and extensions.

**Summary of Key Aspects:**
*   **Modular Architecture**: The separation of concerns into geometry (`GradientBoundarySurface`), physics (`GradientMaterial`), and behavior (`GradientPropagation`) ensures a clean, maintainable, and extensible design.
*   **Integration with Optiland Ecosystem**: The new modules are designed to fit within Optiland's existing framework of `Surfaces`, `Materials`, `Geometries`, and `Rays`, leveraging its backend abstraction for NumPy/PyTorch compatibility.
*   **Core Algorithm**: The use of the RK4 method for ray tracing in GRIN media provides a good balance between accuracy and computational complexity, with a clear path towards adaptive step size control in the future.
*   **Focus on Testability and Performance**: The design considerations include strategies for thorough unit and integration testing, as well as performance optimization through vectorization and backend integration.

**Future Work and Potential Extensions:**
1.  **Advanced GRIN Profiles**: While the current implementation focuses on a specific polynomial form, future work could involve supporting a wider variety of GRIN profiles, such as:
    *   Different polynomial bases or user-defined GRIN functions.
    *   Tabulated GRIN data (e.g., from measurements or more complex simulations).
    *   GRIN materials with anisotropic refractive index properties.
2.  **Enhanced Numerical Methods**:
    *   Implementation of adaptive step size control (e.g., RKF45) for improved efficiency and robustness of the GRIN ray tracer.
    *   Exploration of higher-order or specialized integration methods for specific types of GRIN distributions.
3.  **Full Wavelength Dispersion for GRIN**: Extending `GradientMaterial` to allow all GRIN coefficients (`n0`, `nr2`, etc.) to be functions of wavelength, enabling accurate modeling of chromatic effects in GRIN lenses.
4.  **Non-Sequential GRIN Tracing**: Extending GRIN support to non-sequential ray tracing modes, which would be essential for modeling scattering or complex light paths within GRIN elements.
5.  **Optimization with GRIN Elements**: Leveraging Optiland's optimization framework, particularly its PyTorch backend for automatic differentiation, to optimize GRIN lens parameters (coefficients, geometry) for specific optical performance goals. This would be a powerful capability for GRIN lens design.
6.  **Thermal GRIN Effects**: Modeling how GRIN profiles change with temperature, which can be important for precision optical systems.
7.  **Visualization Tools**: Enhancing Optiland's visualization capabilities to graphically represent GRIN index distributions and ray paths within GRIN media, aiding in design and analysis.

The successful implementation of the core GRIN functionality will open up these exciting avenues for further development, solidifying Optiland's position as a versatile and powerful open-source optical design platform. The detailed engineering reference provided herein aims to empower developers to undertake this implementation with a clear understanding of the requirements, design choices, and integration pathways.

# References

[0] HarrisonKramer/optiland. https://github.com/HarrisonKramer/optiland.

[1] GRIN Lens Support: Design and Implementation Plan. https://github.com/HarrisonKramer/optiland.

[12] Tutorial 10a - Custom Surface Types — Optiland 0.5.6 documentation. https://optiland.readthedocs.io/en/latest/examples/Tutorial_10a_Custom_Surface_Types.html.

[14] surfaces.standard_surface — Optiland 0.5.6 documentation. https://optiland.readthedocs.io/en/stable/_modules/surfaces/standard_surface.html.

[21] Materials — Optiland 0.5.6 documentation. https://optiland.readthedocs.io/en/latest/api/api_materials.html.

[34] materials.material — Optiland 0.5.6 documentation. https://optiland.readthedocs.io/en/stable/_modules/materials/material.html.

[71] Tutorial 2a - Tracing and Analyzing Rays — Optiland 0.5.6 documentation. https://optiland.readthedocs.io/en/latest/examples/Tutorial_2a_Tracing_%26_Analyzing_Rays.html.